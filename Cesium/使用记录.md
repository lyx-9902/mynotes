# Cesium 禁止鼠标调整视角（左键拖动，中键旋转，缩放）

https://blog.csdn.net/qq_17627195/article/details/127652149?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-127652149-blog-137514691.235%5Ev43%5Econtrol&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-127652149-blog-137514691.235%5Ev43%5Econtrol&utm_relevant_index=12

### 3D视图

**1. 禁止左键拖动视角**
`false` 就是禁止，`true` 就是允许

```
viewer.scene.screenSpaceCameraController.enableRotate = false;
```

**2. 禁止中键控制视角缩放**
`false` 就是禁止，`true` 就是允许

```
viewer.scene.screenSpaceCameraController.enableZoom = false;

```

**3. 禁止中键旋转视角**
`false` 就是禁止，`true` 就是允许

```
viewer.scene.screenSpaceCameraController.enableTilt = false;
// 或
viewer.scene.screenSpaceCameraController.tiltEventTypes = [];

```

### 2D和哥伦布视图

**1. 禁止左键拖动视角**
`false` 就是禁止，`true` 就是允许

```
viewer.scene.screenSpaceCameraController.enableTranslate = true;

```

## Cesium orientation

### 基本概念

项目案例：

```js
  viewer.camera.flyTo({
    destination: {  // 地图坐标  笛卡尔坐标系
      x:  -2122206.1856142753,
      y: 4801583.554137398,
      z: 3610238.5181876095,
    },
    orientation: {
      heading: 6.283185307179586,
      pitch: -1.4234550901004552,
      roll: 6.283185307179586,
    },
    duration: 3,
    complete: () => {
    },
  });

笛卡尔坐标写法：两种 下面这种也可以使用。 依次对应 x y z
   viewer.camera.setView({
      // 设置相机位置
      // destination: new Cesium.Cartesian3(
      //   -2303483.424908539,
      //   4398785.994919332,
      //   3994319.720824991
      // ),
      destination: new Cesium.Cartesian3(
        -2304790.1630889364,
         4401050.1852176,
         3996166.811386653
      ),
      orientation: {
        heading: 6.281099725315646,
        pitch: -1.5214111229730496,
        roll: 0,
      },
    });


```

orientation-相机镜头对准的方法
heading-代表镜头左右方向,正值为右,负值为左,360度和0度是一样的

pitch-代表镜头上下方向,正值为上,负值为下.

roll-代表镜头左右倾斜.正值,向右倾斜,负值向左倾斜

![](https://s2.51cto.com/images/blog/202302/27151743_63fc5917de8a615410.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184)

### 如何获取想要的参数

1.先用鼠标手动调整出你想要的角度（自己初始化的Cesium地图）

2.打印出你调整好位置的实例的参数

```
console.log(viewer.scene.camera.heading);
console.log(viewer.scene.camera.pitch);
console.log(viewer.scene.camera.roll)
console.log(viewer.scene.camera.position)
```



### viewer.camera.flyTo

```js
// 俯视整个园区
function flytoAll() {
  viewer.camera.flyTo({
    destination: Cesium.Cartesian3.fromDegrees( 
    113.8445722054053 ,
    34.69626278721039,
    430
    ),//经纬度 高度 (经纬度坐标系/笛卡尔坐标系都可以)
    orientation: {
      heading: 0.02401463174352081,
      pitch: -0.36569983707142595,
      roll: 6.283160003679934
    },
    duration: 3,
    complete: () => {
    },
  });
}
```



## 矩形框区域视角

### flyHome

默认位置 Cesium.Camera.DEFAULT_VIEW_RECTANGLE（默认视角矩形框），视角由一个矩形组成。

```js
Cesium.Camera.DEFAULT_VIEW_RECTANGLE = Cesium.Rectangle.fromDegrees(119.9, 30.7501282784158, 121.33, 31.9645982738191);
// 将相机飞到主视图,即默认矩形框区域。
let duration = 2;
viewer.camera.flyHome(duration)

```

在 Cesium.Rectangle.fromDegrees()中，传入的四个参数分别为最西边坐标点的经度，最南边左边点的纬度，最东边坐标点的经度，最南边坐标点的维度，是矩形框四个坐标点的集合。
duration表示飞行的持续时间，可以不传。默认值为Cesium根据需要行驶的距离来计算飞行持续时间。
————————————————

                            版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。

原文链接：https://blog.csdn.net/ekcchina/article/details/130258271

### lookAt

场景视角锁定，拖动视图主要以小球视角进行环绕查看。使用目标和偏移量设置相机位置和方向。

```js
const center =  Cesium.Cartesian3.fromDegrees(118.923, 32.482,)  // 目标位置
const heading =   Cesium.Math.toRadians(50)// 水平旋转  -正北方向
const pitch =  Cesium.Math.toRadians(-90) // 上下旋转  --俯视朝向
const range = 2000 // 目标点高度
viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range))

```

# 删除entities 不干净

```js
  //清楚点位
  function clearPoints() {
      第一种方法： 每次只删除一个
    // viewer.entities._entities._array.forEach(item => {
    //   if (item._name == "jiashicangpoint") {
    //     viewer.entities.remove(item)
    //   }
    // })
      第二种方法：可以删除干净
    let allList = [];
    viewer.entities.values.forEach(item => {
      if (item._name == "jiashicangpoint") {
        allList.push(item)
      }
    })
    allList.forEach(item => {
      viewer.entities.remove(item)
    })

  }
```

# Cesium 坐标转换（各坐标/角度弧度互相转换）

https://blog.csdn.net/qq_17627195/article/details/127412829



### 飞视角方法-包围球

flyToBoundingSphere

```js
// 定位
    const handleSetView = (val) => {
        // 查找与 val.pointId 匹配的对象
        let device = pointData.value.find(item => item.pointId === val.pointId);
        if (device) {
            let { coordX, coordY, coordZ } = device;
            console.log(`coordX: ${coordX}, coordY: ${coordY}, coordZ: ${coordZ}`);

            // // 计算相机位置
const cameraPosition = Cesium.Cartesian3.fromDegrees(+coordX, +coordY, +coordZ);
            
            viewer.camera.flyToBoundingSphere(
                new Cesium.BoundingSphere(cameraPosition, 2), {
            })
        } else {
            proxy.$modal.msgWarning("未找到匹配的点位");
        }
    }
```



## 两种方式加载点数据的区别

```
Cesium.GeoJsonDataSource.load(points, {
            clampToGround: true
          })
            .then(async (dataSource) => {
              dataSource.entities.values.map((item) => {
                item.billboard.image = item.properties.getValue().url;
                item.billboard.width = 40;
                item.billboard.height = 40;
                item.name = item.properties.getValue().type;
              });
              dataSource.name = 'point'; 
              
              这种加载的点数据，和 
              
              viewer.entities.add({
        id:id,
        name:name,
        geometry:{coordinates:[Number(longitude),Number(latitude),Number(height)]},
        position: Cesium.Cartesian3.fromDegrees(
            Number(longitude),
            Number(latitude),
            !!Number(height) ? Number(height) : 2.5
        ),
        billboard: {
            disableDepthTestDistance: Number.POSITIVE_INFINITY,
            image: imageUrl,
            width: 45,
        }
    })加载的点数据，有什么区别
```

在 Cesium 中，你提到的两种加载点数据的方式存在以下几个关键区别：

1. **数据组织方式**
   - `Cesium.GeoJsonDataSource.load()`：将所有点作为一个数据源（DataSource）进行管理，适合批量加载大量点数据
   - `viewer.entities.add()`：逐个添加实体，每个点都是独立的 Entity 对象
2. **管理与操作**
   - 数据源方式可以整体显示 / 隐藏、移除或进行其他批量操作
   - 单个实体方式需要逐个操作，或通过 id 进行管理
3. **性能差异**
   - 对于大量点数据，使用 GeoJsonDataSource 加载性能更好，Cesium 内部会进行优化
   - 逐个添加实体在数据量大时可能影响性能
4. **数据关联**
   - 数据源方式天然保持了数据间的关联性，适合有整体关系的数据
   - 单个实体是独立存在的，需要额外逻辑来维护它们之间的关系
5. **更新机制**
   - 数据源可以通过`dataSource.entities`访问所有实体进行批量更新
   - 单个实体需要通过`viewer.entities.getById(id)`找到特定实体再更新
6. **适用场景**
   - 批量导入外部数据（如 GeoJSON 文件）时，适合用 GeoJsonDataSource
   - 动态生成少量点或需要精细控制每个点的属性时，适合用 entities.add ()

选择哪种方式取决于你的具体需求，如果是批量加载静态数据，推荐使用 GeoJsonDataSource；如果需要动态管理少量点或精细控制每个点的行为，使用 entities.add () 会更灵活。



## 标题：Cesium中 enu坐标系



在 Cesium 中，**ENU 坐标系**（East-North-Up，东 - 北 - 天坐标系）是一种局部笛卡尔坐标系，常用于表示相对于某个参考点（原点）的局部位置和方向。它是一种右手坐标系，三个轴的定义如下：

- **E 轴（East）**：指向参考点的正东方向
- **N 轴（North）**：指向参考点的正北方向
- **U 轴（Up）**：垂直于参考点的切平面向上（天顶方向）

### ENU 坐标系的特点

1. **局部性**：ENU 坐标系是相对于特定参考点（通常是经纬度坐标）建立的，原点通常对应地球表面的某个点
2. **右手系**：符合右手定则，E × N = U
3. **常用于局部场景**：适合表示相对于某个固定点的位置、姿态或运动（如无人机相对起飞点的位置）

### Cesium 中 ENU 坐标系的常用操作

#### 1. 将经纬度高度转换为 ENU 坐标

```javascript
// 定义参考点（原点）的经纬度
const origin = Cesium.Cartographic.fromDegrees(lng, lat, height);

// 将其他点的经纬度转换为ENU坐标
function toENU(targetLng, targetLat, targetHeight) {
  const target = Cesium.Cartographic.fromDegrees(targetLng, targetLat, targetHeight);
  const originCartesian = Cesium.Cartographic.toCartesian(origin);
  const targetCartesian = Cesium.Cartographic.toCartesian(target);
  
  // 计算ENU坐标
  const enu = Cesium.Transforms.eastNorthUpToFixedFrame(originCartesian);
  const transform = Cesium.Matrix4.inverse(enu, new Cesium.Matrix4());
  const localPosition = Cesium.Matrix4.multiplyByPoint(transform, targetCartesian, new Cesium.Cartesian3());
  
  return {
    east: localPosition.x,   // 东方向分量（米）
    north: localPosition.y,  // 北方向分量（米）
    up: localPosition.z      // 上方向分量（米）
  };
}
```

#### 2. 将 ENU 坐标转换为世界坐标（WGS84）

```javascript
function fromENU(originCartesian, east, north, up) {
  const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(originCartesian);
  const localPosition = new Cesium.Cartesian3(east, north, up);
  return Cesium.Matrix4.multiplyByPoint(enuMatrix, localPosition, new Cesium.Cartesian3());
}
```

#### 3. 应用场景示例

```javascript
// 创建一个参考点（原点）
const origin = Cesium.Cartesian3.fromDegrees(116.39, 39.9, 0);

// 在ENU坐标系中创建一个点（东100米，北200米，高50米）
const enuPosition = new Cesium.Cartesian3(100, 200, 50);

// 转换为世界坐标
const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
const worldPosition = Cesium.Matrix4.multiplyByPoint(enuMatrix, enuPosition, new Cesium.Cartesian3());

// 在该位置添加一个实体
viewer.entities.add({
  position: worldPosition,
  point: {
    pixelSize: 10,
    color: Cesium.Color.RED
  }
});
```

### 关键 API

- `Cesium.Transforms.eastNorthUpToFixedFrame(origin)`：创建从 ENU 坐标系到世界坐标系的转换矩阵
- `Cesium.Matrix4.inverse(matrix)`：计算矩阵的逆矩阵（用于反向转换）
- `Cesium.Matrix4.multiplyByPoint(matrix, point)`：应用矩阵转换点坐标

ENU 坐标系在需要表示相对位置的场景中非常有用，例如机器人导航、增强现实、局部区域分析等，可以简化局部空间中的位置计算。





