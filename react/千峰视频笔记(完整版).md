react全家桶

## 一 React 介绍

**1.**  **React** **起源与发展**

React 起源于 **Facebook** 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。

**2.**  **React 与传统 **MVC** **的关系**

轻量级的视图层**库**！*A JavaScript library for building user interfaces*

React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式；React 构建页面 UI 的库。可以简单地理解为，React 将界面分成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，就成了我们的页面。

**3.**  **React** 特性

特点:
1.声明式设计-React采用声明范式，可以轻松描述应用。

2.高效-React通过对DOM的模拟(虚拟dom)，最大限度地减少与DOM的交互

3.灵活-React可以与已知的库或框架很好地配合。

4.JSX-JSX是JavaScript 语法的扩展

5.组件-通过 React构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。

6.单向响应的数据流- React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单

**4.** **虚拟** **DOM**

传统dom更新:
真实页面对应一个DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作DOM来进行更新

![](.\img\微信截图_20231113164804.png)

虚拟dom:
DOM操作非常昂贵。我们都知道在前端开发中，性能消耗最大的就是 DOM 操作，而且这部分代码会让整体项目的代码变得难以维护。React 把真实 DOM 树转换成JavaScript 对象树，也就是 Virtual

![](.\img\微信截图_20231113164916.png)



## 二 create-react-app

全局安装  脚手架 create-react-app

```
npm install -g create-react-app
```

创建一个项目

```
create-react-app <项目名字>    //注意命名方式
```

### 检测 create-react-app 是否安装成功

```cobol
create-react-app -V // 注意：V 是大写的 
```

Creating a new React app in /dir/your-app.

Installing packages. This might take a couple of minutes. 安装过程较慢，

Installing react, react-dom, and react-scripts...

如果不想全局安装，可以直接使用npx

```
npx create-react-app myapp 也可以实现相同的效果
```

这需要等待一段时间，这个过程实际上会安装三个东西

```
1 react: react的顶级库

2.react-dom: 因为react有很多的运行环境，比如app端的react-native,我们要在web上运行就使用

3.react-dom

4.react-scripts: 包含运行和打包react应用程序的所有脚本及配置
```

出现下面的界面，表示创建项目成功:

```
Success! Created your-app at /dir/your-app

Inside that directory, you can run several commands:

npm start

Starts the development server.

npm run build

Bundles the app into static files for production.
npm test
Starts the test runner.


npm run eject
Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:


cd your-app npm start

Happy hacking!
```

生成项目的目录结构如下:“
根据上面的提示，通过cd your-app 命令进入目录并运行npm start 即可运行项目。

生成项目的目录结构如下

```
├── README.md   使用方法的文档
├── node_modules    所有的依赖安装的目录
├── package-lock.json  锁定安装时的包的版本号,保证团队的依赖能保证一致。
├── package.json
├── public        静态公共目录
└── src            开发用的源代码目录

```

![img](file:///C:/Users/15612/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)npm安装失败

切换为npm镜像为淘宝镜像“

使用yarn，如果本来使用yarn还要失败，还得把yarn的源切换到国内

如果还没有办法解决，请删除node.modules及package-lockjson然后重新执行npm install 命令

再不能解决就删除nodemodules及package-lock.json的同时清除npm缓存npm cacheclean --force

之后再执行npm install 命令

## 三 编写一个react应用程序

react开发需要引入多个依赖文件：react.js、react-dom.js，分别又有开发版本和生产版本，create- react-app里已经帮我们把这些东西都安装好了。把通过CRA创建的工程目录下的src目录清空，然后在里面重新创建一个index.js. 写入以下代码:

```react
// 从 react 的包当中引入了 React。
//只要你要写 React.js 组件就必须引入React, 因为react里有一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入React
import React from 'react'
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中引入的，而不是从 react 引入。
import ReactDOM from 'react-dom'

// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的元素上
ReactDOM.render(
// 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
<h1>欢迎进入React的世界</h1>,
// 渲染到哪里
document.getElementById('root')
)

```

<React.StrictMode> 

目前有助于识别不安全的生命周期
关于使用过时字符串refAPI的警告

检测意外的副作用
检测过时的 context AP



## 四 JSX语法与组件

## 1  JSX语法

JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不会带来任何副作用，反而会让代码更加直观并易于维护。 编译过程由Babel 的 JSX 编译器实现

**JSX不是必需的(但应首选JSX语法)**

JSX只是React.createElement(component,props,...children)的[语法糖](https://so.csdn.net/so/search?q=语法糖&spm=1001.2101.3001.7020)，所有的JSX语法最终都会被转换成对这个方法的调用。

```react
//JSX语法
const element = <div className='foo'>Hello,world</div>
 
//转换后
const element = React.createElement('div',{className:'foo'},'Hello,React')

```



https://reactjs.org/docs/hello-world.html

原理是什么呢？

要明白JSX的原理，需要先明白如何用 JavaScript 对象来表现一个 DOM 元素的结构?看下面的DOM结构

```react
<div class='app' id='appRoot'>
    <h1 class='title'>欢迎进入React的世界</h1>
    <p>
       React.js 是一个帮助你构建页面 UI 的库
    </p>
</div>
```

上面这个 HTML 所有的信息我们都可以用 JavaScript 对象来表示

```javascript
{
tag: 'div',
attrs: { className: 'app', id: 'appRoot'},
    children: [
{
    tag: 'h1',
    attrs: { className: 'title' }, 
    children: ['欢迎进入React的世界']
},
{
  tag: 'p', attrs: null,
  children: ['React.js 是一个构建页面 UI 的库']
}
]
}
```

但是用 JavaScript 写起来太长了，结构看起来又不清晰，用 HTML 的方式写起来就方便很多了。于是 Reactjs 就把 JavaScript 的语法扩展了一下，让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法，这样写起来就方便很多了。编译的过程会把类似 HTML的 JSX结构转换成 JavaScript 的对象构。

下面代码

```react
import React from 'react'
import ReactDOM from 'react-dom'

class App extends React.Component { 
 render () {
    return (
    <div className='app' id='appRoot'>
        <h1 className='title'>欢迎进入React的世界</h1>
        <p>
          React.js 是一个构建页面 UI 的库
        </p>
    </div>
    )
}}


ReactDOM.render(<App />, document.getElementById('root'))
```

编译之后将得到这样的代码

```react
import React from 'react'
import ReactDOM from 'react-dom'


class App extends React.Component {
    render() {
        return (React.createElement(
            "div",
            {className: 'app', id: 'appRoot'},
            React.createElement("h1",{ className: 'title' }, "欢迎进入React的世界"),
            React.createElement("p", null,"React.js 是一个构建页面 UI 的库" )
        )
        )
    }
}

ReactDOM.render(React.createElement(App),
    document.getElementById('root')
)
```

React.createElement会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性
还有子元素等，语法为

```
React.createElement( 
type,
[props], 
[...children]
)

```

所谓的 JSX 其实就是 JavaScript 对象，所以使用 React 和JSX 的时候一定要经过编译的过程

JSX一使用react构造组件，bable进行编译 -->JavaScript对象 一  ReactDOM.render()->DOM元素 一>插入页面

## 2. Class组件

ES6的加入让JavaScript直接支持使用class来定义一个类，react创建组件的方式就是使用的类的继承，ES6 Class

是目前官方推荐的使用方式，它使用了ES6标准语法来构建，看以下代码

```javascript
import React from 'react'
import ReactDOM from 'react-dom'

class App extends React.Component { 
    render () {
            return ( <h1>欢迎进入React的世界</h1>)
            }
        }

ReactDOM.render(
<App />, document.getElementById('root')
)

```

es6 Class组件其实就是一个构造器,每次使用组件都相当于在实例化组件，像这样

```
import React from 'react'
import ReactDOM from 'react-dom'

class App extends React.Component {
    render() {
        return (
            <h1>欢迎进入{this.props.name}的世界</h1>
        )
    }
}

const app = new App({
    name: 'react'
}).render()


ReactDOM.render(app,
    document.getElementById('root')
)
```

## 3.函数式组件

```react
import React from 'react'
import ReactDOM from 'react-dom'

const App = (props) => <h1>欢迎进入React的世界</h1> 
ReactDOM.render(
// React组件的调用方式
<App />, document.getElementById('root')
)
```

这样一个完整的函数式组件就定义好了。但要**注意！注意！注意！**组件名必须**大写**，否则报错

## 4.组件的样式

### 行内样式

想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现

```react
//  注意这里的两个括号，第一个表示我们在要JSX里插入JS了，第二个是对象的括号

 <p style={{color:'red', fontSize:'14px'}}>Hello world</p>
```

行内样式需要写入一个样式对象，而这个样式对象的位置可以放在很多地方，例如 render函数里、组件原型上、外链js文件中

使用class

React推荐我们使用行内样式，因为React觉得每一个组件都是一个独立的整体

其实我们大多数情况下还是大量的在为元素添加类名，但是需要注意的是,class需要写成 className

因为毕竟是在写类js代码，会收到js规则的现在，而class是关键字

```
<p className="hello">Hello world</p>
```

注意:	

```
class ==> className , for ==> htmlFor(label)
```

## 5 事件处理

### 1 绑定事件

采用关于+事件名的方式来绑定一个事件，注意，这里和原生的事件是有区别的，原生的事件全是小写 onclick，React里的事件是驼峰onClick，React 的事件并不是原生事件，而是合成事件。

### 2 事件handler的写法

a 直接在render里写行内的箭头函数(不推荐)

b在组件内使用箭头函数定义一个方法(推荐)

c 直接在组件内定义一个非箭头函数的方法，然后在render里直接使用 onclick=[thishandleclick,bind(this)}  (不推荐)

d 直接在组件内定义一个非箭头函数的方法，然后在constructor里bind(this)(推荐

### 3 Event 对象

和普通浏览器一样，事件handler会被自动传入一个 evente对象，这个对象和普通的浏览器 event 对象所包含的方法和属性都基本一致。不同的是 React中的 event 对象并不是浏览器提供的，而是它自己内部所构建的。它同样具有 event.stopPropagation、event.preventDefault 这种常用的方法

## 6.Ref的应用

a  给标签设置 ref="username"

通过这个获取this.refs.username , ref可以获取到应用的真实dom

b 给组件设置  ref="username"

通过这个获取 this.refs.username  ,ref可以获取到组件对象

###    **新的写法**

```
myRef = React.createRef()

     <div ref={this.myRef}>hello</div>

             访问this.myRef.current

```



## 五 组件的数据挂载方式

**状态(state)**

状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态的目的就是为了在不同的状态下使组件的显示不同(自己管理）

### 拓展解释：

#### a 设计合适的state

state必须能代表一个组件UI呈现的完整状态集，代表一个组件UI呈现的最小状态集。

state必须能代表一个组件UI呈现的完整状态集又可以分成两类数据：用作渲染组件时使用到的数据的来源，用作组件UI展现形式的判断依据：

```react
class Hello extends Component {
    constructor(props) {
        super(props);
        this.state = {
            user: 'react', //用作渲染组件时使用到的数据的来源
            display: true //用作组件UI展现形式的判断依据
        }
    }
    render() {
        return (
            <div>
                {
                    this.state.display ? <h1>{this.state.user}</h1> : <></>
                }
            </div>
        )
    }
}
export default Hello;
```

#### b 普通属性

在es6中，可以使用this.属性名定义一个class的属性，也可以说属性是直接挂载在this下的一个变量。因此，state和props实际上也是组件的属性，只不过是react在Component class中预定义好的属性。

除了state和props以外的其他组件属性称为组件的普通属性。

```react
class Hello extends Component {
    constructor(props) {
        super(props);
        this.timer = null; //普通属性
        this.state = {
            date: new Date()
        }
        this.updateDate = this.updateDate.bind(this);
    }
    componentDidMount(){
        this.timer = setInterval(this.updateDate, 1000);
    }
    componentWillUnmount(){
        clearInterval(this.timer);
    }
    updateDate(){
        this.setState({
            date: new Date()
        })
    }
    render() {
        return (
            <div>
                <h1>{this.state.date.toString()}</h1>
            </div>
        )
    }
}
export default Hello;


```

组件中用到的一个变量是否应该作为state可以通过下面4条依据判断：

这个变量是否通过props从父组件中获取？如果是，那么它不是一个状态
这个变量是否在生命周期中都保持不变？如果是，那么它不是一个状态
这个变量是否可以通过其他状态(state)或者属性(props)计算得到？如果是，那么它不是一个状态
这个变量是否在组件的render方法中使用？如果不是，那么它不是一个状态，这种情况更适合定义为组件的一个普通属性.

#### c 正确修改state

①不能直接修改state，需要使用setState()

②state的更新是异步的

React会将多次setState的状态合并成一次状态修改，不能依赖当前的state计算下一个state(props也是异步的)。

例如：连续两次点击加入购物车，实际数量只会加1，在React合并多次修改为1次的情况下，相当于执行了：

```react
Object.assign(
    previousState,
    {quantity: this.state.quantity + 1},
    {quantity: this.state.quantity + 1}
)
```

这种情况下，可以使用另一个接收一个函数作为参数的setState，这个函数有两个参数，第一个是当前修改后的最新状态的前一个状态preState，第二个参数是当前最新的属性props:

```
this.setState((preState,props) => ({
    quantity: preState.quantity + 1;
}))
```

③state的更新是一个合并的过程

④state与不可变对象

直接修改state，组件不会render；state包含的所有状态都应该是不可变对象，当state中某个状态发生变化时，应该重新创建这个状态对象，而不是直接修改原来的状态。创建新的状态有以下三种方法：

状态的类型是不可变类型(数字、字符串、布尔值、null、undefined)：因为状态是不可变类型，所以直接赋一个新值即可
状态的类型是数组：可以使用数组的concat或者es6的扩展语法，slice方法、filter方法。不能使用push、pop、shift、unshift、splice等方法修改数组类型的状态，因为这些方法会在原数组基础上修改。

```
this.setState((preState) => ({
    arr: [...preState.arr,'react'];
}))
this.setState((preState) => ({
    arr: preState.arr.concat(['react'])
}))
```

- 状态的类型是普通对象(不包含字符串、数组)：使用ES6的Object.assgin方法或者对象扩展语法.



### **(1)**  **定义**  **state**

第一种方式

```
import React, { Component } from 'react' 
import ReactDOM from 'react-dom'

class App extends Component { 
    state = {
      name: 'React', isLiked: false
    }
    render () { 
        return (
        <div>
            <h1>欢迎来到{this.state.name}的世界</h1>
                <button>
                {
                this.state.isLiked ? '❤取消' : '🖤收藏'
                }
                </button>
        </div>
        )
       }
    }
ReactDOM.render(
<App/>, document.getElementById('root')
)

```

另一种方式

```
import React, { Component } from 'react' 
import ReactDOM from 'react-dom'

class App extends Component { 
    constructor() {
        super() 
        this.state = {
        name: 'React', isLiked: false
        }
    }
    
        render () { 
        return (
            <div>
               <h1>欢迎来到{this.state.name}的世界</h1>
                <button>
                {this.state.isLiked ? '❤取消' : '🖤收藏'}
                </button>
            </div>
        )
        }
    }
ReactDOM.render(
<App/>, document.getElementById('root')
)

```

this.state 是纯js对象,在vue中，data属性是利用Object.defineProperty 处理过的，更改data的数据的时候会触发数据的getter 和setter ，但是React中没有做这样的处理，如果直接更改的话， react是无法得知的，所以，需要使用特殊的更改状态的方法 setState 。

### **(2)**  **setState**

isLiked 存放在实例的 states对象当中，组件的render 函数内，会根据组件的states的中的isLiked 不同显示“取消"或“收藏"内容。下面给button加上了点击的事件监听。

```
import React, { Component } from 'react' import ReactDOM from 'react-dom'

class App extends Component { 
    constructor() {
        super() 
        this.state = {
        name: 'React', isLiked: false
        }
    }

    handleBtnClick = () => { this.setState({
    isLiked: !this.state.isLiked
    })
  }
  
render () { 
    return (
    <div>
         <h1>欢迎来到{this.state.name}的世界</h1>
        <button onClick={this.handleBtnClick}>
            {
            this.state.isLiked ? '❤取消' : '🖤收藏'
            }
        </button>
    </div>
    )
    }
}
ReactDOM.render(
<App/>, document.getElementById('root')
setState 有两个参数
```

第一个参数可以是对象，也可以是方法return一个对象，我们把这个参数叫做 updater

参数是对象

```
this.setState({
isLiked: !this.state.isLiked
})
```

参数是方法

```
this.setState((prevState, props) => { return {
        isLiked: !prevState.isLiked
        }
})

```

注意的是这个方法接收两个参数，第一个是上一次的state,  第二个是props .

setState 是异步的，所以想要获取到最新的state，没有办法获取，就有了第二个参数，这是一个可选的回调函数

```
this.setState(
(prevState, props) => { 
return {
    isLiked: !prevState.isLiked
}, 
    () => {
    console.log('回调里的',this.state.isLiked)
    }
)
console.log('setState外部的',this.state.isLiked)

```

### (3)属性(props)

props 是正常是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更改，但是你可以通过父组件主动重新渲染的方式来传入新的属性是描述性质、特点的，组件自己不能随意更改。

之前的组件代码里面有props 的简单使用，总的来说，在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为组件参数来接收props :

```
(1) 在组件上通过key=value 写属性,通过this.props获取属性,这样组件的可复用性提高了.
(2) 注意在传参数时候，如果写成isShow="true" 那么这是一个字符串,如果写成isShow={true} 这个是布尔值。
(3) {...对象} 展开赋值
(4) 默认属性值

*.defaultProps = {
     默认都是空，或者写入
   }
  static defaultProps = { 
  myname:"默认的myname", myshow:true
}

(5) prop-types 属性验证
import propTypes from "prop-types";

*.propTypes={
     name:propTypes.string, age:propTypes.number
}

static propTypes={ 
        myname:propTypes.string,
        myshow:propTypes.bool
    }

```

（5）组件中插槽中的dom，在自己组件函数props中可以拿到。

```
  <App>
     dom或一个组件
    </App>
```



```
class App extends Component {
    componentDidMount() {
        // console.log(this.props)
    }
    
    render() {
        return (
            <div>
                {this.props.children} // <----可以拿到dom 或组件
                {this.props.isShow && <Tabbar/>}
            </div>
        )
    }
}
```









### (4)属性vs状态

相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）

不同点：

\1.    属性能从父组件获取，状态不能

\2.    属性可以由父组件修改，状态不能

\3.    属性能在内部设置默认值，状态也可以，设置方式不一样

\4.    属性不在组件内部修改，状态要在组件内部修改

\5.    属性能设置子组件初始值，状态不可以

\6.    属性可以修改子组件的值，状态不可以



state的主要作用是用于组件保存、控制、修改自己的可变状态。 state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state  是一个局部的、只能被组件自身控制的数据源。

state中状态可以通过 this.setState 方法进行更新， setState 会导致组件的重新渲染。

props的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 ，否则组件的不变。

没有state-的组件叫无状态组件(stateless component)，设置了 state的叫做有状态组件(stateful component)。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。

### (5)渲染数据

条件渲染

```
{
condition ? '渲染列表的代码' : '空空如也'
}
```

列表渲染

```
// 数据
const people = [
{ id: 1,name: 'Leo', age: 35}, 
{id: 2,name: 'XiaoMing', age: 16
}]
// 渲染列表
{
    people.map(person => { return (
        <dl key={person.id}>
        <dt>{person.name}</dt>
        <dd>age: {person.age}</dd>
        </dl>
        )
    })
}

```

React的高效依赖于所谓的Virtual-DOM，尽量不碰DOM。对于列表元素来说会有一个问题:元素可能会在一个列表中改变位置。要实现这个操作，只需要交换一下DOM位置就行了，但是React并不知道其实我们只是改变了元素的位置，所以它会重新渲染后面两个元素(再执行Vitual-DOM )，这样会大大增加DOM操作。但如果给每个元素加上唯一的标识，React就可以知道这两个元素只是交换了位置，这个标识就是key，这个key必须是每个元素唯一的标识

dangerouslySetInnerHTML

对于富文本创建的内容，后台拿到的数据是这样的

```
content = "<p>React.js是一个构建UI的库</p>"
```

处于安全的原因，React当中所有表达式的内容会被转义，如果直接输入，标签会被当成文本。这时候就需要使用dangerouslyS.etHTML属性，它允许我们动态设置innecHTML

```
import React, { Component } from 'react' import ReactDOM from 'react-dom'

class App extends Component { 
       constructor() {
        super() this.state = {
            content : "<p>React.js是一个构建UI的库</p>"
        }
    }
render () { 
   return (
        <div
        // 注意这里是两个下下划线  __html 
        dangerouslySetInnerHTML={{ __html: this.state.content}}
        />
        )
     }
}

ReactDOM.render(
<App/>, document.getElementById('root')
)

```



## 六表单中的受控租金按和非受控组件

### 非受控组件:

表单元素在React中自身维护一些状态，这些状态默认情况下是不受react控制的，这类状态不受react控制的表单元素称为非受控组件。

### 受控组件:

在React中，状态的修改必须通过组件的state，

注意: 

另一种说法（广义范围的说法），React组件的数据渲染是否被调用者传递的 props 完全控制，控制则为受控组件，否则非受控组件。

### 演示

非受控组件有悖于这一原则，为了让表单元素的状态变更也能通过组件的state管理，React使用受控组件的技术达到这一目的。

**受控组件**

如果一个表单元素的值是由React来管理的，那么它就是一个受控组件。对于不同的表单元素，React的控制方法略有不同，常用的三类表单元素控制方式是：

①文本框

包含类型为text的input和textarea元素，它们受控的原理是：通过value属性设置表单元素的值，通过onChange时间监听值的变化，并将变化同步到React组件的state中：






## 七 组件通信的方式

### **1.**   父子组件通信方式

(1)    父传子  看props小节

父组件中，在引用的子组件上，k：v方式传递，

子组件使用props接收。

(2)     传递数据(父传子)与传递方法(子传父)

```
传递方法(子传父) 
父组件把修改自己数据的方法，通过变量，使用子组件传递过去。子组件使用this.props接受
import React, { Component } from 'react'

子组件
class Navbar extends Component{
    render(){
        return <div style={{background:"red"}}>
            <button onClick={()=>{
                   console.log("子通知父， 让父的isSHow 取反。",this.props.event) 

                   this.props.event() //调用父组件传来啊的回调函数
            }}>click</button>
            <span>navbar</span>
        </div>
    }
}
父组件
export default class App extends Component {
    state = {
        isShow:false
    }

    handleEvent = ()=>{
        this.setState({
            isShow:!this.state.isShow
        })
        // console.log("父组件定义的event事件")
    }
    render() {
        return (
            <div>
                <Navbar event={this.handleEvent}/>
                {/* <button onClick={()=>{
                    this.setState({
                        isShow:!this.state.isShow
                    })
                }}>click</button> */}
                {this.state.isShow && <Sidebar/>}
            </div>
        )
    }
}
```

(2)     ref标记 (父组件拿到子组件的引用，从而调用子组件的方法)

在父组件中清除子组件的input输入框的value值。**this.refs.form.reset()**



### **2.**   非父子组件通信方式

#### **(1)**   **状态提升**  **(**中间人模式**)**

React中的状态提升概括来说,就是将多个组件需要共享的状态提升到它们最近的父组件上.在父组件上改变这个状态然后通过props分发给子组件. （实质还是父子通信方式）

```
import React, { Component } from 'react'
import axios from 'axios'
import './css/03-communination.css'
export default class App extends Component {

    constructor(){
        super()
        this.state = {
            filmList:[],
            info:""
        }
    }
    数据来自互联网
    https://m.maizuo.com/v5/#/films/nowPlaying
    componentDidMount(){
        axios.get(`/test.json`).then(res=>{
            console.log(res.data.data.films)
            this.setState({
                filmList:res.data.data.films
            })
        })
    }

    render() {
        return (
            <div>
                {/* {this.state.info} */}
                {
                    this.state.filmList.map(item=>
                        <FilmItem key={item.filmId} {...item} onEvent={(value)=>{
                            // console.log("父组件接受",value)

                            this.setState({
                                info:value
                            })
                        }}></FilmItem>    
                    )
                }


                <FilmDetail info={this.state.info}></FilmDetail>
            </div>
        )
    }
}

/*受控组件*/
class FilmItem extends Component{
    render(){
        // console.log(this.props)
        let {name, poster,grade,synopsis}  = this.props
        return <div className="filmitem" onClick={()=>{
            // console.log(synopsis)
            this.props.onEvent(synopsis)
        }}>
            <img src={poster} alt={name}/>
            <h4>{name}</h4>
            <div>观众评分：{grade}</div>
        </div>
    }
}

class FilmDetail extends Component{
   
    render(){
        console.log(this.props)
        return <div className="filmdetail">
            {this.props.info}
        </div>
    }
}
```



#### **(2)**   发布订阅模式实现

纯js实现 ，谁订阅，谁接受，抛弃了父子孙关系。

```
/*
 * @作者: kerwin
 * @公众号: 大前端私房菜
 */
import React, { Component } from 'react'

export default class App extends Component {
    render() {
        return (
            <div>
                app
            </div>
        )
    }
}

//调度中心
var bus = {

    list:[],
    //订阅
    subscribe(callback){
        // console.log(callback)

        this.list.push(callback)
    },

    //发布
    publish(text){
        //遍历所有的list， 将回调函数执行
        // console.log(this.list)

        this.list.forEach(callback=>{
            callback && callback(text)
        })
    }
}


// 订阅者
bus.subscribe((value)=>{
    console.log("11111",value)
})

bus.subscribe((value)=>{
    console.log("2222",value)
})



//发布者

setTimeout(()=>{
    bus.publish("男人看了沉默111")
},0)


// Redux 基于订阅发布 

```



#### **(3)**   **context** 状态树传参

```
import React, { Component } from 'react'
import axios from 'axios'
import './css/03-communination.css'

const GlobalContext  = React.createContext() //创建context对象

export default class App extends Component {

    constructor(){
        super()
        this.state = {
            filmList:[],
            info:""
        }
        axios.get(`/test.json`).then(res=>{
            console.log(res.data.data.films)
            this.setState({
                filmList:res.data.data.films
            })
        })
    }

    render() {
        return (
            <GlobalContext.Provider value={{
                call:"打电话",
                sms:"短信",
                info:this.state.info,
                changeInfo:(value)=>{
                    this.setState( {
                        info:value
                    })
                }
            }}>
                <div>
                    {/* {this.state.info} */}
                    {
                        this.state.filmList.map(item=>
                            <FilmItem key={item.filmId} {...item} ></FilmItem>    
                        )
                    }


                    <FilmDetail ></FilmDetail>
                </div>
            </GlobalContext.Provider>
        )
    }
}

/*受控组件*/
class FilmItem extends Component{
    render(){
        // console.log(this.props)
        let {name, poster,grade,synopsis}  = this.props
        return (
        <GlobalContext.Consumer>
           {
                (value)=>{
                    console.log(value)
                    
                    return <div className="filmitem" onClick={()=>{
                        console.log(synopsis)
                        // this.props.onEvent(synopsis)

                        // value.info = "2222222"

                        // console.log(value)

                        value.changeInfo(synopsis)
                    }}>
                        <img src={poster} alt={name}/>
                        <h4>{name}</h4>
                        <div>观众评分：{grade}</div>
                    </div>
                }
           }
        </GlobalContext.Consumer>
        )    
    }
}

class FilmDetail extends Component{
    render(){
        return (
            <GlobalContext.Consumer>
                {
                    (value)=><div className="filmdetail">
                        detail-{value.info}
                    </div>
                }
            </GlobalContext.Consumer>
        )
    }
}
```







## 八 React生命周期

**只有类组件才有生命周期，函数组件没有生命周期**

###  1.初始化阶段

```
componentWillMount: render之前最后一次修改状态的机会

render: 只能访问this.props和this.state，不允许修改状态和DOM输出

componentDidMount: 成功render并渲染完成真实DOM之后触发，可以修改DOM
```

### 2.运行中阶段

```
componentWillReceiveProps: 父组件修改属性触发

shouldComponentUpdate: 返回false会阻止render调用

componentWillUpdate: 不能修改属性和状态

render: 只能访问this.props和this.state，不允许修改状态和DOM输出

componentDidUpdate: 可以修改DOM
```



```
    shouldComponentUpdate(nextProps, nextState) { // 生命周期函数，是否渲染组件，false则不变
        if(this.props.filter === nextProps.filter){
            return false
        }
        return true
    }
```



### 3.销毁阶段

```
componentWillUnmount: 在删除组件之前进行清理操作，比如计时器和事件监听器
```

### 4.老生命周期的问题

(1)componentWillMount,在ssr中 这个方法将会被多次调用，所以会重复触发多遍，同时在这里如果绑定事件将无法解绑，导致内存泄漏， 变得不够安全高效逐步废弃。

(2) componentWilReceiveProps 外部组件多次频繁更新传入多次不同的 props，会导致不必要的异步请求

(3)componetWilupdate,更新前记录 DOM 状态，可能会做一些处理，与componentDidUpdate相隔时间如果长，会导致 状态不太信

### 5.新生命周期的替代

(1) getDerivedStateFromProps 第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父传子)返回一个对象作为新的state，返回null则说明不需要在这里更新state

```
//老的生命周期的写法 
componentDidMount() {
    if (this.props.value !== undefined) {
        this.setState({
            current: this.props.value
        })
    }
}
componentWillReceiveProps(nextProps){
    if (nextProps.value !== undefined) {
        this.setState({
            current: nextProps.value
        })
    }
}

// 新的生命周期写法
static getDerivedStateFromProps(nextProps, prevState) {
    const {type} = nextProps;
    // 当传入的type发生变化的时候，更新state
    if (type !== prevState.type) {
        return {
            type,
        };
    }
    // 否则，对于state不进行任何操作
    return null;
}
复制代码
```

 (2) 

getSnapshotBeforeUpdate 取代了 componetWillUpdate ,触发时间为update发生的时候，在render之后

dom渲染之前返回一个值，作为componentDidUpdate的第三个参数

```
//新的数据不断插入数据前面，  导致我正在看的数据向下走，如何保持可视区依旧是我之前看的数据呢？
getSnapshotBeforeUpdate(){
    return this.refs.wrapper.scrollHeight
}


componentDidUpdate(prevProps, prevState, preHeight) {
    //if(preHeight===200)return ;
    this.refs.wrapper.scrollTop += this.refs.wrapper.scrollHeight - preHeight
}


<div style={{ height: "200px", overflow: "auto" }}} ref="wrapper">
    <ul>
        .........
    </ul>
</div>
```

### 6.react中性能优化的方案

#### 第一种：手动优化 shouldComponentUpdate

```
    // scu 性能优化函数
    
    shouldComponentUpdate(nextProps,nextState){
        // return true; //应该更新
        //return false;; //阻止更新
        // this.state  老的状态
        // nextState   新的状态
        if(JSON.stringify(this.state)!== JSON.stringify(nextState)){
            return true
        }

        return false
    }
```

#### 第二种：PureComponent

PureComponent会帮你 比较新props 跟旧的props， 新的state和老的state（值相等,或者对象含有相同的属性、且属性值相等 ），决定shouldcomponentUpdate 返回true 或者false， 从而决定要不要呼叫 render function 。

使用方法：

将

```
export default class App extends Component {...
```

修改为

```
export default class App extends PureComponent {...
```



案例演示：

```react
import React, { PureComponent,Component } from 'react'

export default class App extends PureComponent { <----重点
    state  = {
        myname:"kerwin"
    }
    render() {
        console.log("render")
        return (
            <div>
                <button onClick={()=>{
                    this.setState({
                        myname:"xiaoming"
                    })
                }}>click</button>

                {this.state.myname}
            </div>
        )
    }
}
```

#### 总结

第一种，当子组件较多时，需要一个个单独去设置。

第二种：限定使用场景，当子组件例如是一个计数器这种一直在修改的组件，那么是没有必要使用PureComponent的，因为比较这个过程，也是需要时间的。这一点是要注意的，不要为了使用而是用。







## 九 React Hooks

### 1 用hooks理由

1. 高阶组件为了复用，导致代码层级复杂

2. 生命周期的复杂
3. 写成functional组件,无状态组件 ，因为需要状态，又改成了class,成本高

### 2. useState(保存组件状态)

```
const [list,setList] = useState(["aa","bb","cc"])
结构出list变量， 和修改list的唯一指定方法setList

案例: 点击按钮num+1; 在实际页面效果中，由于每次刷新，num都会回到初始值，无法达到目的。
import React,{useState,useRef} from 'react'
export default function App() {
    var num = 20;
    const [list,setList] = useState(["aa","bb","cc"])
    
```

### 3. useEffect(处理副作用)和useLayoutEffect (同步执行副作用)

Function Component 不存在生命周期，所以不要把 Class Component 的生命周期概念搬过来试图对号入座。

```
useEffect(() => {
           //effect 渲染页面后执行
return () => {
         //cleanup  销毁时执行
};
}, [依赖的状态;空数组,表示不依赖])
```

不要对 Dependencies 撒谎, 如果你明明使用了某个变量，却没有申明在依赖中，你等于向 React 撒了谎，后果
就是，当依赖的变量改变时，useEffect 也不会再次执行, eslint会报警告

```
let id = props.match.params.myid useEffect(()=>{
axios.get(`/articles/${id}`).then(res => { settitle(res.data.title) setcontent(res.data.content) setcategory(res.data.category)
})
},[id])
```

**useEﬀect**和 **useLayoutEﬀect**  有什么区别？

**简单来说就是调用时机不同，**
useLayoutEffect **和原来** componentDidMount **&** componentDidUpdate **一致，在 react完成DOM更新后马上**同步**调用的代码，会阻塞页面渲染。而**
useEffect **是会在整个页面渲染完才会调用的代码**



### 4. useRef（是hooks一种，一般在**函数组件使用**）

作用是：记住状态

```
export default function App() {
    const mytext = useRef() // React.createRef()
    
    const handleAdd = ()=>{
        console.log(mytext.current.value) // 获取值
    }
 
  return (<div>
            <input ref={mytext}/> 
               <button onClick={handleAdd}>add</button>
```

官方建议优先使用useEffect

在实际使用时如果想避免**页面抖动**（在useEffect 里修改DOM很有可能出现）的话，可以把需要操作DOM的代码放在useLayoutEffect 里。在这里做点dom操作，这些dom修改会和
react 做出的更改一起被一次性渲染到屏幕上，只有一次回流、重绘的代价

### **5. useCallback(**记忆函数**)**

防止因为组件重新渲染，导致方法被重新创建 ，起到缓存作用*;* 只有第二个参数 变化了，才重新声明一次。

```react
var handleClick = useCallback(()=>{ console.log(name)
},[name])
<button onClick={()=>handleClick()}>hello</button>

//只有name改变后，  这个函数才会重新声明一次，
//如果传入空数组，  那么就是第一次创建后就被缓存，  如果name后期改变了,拿到的还是老的name。
//如果不传第二个参数，每次都会重新声明一次，拿到的就是最新的name.

```

**useMemo** **记忆组件**

useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的

```react
useCallback(fn, inputs) is equivalent to useMemo(() => fn, inputs).
```

唯一的区别是：**useCallback** **不会执行第一个参数函数，而是将它返回给你，而** **useMemo** **会执行第一个函数并****且将函数执行结果返回给你。**所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。

所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。(类似与vue的计算属性)

### **6. useRef(**保存引用值**)**

```react
const myswiper = useRef(null);
<Swiper ref={myswiper}/>
```

ref 写在dom上是value值，写在组件上，是组件对象。



### 7. useContext（减少组件层级）

对class类组件中使用context方法，

在函数式组件中的简化写法。 提供端没有简化，接受端较大简化。

```react
import React, { useState,useEffect,useContext } from 'react'
import axios from 'axios'
import './css/index.css'

const GlobalContext  = React.createContext() //创建context对象

export default function App (){
    const [filmList, setfilmList] = useState([])
    const [info, setinfo] = useState("")

    useEffect(() => {
        axios.get(`/test.json`).then(res=>{
            // console.log(res.data.data.films)
            setfilmList(res.data.data.films)
        })
    }, []);

    return (
        <GlobalContext.Provider value={{
            call:"打电话",
            sms:"短信",
            info:info,
            changeInfo:(value)=>{
                setinfo(value)
            }
        }}>
            <div>
                {/* {this.state.info} */}
                {
                    filmList.map(item=>
                        <FilmItem key={item.filmId} {...item} ></FilmItem>    
                    )
                }


                <FilmDetail ></FilmDetail>
            </div>
        </GlobalContext.Provider>
    )
}

/*受控组件*/

function FilmItem(props){
    let {name, poster,grade,synopsis}  = props
    const value = useContext(GlobalContext)

    console.log(value)// 父组件GlobalContext.Provider 提供的值：call:"打电话",
    return <div className="filmitem" onClick={()=>{
                console.log(synopsis)

                value.changeInfo(synopsis)
            }}>
                <img src={poster} alt={name}/>
                <h4>{name}</h4>
                <div>观众评分：{grade}</div>
            </div> 
}



function FilmDetail(){
    const value = useContext(GlobalContext)
    return <div className="filmdetail">
        detail-{value.info}
    </div>
}
```

### 8.useReducer 的使用

功能：Hooks提供的一种，将组件状态提到外面的方法。

案例： 对count数字， +  -- 操作。

```react
import React,{useReducer} from 'react'
 //处理函数
 const reducer = (prevState,action)=>{
    //  console.log("reduercer",prevState,action)
     let newstate = {...prevState}
     switch(action.type){
         case "kerwin-minus":
            newstate.count--
            return newstate

         case "kerwin-add":
            newstate.count++
            return newstate
        
         default:
            return prevState
     }
 }
 // 外部的对象
 const intialState = {
     count:0,
    //  list:[]
 } 

 export default function App() {
     const [state, dispatch] = useReducer(reducer,intialState)
        console.log(state, dispatch)
     return (
         <div>
             <button onClick={()=>{
                 dispatch({
                     type:"kerwin-minus"
                 })
             }}>-</button>
             {state.count}
             <button onClick={()=>{
                 dispatch({
                    type:"kerwin-add"
                })
             }}>+</button>
         </div>
     )
 }
```

### 9.useReducer + useContext配合使用（减少组件层级）

  Hooks提供类似redux数据仓库理念的工具方法。

案例：app父组件， 传值给三个子组件，共享数据和方法。child1组件，点击，child2 child3视图变化。

```react
import React,{useReducer,useContext} from 'react'

const initailState = {
    a:"11111",
    b:"11111"
}

const reducer = (prevState,action)=>{
    let newstate = {...prevState}
    switch(action.type){
        case "change-a":
            newstate.a = action.value
            return newstate
        case "change-b":
            newstate.b = action.value
            return newstate
        default:
            return prevState
    }
    // return prevState
}

const GlobalContext = React.createContext()
export default function App() {
    const [state, dispatch] = useReducer(reducer, initailState)
    
    return (
        <GlobalContext.Provider value={
            {
                state,
                dispatch
            }
        }>
            <div>
                <Child1/>
                <Child2/>
                <Child3/>
            </div>
        </GlobalContext.Provider>
    )
}

function Child1(){
    const {dispatch} = useContext(GlobalContext)
    return <div style={{background:"red"}}>
        <button onClick={()=>{
            dispatch({
                type:"change-a",
                value:"2222222"
            })
        }}>改变a</button>
        <button onClick={()=>{
            dispatch({
                type:"change-b",
                value:"333333"
            })
        }}>改变b</button>
    </div>
}

function Child2(){
    const {state} = useContext(GlobalContext)
    return <div style={{background:"yellow"}}>
        child2-{state.a}
    </div>
}

function Child3(){
    const {state} = useContext(GlobalContext)
    return <div style={{background:"gray"}}>
        child3-{state.b}
    </div>
}
```



### 10 自定义hooks

功能： 页面逻辑更清晰，更好阅读，体现函数式变成思想。

实现： Hooks提供一种方法。 允许你将一个大方法，按一定逻辑，抽离出来写成一个use-开头的小方法，不用担心异步问题。每次修改，代码都会重新给出新值。

案例如下；

```
import React, { useState,useEffect,useMemo } from 'react'
import axios from 'axios'

**1 获取list数据方法
function useCinemaList(){
    const [cinemaList, setcinemaList] = useState([])


    useEffect(() => {
        axios({
            url:"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159",
            method:"get",
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.0.4","e":"16395416565231270166529","bc":"110100"}',
                
                'X-Host': 'mall.film-ticket.cinema.list'

            }
        }).then(res=>{
            setcinemaList(res.data.data.cinemas)
        })
    }, [])

    return {
        cinemaList
    }
}
 **2获取筛选后的数据方法
function useFilter(cinemaList,mytext){
    const getCinemaList = useMemo(() => cinemaList.filter(item=>item.name.toUpperCase().includes(mytext.toUpperCase()) || 
    item.address.toUpperCase().includes(mytext.toUpperCase())
    ), [cinemaList,mytext])

    return {
        getCinemaList
    }
}

export default function Cinema(){
    const [mytext, setmytext] = useState("")
    
    const {cinemaList}  = useCinemaList()

    const {getCinemaList} = useFilter(cinemaList,mytext)

    return <div>
            {/* {this.state.mytext} */}
                <input value={mytext} onChange={(evt)=>{
                    setmytext(evt.target.value)
                }}/>
                {
                    getCinemaList.map(item=>
                        <dl key={item.cinemaId}>
                            <dt>{item.name}</dt>
                            <dd>{item.address}</dd>
                        </dl>    
                    )
                }
        </div>
}
```







### 小结解疑：

Q:  [react中useRef与createRef的区别](https://www.cnblogs.com/-roc/p/16943895.html)

A:   useRef()                   React.createRef()

useRef （是hooks一种，一般在**函数组件使用**）

1.1.获取当前dom数据（不推荐，推荐使用受控组件-即使用useState绑定表单元素）

1.2、作为存储使用

createRef（一般用于class组件，获取子组件dom）

1、createRef创建的ref对象，组件每更新一次，ref对象就会被重新创建。

区别

1.    useRef只会在组件首次渲染时创建

2.  createRef会在组件每次渲染的时候重新创建

   

   

## 十 React路由

### **1.**  什么是路由？

路由是根据不同的 url 地址展示不同的内容或页面。

一个针对React而设计的路由解决方案、可以友好的帮你解决React components 到URl之间的同步映射关系

### 2.路由安装

https://reacttraining.com/react-router/web/guides/quick-start

```
npm install react-router-dom@5

"react-router-dom": "^5.3.4",
```

### 3. 路由使用

####  (1)路由方法导入

```
import React from "react";
import {
         BrowserRouter as Router, Switch, Route, Link
     } from "react-router-dom";
```

#### (2)定义路由以及重定向 案例hash模式

  路由基本使用

```react
<HashRouter>
  <Route path="/films" component={Films}/>
    <Route path="/cinemas" component={Cinemas}/>
</HashRouter>
当浏览器http://localhost:3000/#/films时，展示对应组件。插件的基本功能就是匹配功能。
```

加功能1：

当用户输入的路径，没有对应页面时，跳到home页去。

```react
<HashRouter>
  <Switch>
         <Route path="/films" component={Films}/>
         <Route path="/cinemas" component={Cinemas}/>
      
       <Redirect from="/" to="/home" />   //from="/"  模糊匹配
   </Switch>
</HashRouter>
Switch嵌套路由，配合重定位标签。实现： 浏览器输入地址后，自上而下匹配，只要匹配到就跳出。没有匹配到，就重定位到home去。

```

加功能2：

当进入/ 根路由，就进入home去， 如果是 /abc  等乱输入的路径，就跳入到NotFound 未找到页面。

```react
<HashRouter>
    <Switch>
        <Route path="/films" component={Films}/>
        <Route path="/cinemas" component={Cinemas}/>
        <Route path="/center" component={Center}/>
        
        <Redirect from="/" to="/home" exact/>    
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
Redirect重定向标签，加exact精准属性，只有/，才进入home,其他情况，万能匹配，进入NotFound页面。
```



解析：

exact 精确匹配 (Redirect 即使使用了exact, 外面还要嵌套Switch 来用)；

Warning: Hash history cannot
PUSH the same path; a new entry will not be added to the history
stack,这个警告只有在hash 模式会出现。

#### (3)嵌套路由

页面效果：

父页面中显示轮播图和两个按钮  分别显示不同的子页面。

代码配置：

router.js  根路由

```
<HashRouter>
    <Switch>
        <Route path="/films" component={Films}/>   //不要加 exact 否则子页面不显示
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

films组件

```
import React, { Component } from 'react'
import Nowplaying from './films/Nowplaying'
import Comingsoon from './films/Comingsoon'
import {Redirect, Route, Switch} from 'react-router-dom'
export default class Films extends Component {
    render() {
        return (
            <div>
                <div style={{height:"200px",background:"yellow"}}>大轮播</div>

                <div>导航栏  按钮1  按钮2</div>

                {/* 路由配置 嵌套路由 */}
                <Switch>
                    <Route path="/films/nowplaying" component={Nowplaying}/>
                    <Route path="/films/comingsoon" component={Comingsoon}/>
                    <Redirect from="/films" to="/films/nowplaying"/> 
                </Switch>

            </div>
        )
    }
}

```

#### (4)路由跳转方式

按照是否以标签例如<a href='#/films'/>,还是js跳转页面，分类如下：

##### a.   声明式导航

activeClassName 当前显示页面，自动加class。配合css 可以高亮显示tab。

案例那个高亮，加 active.

class类名，以对象方式使用。因为类名会自动编译变化。

```
<NavLink to="/films" activeClassName="active">films</NavLink>   //react 浏览器中会编译成a标签
<NavLink to="/cinemas" activeClassName="active">cinemas</NavLink>
<NavLink to="/center" activeClassName="active">center</NavLink>
```

##### b   编程式导航

案例

###### router.js  根路由

```
<HashRouter>
    <Switch>
        <Route path="/films" component={Films}/>   
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

###### films组件

```
import React, { Component } from 'react'
import Nowplaying from './films/Nowplaying'
import Comingsoon from './films/Comingsoon'
import {Redirect, Route, Switch} from 'react-router-dom'
export default class Films extends Component {
    render() {
        return (
            <div>
                <div style={{height:"200px",background:"yellow"}}>大轮播</div>

                <div>导航栏</div>

                {/* 路由配置 嵌套路由 */}
            {/* <Nowplaying/> */}
                <Switch>
                    <Route path="/films/nowplaying" component={Nowplaying}/>
                    <Route path="/films/comingsoon" component={Comingsoon}/>
                    <Redirect from="/films" to="/films/nowplaying"/> 
                </Switch>

            </div>
        )
    }
}
```



###### Nowplaying组件

当项目引入路由管理，组件都传入router，这时候组件都成为router的孩子，不管是一级路由，还是页面中嵌入的二级路由，组件都可以接受到一个props参数，这个参数就是路由对象。

```javascript
对象中包含了和路由相关的属性和方法。
{
  history,(有路由相关方法： push go goBack goForward replace location等)
  location  
  match  
}
```

props参数  根据来源分为两种：

第一种：形参传入  有以上三个对象

第二种：使用router对象

```
import { useHistory } from 'react-router-dom'
 const history  = useHistory()
 conosole.log(history)
 这个里面只有 history一个； 范围小一些。
```

Nowplaying组件

```
import React,{useState} from 'react'
import { useHistory } from 'react-router-dom'

export default function Nowplaying( props ) {
    const [list, setlist] = useState(["aa","bb","cc"])
    
      const history  = useHistory()
        
    const handleChangePage = (id)=>{
        // console.log("click")
        //  1.原生js跳转
        // window.location.href="#/detail/"+id

        2.使用入参的props
        // props.history.push(`/detail/${id}`)   //函数式写法（）
        // this.props.history.push(`/detail/${id}`) // 类组件式写法
        
  第二种方式：使用 useHistory 方法来自 router插件提供
        //1 -动态路由传参
        // history.push(`/detail/${id}`)
    
        // 2- query传参
        // history.push({ pathname : '/detail' ,query : { myid: id} })

        // 3- state传参
        // history.push({pathname:"/detail",state:{myid:id}})
    }

    return (
        <div>
            {
                list.map(item=> <li onClick={()=>handleChangePage(item)}>{item}</li>)
            }
        </div>
    )
}
```

#### (5) 路由传参

##### 声明式传参

特征和优缺点：

 参数保存位置， url路径中。    当页面刷新，参数不会丢失。

router.js  根路由

```
<HashRouter>
    <Switch>
        {/* /detail/1111  动态路由 */}
         <Route path="/detail/:myid" component={Detail} /> 
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

###### Nowplaying组件   

列表组件  入参

```
如上代码快
...
 2.使用入参的props
 // props.history.push(`/detail/${id}`)   //函数式写法（）
...
```

detail 详情组件 接参

当前路径   http://localhost:3000/#/detail/bb

```
import React from 'react'

export default function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")  //bb为参数值  myid为形参
    return (
        <div>
            deteail
        </div>
    )
}
```

##### 编程式传参    

特征和优缺点：

 参数保存位置， 缓存中。    当页面刷新，参数会丢失。

router.js  

根路由path="/detail" 这种传参就不要加形参  ：myid了。

```
<HashRouter>
    <Switch>
         <Route path="/detail" component={Detail} /> 
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

###### 

```
(1)
   入参
this.props.history.push({ pathname : '/user' ,query : { day: 'Friday'} }) 
   接受参数
this.props.location.query.day
(2)
    入参
this.props.history.push({ pathname:'/user',state:{day : 'Friday' } }) 
  接受参数
this.props.location.state.day
代码参考（4）路由跳转方式小结。
  测试发现this.props.history.push传入的对象， pathname是必须按照格式，后面query state或是其他属性，都可以，只要在接受参数处，一一对应即可。
```

### 4. 路由拦截（路由守卫）

react 并没有像vue router.beforeEach路由前，路由后等api; 所以这里只是用原生函数方法。

router.js

```
鉴权代码 
function isAuth(){
    return localStorage.getItem("token")
}



<Router>
      <Switch>
          <Route path="/films" component={Films}  />
      <Route path="/center" render={(props)=>{
        return isAuth()?<Center myname="tom"/>:<Redirect to="/login"/>
      }/>                 
```

### 5 路由模式

##### hash模式

像这种带#号的，叫锚点，这里称hash模式。不发起请求。

如果不想看到这样，可以使用令一种模式。

```
http://localhost:3000/#/login

import React, { Component } from 'react'
import { HashRouter as Router,Redirect,Route,Switch} from 'react-router-dom'

export default class IndexRouter extends Component {
    render() {
        return (
            <Router>   模式标签
                <Switch>
                    <Route path="/films" component={Films}  />
```

##### history模式

http://localhost:3000/login     像一个真正的路径。

BrowserRouter 没有#的路径，好看 ，真正朝后端发请求要页面，后端没有对应的路径处理路径， 就会404， 不好看。所以后台要做处理，因为项目是单页面，后台并没有对应资源，只需要返回index.html，前台重新渲染。

```
import React, { Component } from 'react'
import { BrowserRouter as Router,Redirect,Route,Switch} from 'react-router-dom'
...
 <Router>   模式标签
 或者
 import { BrowserRouter,Redirect,Route,Switch} from 'react-router-dom'
...
 <BrowserRouter>  </BrowserRouter>  模式标签

```

BrowserRouter as Router 意为： BrowserRouter 解构出来，起了一个别名叫Router。 这样后面代码就不用改了。更加便捷。

### 6 组件丢爹history和干爹支援（高阶组件withRouter）

#### 第一种情况：router 传递页面组件 

##### 

首先确定，父组件传参，子组件props接受参数。

router.js

```
 <BrowserRouter>
                <Switch>
                    <Route path="/films" component={Films}  />
                    
                     <Route path="/center" render={()=>{
                        return isAuth()?<Center myname="tom"/>:<Redirect to="/login"/>
                    }}/>          
```

前面路由守卫时，center组件做了处理，当我们在center组件中，使用history方法时，页面提示未找到方法。

center组件 

```
export default function Center(props) {
    return (
        <div>
            center

            <div onClick={()=>{
                props.history.push(`/filmsorder`)

                // console.log(props)
            }}>电影订单</div>
        </div>
    )
}
```

前面我们提到，使用路由时，被路由标签   <Router>   </Router> 包裹的页面组件，都是子组件，自然可以接受props参数，包含history等。

查看route核心方法

```
// class Route extends Component{
//     ...

//     render(){
//         var MyComponent = this.props.component
//     return <div>
//             <MyComponent history={} match={}.../>
//         </div>
//     }
// }
```

route以变量形式，接受组件，传入参数，再render出去。而center这条路由，直接使用render，并没有传参，测试传递一个自定义参数myname, center组件中，打印props，果然看到参数tom,证实确实是route给出的东西，没有传递下去，导致子组件history方法缺失。

```
<Route path="/center" render={()=>{
                        return isAuth()?<Center myname="tom"/>:<Redirect to="/login"/>
                    }}/> 
```

改进, 解构，传参下去

```
    <Route path="/center" render={(props)=>{
                        console.log(props,'执行了')
                        return isAuth()?<Center myname="kerwin" {...props}/>:<Redirect to="/login"/>
                    }}/>
```

#### 第二种情况 组件传递组件

代码中，FilmItem小组件， props.history.push提示未找到，情况和第一种相似，都是参数在传递过程中，中断。

```
import React,{useState} from 'react'
export default function Nowplaying(props) {       <----------1这个props参数
    const [list, setlist] = useState([1,2,3,4])

    return (
        <div>
            {
                list.map(item=>
                 <FilmItem key={item.filmId} {...item} 	/>     <----------2这里 {...props}
                )
            }
        </div>
    )
}

function FilmItem(props){
    // console.log(props)  // 打印没有 props.history
    let {name,filmId} = props
    return <li onClick={()=>{
        props.history.push(`/detail/${filmId}`)
    }}>
        {name}
    </li>    
}
```

#### 干爹支援

父组件  ---> 子组件 ---> 孙组件， 有点麻烦，是否有其他便捷api？

router提供一个高阶组件，作用是为没有路由属性和方法的普通组件，增益方法。

```
import {withRouter} from 'react-router-dom'
```

使用方法：

```
import React,{useState} from 'react'
import {useHistory,withRouter} from 'react-router-dom'

export default function Nowplaying(props) {
    const [list, setlist] = useState([1,2,3,4])

    return (
        <div>
            {
                list.map(item=>
                 <WithFilmItem key={item.filmId} {...item} />
                )
            }
        </div>
    )
}

             这是一个普通孙组件           
function FilmItem(props){
    // console.log(props)
    let {name,filmId} = props
    return <li onClick={()=>{
        props.history.push(`/detail/${filmId}`)
    }}>
        {name}
    </li>    
}


const WithFilmItem = withRouter(FilmItem)  <----- withRouter方法，包裹普通组件，吐出来增益组件。这样，FilmItem中的onClick里面，就可以使用 props.history.push了。
```

#### withRouter   的应用与原理

You can get access to the history object's properties and the closest <Route>'smatch via the withRouter higher-order component.wi thRouter will pass updatedmatch, location, and history props to the wrapped component whenever itrenders.

```
只要被withRouter加工后，就可以获取到history相关。
 import { withRouter } from "react-router"; 
 withRouter(MyComponent); 
 withRouter(connect(...)(MyComponent))

```





## 十一  Flux与Redux

### Flux介绍

是一种架构思想，专门解决软件的结构问题。它跟MVC架构是同一类东西，但是更加简单和清晰。Flux存在多种实现(至少15种

[https://github.com/voronianski/ﬂux-comparison](https://github.com/voronianski/flux-comparison)

Facebook Flux是用来构建客户端Web应用的应用架构。它利用**单向数据流**的方式来组合React中的视图组件。它更像一个模式而不是一个正式的框架，开发者不需要太多的新代码就可以快速的上手Flux.

![图](.\img\redux.jpg)

### Redux介绍

Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（state对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers），这样就可以进行数据追踪，实现时光旅行。

#### 1  redux介绍及设计和使用的三大原则

原因：[Redux](https://so.csdn.net/so/search?q=Redux&spm=1001.2101.3001.7020)应用需要遵循三大原则，否则程序很容易出现难以察觉的问题。

1  state 以单一对象存储在 store 对象中
2  state 只读(每次都返回一个新的对象)

3  使用纯函数 reducer 执行 state 更新

细化解释：

①唯一数据源

　　Redux只维护一个全局的状态对象，存储在Redux的store中。唯一数据源是一种集中式管理应用状态的方   

​       式，便于监控任意时刻应用的状态和调试应用，减少出错的可能性。

②保持应用状态只读

　　在任何时候都不能直接修改应用状态。当需要修改应用状态时，必须发送一个action，由这个action描述如何   

​       修改应用状态。

③应用状态的改变通过纯函数完成

　　action表明修改应用状态的意图，真正对应用状态做修改的是reducer。reducer必须是纯函数，所以reducer 

​       在接收到action时，不能直接修改原来的状态对象，而是要创建一个新的状态对象返回。

纯函数指的是：

​    对于同样的参数值，函数的返回结果总是相同的。函数的执行不会产生副作用，例如修改外部对象或输出到I/O

 设备。

主要组成action
　　action是Redux中信息的载体，是store唯一的信息来源。把action发送给store必须通过store的dispatch方法。action是普通的JavaScript对象，但每一个action必须有一个type属性描述action的类型，type一般为字符串常量。除了type属性外，action的结构完全由自己决定。一般通过action creator创建action，action creator是返回action的函数

相关文档参看：https://blog.csdn.net/sxww_zyt/article/details/129253498



#### 2. redux 工作流

摘自官网

![示例](https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)



![img](.\img\redux2.jpg)



#### 3. react绑定后使用redux实现案例

##### npm 引入

 官网 https://cn.redux.js.org/introduction/getting-started/

```
# NPM
npm install redux
```

##### 案例演示

：列表页中显示地图tabbar，进入详情页时隐藏。

npm初始化后，在项目根目录中新建redux文件夹子，进入文件夹，新建store.js文件。

###### store.js

```
 //1. 引入redux, 
 //2. createStore( reducer )
 import {createStore} from 'redux'

 const reducer = (prevState={ show:true,},action)=>{
    console.log(prevState,action)
    let newState = {...prevState}
    switch(action.type){
       case "0":
         newState.show = false
         return newState     （return 的state，就变成最新的state，app页面可以获取最新的值）
       case "1":
         newState.show = true
         return newState
       default:
          return prevState
    }
 }
 const store = createStore(reducer);

 export default store
```



###### App.js组件   

项目运行，即执行 store.subscribe 订阅。

只要那个页面调用 dispatch，store.subscribe就会被触发， 拿到已经修改后的数据，做自己的逻辑。

本页面情况是：   

初始加载A页面（订阅者），跳转B页面（触发者），再回A页面。  -----》需要store.subscribe订阅。

  但有一种情况，

就是A页面，跳转B页面（触发者），然后跳往C页面，不需要订阅，直接拿值即可。store.getState()

```react
import React, { Component } from 'react'
import MRouter from './router/IndexRouter'
import Tabbar from './components/Tabbar'
import './views/css/App.css'
               import store from './redux/store'
export default class App extends Component {
    state = {
        isShow:store.getState()
    }

    componentDidMount() {
        store.subscribe(()=>{// store.subsribe 订阅
            console.log("app 中订阅",store.getState())

            this.setState({
                isShow:store.getState().show
            })
        })
    }
    
    render() {
        return (
           <div>
                {/* 其他的内容 */}
                <MRouter>
                    {this.state.isShow && <Tabbar></Tabbar>}
                </MRouter>
           </div>
        )
    }
}

```

###### detail.js组件 

详情组件

```
import React,{useEffect} from 'react'
import store from '../redux/store'

export default function Detail(props) {
    console.log(props.match.params,"利用id去后端拿数据。")
    // console.log(props.location.query.myid,"利用id去后端拿数据。")
    // console.log(props.location.state.myid,"利用id去后端拿数据。")

    useEffect(() => {
        // console.log("create") 渲染完成调用
        
        //store.dispatch  通知
        store.dispatch( {type:"0" } )
        return () => {
            // console.log("destroy") 页面销毁时调用
            
            store.dispatch( {type:"1" } )
        }
    }, [])

    return (
        <div>
            deteail
        </div>
    )
}

```

##### 案例演示逻辑解析

上面案例实现，核心方法

```
/*
store.subscrbe   app页面进入监听

store.dispatch   其他页面调用

store.getState  app页面被触发后，使用该方法获取最新state值

*/
```

diy三个方法

改写store.js

```
 //1. 引入redux, 
 //2. createStore( reducer )
 import {createStore} from 'redux'

 const reducer = (prevState={ show:true},action )=>{
    console.log(action)
    let newState = {...prevState}
    switch(action.type){
       case "kerwinhide-tabbar":
         newState.show = false
         return newState
       case "kerwinshow-tabbar":
         newState.show = true
         return newState
       default:
          return prevState
    }
 }
 const store = createKerwinStore(reducer);// 初始化createStore,更换为下面自定义方法。

 export default store


/*
store.subscrbe   app页面进入监听

store.dispatch   其他页面调用

store.getState  app页面被触发后，使用该方法获取最新state值

*/
  function createKerwinStore(reducer){
     var list = []
     var state = reducer(undefined,{})
     
     function subscribe(callback){
        list.push(callback)
     }
  
     function dispatch(action){
        state = reducer(state,action)
        for(var i in  list){
           list[i] && list[i]()
        }
     }
  
     function getState(){
        return state
     }
     return {
        subscribe,
        dispatch,
        getState
     }
   }

```

其他页面不动，测试发现功能正常。

##### 引申  什么时纯函数

```
 /*
   var obj = {
     myname:"kerwin"
   }
   
   function test(obj){
     var newobj = {...obj}
     newobj.myname="xiaoming"
   
     return newobj
    }
    
    test(obj)  //myname:"xiaoming"
        obj //  myname: "kerwin" obj没有改变（注意：解构是浅复制）

    纯函数： 
      1. 对外界没有副作用 --- 指的是不会修改影响函数外边的变量。这里指不能修改obj对象。
      2. 同样的输入得到同样的输出
 */
```

 根据这个规则，reducers 也可以归类于纯函数类。 它不修改state，每次都是解构后return , 同样的入参，输出同样的出参。 

#### 4 reducer扩展 多命名空间管理

当项目较大，多人开发时，一个retucers肯定不行的，接下来引出新方法 - 

```
 combineReducers  from 'redux'
```

示例如下：

store.js

```
 //1. 引入redux, 
 //2. createStore( reducer )
 import {combineReducers, createStore} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 
 const reducer  = combineReducers({CityReducer,TabbarReducer })
 const store = createStore(reducer);
 export default store
```

子 -- 01

```
const CityReducer = (prevState={
    cityName:"北京"
   //  ...
 },action)=>{

    let newState = {...prevState}
    switch(action.type){
      
       case "change-city":
         newState.cityName = action.payload
         return newState

       default:
          return prevState
    }
 }

 export default  CityReducer
```

子 -- 01

```
const TabbarReducer = (prevState={
    show:true
 },action)=>{
    let newState = {...prevState}
    switch(action.type){
       case "kerwinhide-tabbar":
         newState.show = false
         return newState
       case "kerwinshow-tabbar":
         newState.show = true
         return newState
       default:
          return prevState
    }
 }
 export default TabbarReducer
```

使用state值的时候，也要做相应调整。

```
打印store.getState()就变成
{
 CityReducer: {cityName: '北京'}
 TabbarReducer: {show: true}
}
```



```
    componentDidMount() {
        store.subscribe(()=>{  // store.subsribe 订阅
            console.log("app 中订阅",store.getState())   打印看上边

            this.setState({
                isShow:store.getState().TabbarReducer.show  // 需要再递进一层
            })
        })
    }
```

总结：

如果如果不同的action所处理的属性之间没有联系，我们可以把Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的Reducer 即可

```
import {combineReducers} from "redux"; 

const reducer = combineReducers({
a: functionA, 
b: functionB, 
c: functionC
})

访问：
(state)=>{ return {
        kerwinstate:state.a (不同的命名空间)
    }
}
```



#### 5. redux 中间件 

##### 第一种  redux-thunk

###### 1. 中间件的作用

在redux里，action仅仅是携带了数据的普通js对象。action creator返回的值是这个action类型的对象。然后通过store.dispatch()进行分发。同步的情况下一切都很完美，但是reducer无法处理异步的情况。

那么我们就需要在action和reducer中间架起一座桥梁来处理异步。这就是middleware。

```
 
 store.dispatch(getCinemaListAction())
 
  dispatch的返回函数中，不能是一个异步，就如下面test函数，立即执行后，必须返回东西。
```



```
function test(){
    setTimeout(()=>{
        return 1000 
    },2000)

}

test() //undefined
```

解决这个报错，就需要使用中间件了





###### 2. 中间件 redux-thunk的使用

```
npm i redux-thunk
```

改造store.js文件

原来

```
 import {combineReducers, createStore} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 
 const reducer  = combineReducers({CityReducer,TabbarReducer })
 const store = createStore(reducer);
 export default store
```

现在

使用了 

applyMiddleware  from 'redux'     （redux中，已经给出了插件接口）

import reduxThunk from 'redux-thunk'

createStore时，传入第二个参数 applyMiddleware(reduxThunk)

```react
 import {applyMiddleware, combineReducers, createStore} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 import CinemaListReducer from './reducers/CinemaListReducer'
 import reduxThunk from 'redux-thunk'
 
 const reducer  = combineReducers({
  CityReducer,
  TabbarReducer,
  CinemaListReducer
 })
 const store = createStore(reducer,applyMiddleware(reduxThunk));
 export default store
```

使用页面

```
 dispatch中可以包含axios（url:"xxx"）等异步的操作了
 store.dispatch(getCinemaListAction())
```

项目案例1：

进入列表页，检查store中是否已经有数据，没有就后台请求。

store.js配置好中间件

```react
 import {applyMiddleware,combineReducers, createStore} from 'redux' <----- 关键点
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 import CinemaListReducer from './reducers/CinemaListReducer'
 import reduxThunk from 'redux-thunk'  <----- 关键点

 const reducer  = combineReducers({CityReducer,TabbarReducer ,CinemaListReducer})
 const store = createStore(reducer,applyMiddleware(reduxThunk));<----- 关键点
 export default store
```



列表页

```react
import React,{useState,useEffect} from 'react'
import getCinemaListAction from '../redux/actionCreator/getCinemaListAction'
import store from '../redux/store'
export default function Cinemas(props) {

    const [cityName] = useState(store.getState().CityReducer.cityName)

    const [cinemaList,setCinemaList] = useState(store.getState().CinemaListReducer.list)


    useEffect(() => {
        // if(store.getState)
        // console.log()
        if(store.getState().CinemaListReducer.list.length===0){
            //去后台取数据
            // actionCreator 里写异步
            store.dispatch(getCinemaListAction())
        }else{
            console.log("store 缓存")
        }
        //订阅
        store.subscribe(()=>{
            console.log("cinema 中订阅",store.getState().CinemaListReducer.list)
            setCinemaList(store.getState().CinemaListReducer.list)
        })

        // windw
    }, [])

    return (
        <div>
            <div onClick={()=>{
                props.history.push(`/city`)
            }}>{cityName}</div>
            {
                  cinemaList.map(item=>
                    <dl key={item.cinemaId} style={{padding:"10px"}}>
                        <dt>{item.name}</dt>
                        <dd style={{fontSize:"12px",color:"gray"}}>{item.address}</dd>
                    </dl>    
                )
            }
        </div>
    )
}

```

数据请求js

```react
import axios from 'axios'
function getCinemaListAction(){

    return (dispatch)=>{
        axios({
            url:"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159",
            method:"get",
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.0.4","e":"16395416565231270166529","bc":"110100"}',
                
                'X-Host': 'mall.film-ticket.cinema.list'
    
            }
        }).then(res=>{
            // console.log(res.data.data.cinemas)
            dispatch({
                type:"change-list",
                payload:res.data.data.cinemas
            })
        })   
    }    
}

export default getCinemaListAction

```

##### 第二种 Promise方式

使用方式：

```
作为一款插件引入
npm i redux-promise
```

store.js中使用

```react
 import {applyMiddleware,combineReducers, createStore} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 import CinemaListReducer from './reducers/CinemaListReducer'
 import reduxThunk from 'redux-thunk'

 import reduxPromise from 'redux-promise'//中间件promise <--------重点
 

 const reducer  = combineReducers(
 {CityReducer,
 TabbarReducer ,
 CinemaListReducer
 })
 
 const store = createStore(
 reducer,
 applyMiddleware(reduxThunk,reduxPromise)); <--------重点 传入第二款中间件
 
 export default store
```

触发页面

```react
 useEffect(() => {
        // if(store.getState)
        // console.log()
        if(store.getState().CinemaListReducer.list.length===0){
            //去后台取数据
            // actionCreator 里写异步
            store.dispatch(  getCinemaListAction()  )  <--------重点 dispatch方法
        }else{
            console.log("store 缓存")
        }
        //订阅
        var unsubscribe = store.subscribe(()=>{
            console.log("cinema 中订阅",store.getState().CinemaListReducer.list)
            setCinemaList(store.getState().CinemaListReducer.list)
        })
        return ()=>{
            //取消订阅？
            unsubscribe() 
        }
    }, [])
```

getCinemaListAction() 封装页面

与redux-thunk的区别：

redux-thunk 

```react
test(){
return ( dispatch )=>{   <--------重点 return 的是一个函数
    axios({}).then(res =>{
        dispatch({        <--------重点 使用入参方法dispatch返回数据
                type:"change-list",
                payload:res.data.data.cinemas
            })
    }) 
}

}
export default test
```

promise版本

```
test(){
 return   axios({}).then(res =>{ <--------重点 return 的是一个promise( axios就是promise类的 )
    
       return  { type:"change-list",  <--------重点 return 出去参数
                payload:res.data.data.cinemas
              }
    }) 


}
export default test
```

原理就是：

store.dispatch( xx ）接受到的东西，它会判断一个function  ，就（）执行；还是Promise  就then出去。





```
import axios from 'axios'
function getCinemaListAction(){

    // return (dispatch)=>{
        return axios({
            url:"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159",
            method:"get",
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.0.4","e":"16395416565231270166529","bc":"110100"}',
                
                'X-Host': 'mall.film-ticket.cinema.list'
    
            }
        }).then(res=>{
            // console.log(res.data.data.cinemas)
            // dispatch({
            //     type:"change-list",
            //     payload:res.data.data.cinemas
            // })
           return {
                type:"change-list",
                payload:res.data.data.cinemas
            }
        })   
    // }    
}

export default getCinemaListAction
```









#### 6. 关于反复订阅的问题

页面列表中，使用了 store.subscribe订阅， 但是发现一个问题，就是只要返回数据， 所有订阅者都会触发，不管你需不需要，并且单个页面还会重复订阅。原因是，redux是一个运行在缓存中的逻辑，每次订阅都会往事件数组列中push新的回调执行，然后当数据返回时，又把列表里的订阅事件，执行了一遍。

```
import React,{useState,useEffect} from 'react'
import getCinemaListAction from '../redux/actionCreator/getCinemaListAction'
import store from '../redux/store'
export default function Cinemas(props) {

    const [cityName] = useState(store.getState().CityReducer.cityName)

    const [cinemaList,setCinemaList] = useState(store.getState().CinemaListReducer.list)


    useEffect(() => {

        if(store.getState().CinemaListReducer.list.length===0){
            //去后台取数据
            // actionCreator 里写异步
            store.dispatch(getCinemaListAction())
        }else{
            console.log("store 缓存")
        }
        //订阅
        store.subscribe(()=>{
            console.log("cinema 中订阅",store.getState().CinemaListReducer.list)
            setCinemaList(store.getState().CinemaListReducer.list)
        })

    }, [])

    return (
        <div>
            <div onClick={()=>{
                props.history.push(`/city`)
            }}>{cityName}</div>
            {
                  cinemaList.map(item=>
                    <dl key={item.cinemaId} style={{padding:"10px"}}>
                        <dt>{item.name}</dt>
                        <dd style={{fontSize:"12px",color:"gray"}}>{item.address}</dd>
                    </dl>    
                )
            }
        </div>
    )
}
```

解决方法：

store.subscribe在订阅的时候，返回了一个取消订阅的函数，只要在适当时机执行，就可以取消订阅。

```

    useEffect(() => {

        if(store.getState().CinemaListReducer.list.length===0){
            //去后台取数据
            // actionCreator 里写异步
            store.dispatch(getCinemaListAction())
        }else{
            console.log("store 缓存")
        }
        //订阅
       var unsubscribe =  store.subscribe(()=>{ <----- 重点
            console.log("cinema 中订阅",store.getState().CinemaListReducer.list)
            setCinemaList(store.getState().CinemaListReducer.list)
        })
       return ()=>{
        //页面销毁时执行
        // 取消订阅
        unsubscribe()  <----- 重点
       }
    }, [])
```





#### 7. 插件（可视化redux数据）

Redux DevToolsExtension ；   类似与vue  的  vuejsdevtools；作用都是开发辅助，方便查看数据变化。

redux插件下载地址（ 可以下载chrome浏览器） 下载扩展zip包，下载后，拖到chrome扩展程序处，即自动安装。

https://github.com/zalmoxisus/redux-devtools-extension

然后，项目中配置

store.js参数配置

https://github.com/zalmoxisus/redux-devtools-extension#usage

```
import { 
createStore, 
compose    <----- 重点  解构出这个参数
} from 'redux' 
import reducer from './reducer'

const composeEnhancers = window.  REDUX_DEVTOOLS_EXTENSION_COMPOSE	 || compose; const store = createStore(reducer, 
composeEnhancers( 原来的中间件 )      <----- 重点  包裹原来的中间件
)

```

示例：

```
 import {applyMiddleware,combineReducers, createStore, compose} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 import CinemaListReducer from './reducers/CinemaListReducer'
 import reduxThunk from 'redux-thunk'

 import reduxPromise from 'redux-promise'

 const composeEnhancers = window.  REDUX_DEVTOOLS_EXTENSION_COMPOSE	 || compose;

 const reducer  = combineReducers({CityReducer,TabbarReducer ,CinemaListReducer})
 const store = createStore(reducer, composeEnhancers(applyMiddleware(reduxThunk,reduxPromise)));
 export default store

```

刷新页面

![](.\img\微信截图_20231112165343.png)



## 十二 react-redux 

![img](.\img\clip_image002.jpg)

#### 1 .口述功能

使用本库的前提，要使用redux. 

依赖与redux,增加了一点react特性。

react-redux就是一个高阶组件，把属性和方法注入到了props.  

用它来发布，订阅，取消订阅等繁琐的事情，更加注重业务。 

​               效果：            低阶组件--->   处理包装 ------> 高阶组件  增加了属性和方法

**实现方式：**

是增加了connect函数生成一个父组件，父传子方式，传递参数。

connect（供应商组件） 包裹<app/>标签，然后每个页面组件使用，就把那个组件改造一下。

#### 2.使用

```
npm i react-redux 
```

#### 3. 案例演示

index.js页面

```
import React from 'react'
import ReactDOM from 'react-dom'
import App from './05-redux/App'

import {Provider} from 'react-redux'    <---- 重点
import {store} from './06-react-redux/redux/store' <---- 重点

ReactDOM.render(

    <Provider store={store}>  <---- 重点  在顶级标签，供应商组件包裹，注入store仓库
         <App/>
    </Provider>
    
  ,document.getElementById("root"))
```

##### 示例01 

app组件改造示例01 

```
import React, { Component } from 'react'
import MRouter from './router/IndexRouter'
import Tabbar from './components/Tabbar'
import './views/css/App.css'

import { connect } from 'react-redux' <---- 重点  引入connect方法

 class App extends Component {

    componentDidMount() {
        console.log(this.props)
    }

    render() {
        return (
           <div>
         
                <MRouter>
                  {this.props.isShow && <Tabbar></Tabbar>} <---- 重点 isShow的拿参形式
               </MRouter>
              
           </div>
        )
    }
}

const mapStateToProps = (state)=>{
    // console.log(state)
    return {
        a:1,
        b:2,
        isShow:state.TabbarReducer.show
    }
}
const  callback = {
    a:()=>{

    },
    b:()=>{

    }
}
    
export default connect( mapStateToProps,callback )(App) <---- 重点 解释如下
```

connect（a,b）返回一个函数，再把App入参。这样是为了便于我们自定义传参。 

--形参a      将来给孩子传的属性

是一个函数 return 一个对象，这里面可以拿到顶级传入的store参数，选取本页面会使用道到的 isshow .

--形参b  将来给孩子传的回调函数

传入回调方法，这里面可以是请求的数据，等自定义的东西。

传入之后，项目中所有的组件都视为Provider的子组件，通过props拿到自己传入的参数。

##### 示例02

detail详情组件示例2

列表页执行代码

```
 props.history.push(`/detail/${filmId}`)
```

详情页：

```react
import React,{useEffect} from 'react'
import { show,hide } from '../redux/actionCreator/TabbarActionCreator'

import {connect} from 'react-redux' <---- 重点

 function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")

    let  {show,hide,match} = props; // 把参数解构出来 否则依赖过多 浏览器warm提示

    useEffect(() => {
        // console.log("create")
        // store.dispatch(hide())
                  hide()  <---- 重点 原来dispatch的方法替换为更为更为简洁的hide()
        return () => {
            console.log("destroy")
            // store.dispatch(show() )
                    show()  <---- 重点
        }
    }, [match.params.myid, show,hide]) 依赖参数

    return (
        <div>
            deteail
        </div>
    )
}
const mapDispatchToProps  = {
    show,
    hide
}
export default connect(null,mapDispatchToProps)(Detail) <---- 重点 组件提升
```

TabbarActionCreator 方法

```
 function hide(){
     return {
        type:"kerwinhide-tabbar"
    }
 }

 function show(){
    return {
        type:"kerwinshow-tabbar"
    }
 }

 export {show,hide}
```

##### 示例03 

city.js组件改造

```
import React,{useState} from 'react'
import {connect} from 'react-redux'  <---- 重点

 function City(props) {
    const [list] = useState(["北京","上海","深圳","广州"])
    return (
        <div>
            city

            <ul>
                {
                    list.map(item=>
                    <li key={item} onClick={()=>{
                        // store.dispatch({
                        //     type:"change-city",
                        //     payload:item
                        // })
                        props.change(item)  <---- 重点 传入行参数item

                        props.history.goBack()
                    }}>{item}</li>    
                    )
                }
            </ul>
        </div>
    )
}
const mapDispatchToProp =  {
    change(item){     接受参数  item 
        return {
            type:"change-city",       //这里是通过type挨个区匹配reducer
            payload:item
        }
    }
}

export default connect(null,mapDispatchToProp)(City) <---- 重点
```

CityReducer.js

```
const CityReducer = (prevState={
    cityName:"北京"
   //  ...
 },action)=>{

    let newState = {...prevState}
    switch(action.type){
      
       case "change-city":
         newState.cityName = action.payload
         return newState

       default:
          return prevState
    }
 }

 export default  CityReducer
```

##### 示例04

Cinemas.js电影列表页面  改造

```react
import React,{ useEffect } from 'react'
import getCinemaListAction from '../redux/actionCreator/getCinemaListAction'
import { connect } from 'react-redux' <---- 重点

 function Cinemas(props) {

    let {list, getCinemaListAction, cityName} = props

    useEffect(() => {

        if(list.length===0){
            //去后台取数据
            // actionCreator 里写异步
            // store.dispatch(getCinemaListAction())
            getCinemaListAction()  <---- 重点
        }
    }, [list,getCinemaListAction]) <---- 重点
    return (
        <div>
            <div style={{overflow:"hidden"}}>
                <div onClick={()=>{
                    props.history.push(`/city`)
                }} style={{float:"left"}}>{ cityName }</div>
                <div style={{float:"right"}} onClick={()=>{
                    props.history.push(`/cinemas/search`)
                }}>搜索</div>
            </div>
            {
                  list.map(item=> <---- 重点 这里直接使用解构出来的 list
                    <dl key={item.cinemaId} style={{padding:"10px"}}>
                        <dt>{item.name}</dt>
                        <dd style={{fontSize:"12px",color:"gray"}}>{item.address}</dd>
                    </dl>    
                )
            }
        </div>
    )
}
const mapStateToProps = (state)=>{ <---- 重点  顶级组件给的参数  数据仓库
    return {
        list:state.CinemaListReducer.list,
        cityName:state.CityReducer.cityName
    }
}

const mapDispatchToProps = {
    getCinemaListAction
}
export default connect(mapStateToProps,mapDispatchToProps)(Cinemas)<---- 重点
```

#### 4.总结

react-redux插件的引入，把数据从页面抽离，使每个页面都变成了Ui组件。

###### 扩展 ：UI组件和容器组件

###### 1）UI组件

• 只负责 UI 的呈现，不带有任何业务逻辑

• 没有状态（即不使用this.state这个变量）

• 所有数据都由参数（this.props）提供

• 不使用任何 Redux 的 API

###### (2) 容器组件

• 负责管理数据和业务逻辑，不负责 UI 的呈现

• 带有内部状态
•用 Redux 的 API

###### 细化解释：

展示组件负责应用的UI展示，也就是组件如何渲染，具有很强的内聚性。展示组建不关心渲染时使用的数据是如何获取到的，它只要知道有了这些数据后，组件应该如何渲染就足够了。

容器组件负责应用逻辑的处理，如发送网络请求、处理返回数据，将处理过的数据传递给展示组件使用等。容器组件还提供修改源数据的方法，通过展示组件的props传递给展示组件，当展示组件的状态变更引起源数据变化时，展示组件通过调用容器组件提供的方法同步这些变化。

展示组件和容器组件可以自由嵌套。

注意！展示组件和容器组件是根据组件意图划分的，无状态组件和有状态组件是根据组件内部是否使用state划分组件。通常情况下，展示组件是通过无状态组件实现的，容器组件是通过有状态组件实现的，但是展示组件也可以是有状态组件。，容器组件也可以是无状态组件。


##### **1.**  Provider  与  connect

(1)React-Redux  提供Provider组件，可以让容器组件拿到state

```
import React from 'react'
import ReactDOM from 'react-dom'


import { Provider } from 'react-redux' import store from './store'

import App from './App'


const rootElement = document.getElementById('root') ReactDOM.render(
<Provider store={store}>
<App />
</Provider>, rootElement
)

```

##### 2. React-Redux 提供connect方法

，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来

```
import { connect } from 'react-redux'
import { increment, decrement, reset } from './actionCreators'


// const Counter = ...
const mapStateToProps = (state /*, ownProps*/) => { return {
counter: state.counter
}
}
const mapDispatchToProps = { increment, decrement, reset } export default connect(
mapStateToProps, mapDispatchToProps
)(Counter)

```

#####  3  HOC与context通信在react-redux底层中的应用

(1)     connect 是HOC， 高阶组件

(2)  Provider组件，可以让容器组件拿到state ， 使用了context( 跨级通信 )

##### 4 高阶组件构建与应用

HOC不仅仅是一个方法，确切说应该是一个组件工厂，获取低阶组件，生成高阶组件。

 (1)代码复用，代码模块化

(2) 增删改props

(3)   渲染劫持

**示例**

```javascript
// Child.js

//高阶函数  入参为低阶组件
function Control(wrappedComponent) {
  return class MyControl extends React.Component {
    render() {
      if (!this.props.data) {
        return <div>loading...</div>
      }
      return <wrappedComponent {...props} />
    }
  }
}


class MyComponent extends React.Component {
  render() {
    return <div>{this.props.data}</div>
  }
}
export default Control(MyComponent); //输出高阶组件



//Parent.js
import MyControlComponent from "./Child"
<MyControlComponent data={this.state.value}/>

//在父级传入data是null的时候，这一块儿就只会显示loading...,
//不会显示组件的具体内容，如果data不为null,  就显示真实组件信息。

```

#### 5.原理探究

```
...
export default connect(mapStateToProps,mapDispatchToProps)(Cinemas)<---- 重点

这里组件使用connect方法处理后，为低阶组件，增加了属性和方法，对这一核心方法解析。
```

   根据输入和输出效果，自定义connect方法 

   如下

```
import React,{useEffect} from 'react'
//低阶组件
function NotFound(props) {
    useEffect(() => {
        console.log(props)
    }, [props])
    return (
        <div>
            404 not found
        </div>
    )
}
自定义connenct方法
function kerwinconnenct(cb,obj){
    var value = cb()
    return (MyComponent)=>{
        return (props)=>{
            // console.log()
            return <div style={{color:"red"}}>
                <MyComponent {...value} {...props} {...obj}/>
            </div>
        }
    }
}
输出高阶组件
export default kerwinconnenct(()=>{
    return {
        a:1,
        b:2
    }
},{
    aa(){},
    bb(){}
})(NotFound)

```



#### redux持久化改造

使用插件 redux-persist 

前提：最好使用了react-redux之后，再使用这个。

https://github.com/rt2zz/redux-persist

使用

```
npm i redux-persist

```

 需要改造两处

store.js文件

```react
 import {applyMiddleware,combineReducers, createStore, compose} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 import CinemaListReducer from './reducers/CinemaListReducer'
 import reduxThunk from 'redux-thunk'
 import reduxPromise from 'redux-promise'

 import { persistStore, persistReducer } from 'redux-persist'
 import storage from 'redux-persist/lib/storage' // defaults to localStorage for web
 
 const persistConfig = {
    key: 'kerwin',
    storage,
    whitelist: ['CityReducer']
  }
  
  const reducer  = combineReducers({
    CityReducer,
    TabbarReducer,
    CinemaListReducer
   })
  const persistedReducer = persistReducer(persistConfig, reducer)
  
  
  
   const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
  
   const store = createStore(persistedReducer,composeEnhancers(applyMiddleware(reduxThunk,reduxPromise)));
   let persistor = persistStore(store)
  
   export {store,persistor}
```

index.js

```react
import React from 'react'
import ReactDOM from 'react-dom'
import App from './05-redux/App'

import {Provider} from 'react-redux'
import {store,persistor} from './05-redux/redux/store'

console.log(store)
ReactDOM.render(

    <Provider store={store}>
          <PersistGate loading={null} persistor={persistor}>
             <App/>
          </PersistGate>
        
    </Provider>

  ,document.getElementById("root"))
```

应该可以了

## 十九 redux-saga

#### 简介

在*saga*中，全局监听器和接收器使用*Generator（ES6生成器方法）*函数和*saga*自身的一些辅助函数实现对整个流程的管控。

redux-saga 是一个 redux 中间件，注意 redux-saga 是 redux 中间件，这意味着它应该配合 redux 一起使用，并且 react-redux 是将 redux 的 store 连接到 React 组件中，因此他们三者 **redux， react-redux, redux-saga** 是合作关系而非对立关系。

![](.\img\saga.jpg)



#### **原理实现：ES6生成器**

![](.\img\saga1.jpg)



Generator ES6生成器： 又叫状态机。也是一种异步解决方案。本插件基于该能力。

效果类似与步进电机， 执行一步，走一步。可以传参，和接受参数。

项目中使用场景： 授权过程中， 第一个接口，拿到参数，调用第二个接口，参数用于调用第三个。



案例1：

演示基本运行逻辑

```react
function *test(parms){ // 声明方法    普通函数前面加星号
    console.log("111111",parms)
    var input1 = yield "111-输出";  //yield 关键字 每一个代表一步

    console.log("22222",input1) //第二步
    var input2 =yield "222-输出";//第二步

    console.log("333333",input2)//第三步
    var input3 =yield "333-输出";//第三步
    console.log("444444",input3) 
}

var kerwintest = test('初始传参') //生成状态机

var res1 = kerwintest.next('第一步传参')//每一步走完 都会得到一个对象
// console.log(res1) //返回一个对象 {done: false,value: "111-输出"}  done表示还不是最后一步 value为这一步中*test的入参
var res2 = kerwintest.next('aaaa第二步')
console.log(res2)
var res3 = kerwintest.next('bbbb第三步')
console.log(res3)
var res4 = kerwintest.next('ccccc第四步')

console.log(res4) // {done: true value: undefined}   三个yield next第四个 返回 false

```

案例2： 异步形式的

**原来的方式**

```
async function  A(){
    var res1 =await fetch()
    var res2 =await fetch()
    var res3 =await fetch()

  console.log(res3)
}
```

生成器方式

链式调用

```react
function *test1(){

    setTimeout(()=>{
        console.log("11111-success")
        kerwintest1.next() //自动执行第二步
    },1000)

    yield;
    setTimeout(()=>{
        console.log("222222-success")

        kerwintest1.next()  //自动执行第三步
    },1000)
    yield;
    setTimeout(()=>{
        console.log("3333-success") 
    },1000)
    yield;
}

var kerwintest1 = test1()

kerwintest1.next() // 第一步启动一下
```



#### 正题

本插件是解决异步的，不要为使用而使用。

##### 安装

```
npm install --save redux-saga
```

##### 案例

![](.\img\saga3.png)



一下演示是，saga监听多个saga事件

###### 事件逻辑链： 

**appjs** ： store.dispatch 发起type =get-list1的事件

**saga/saga1.js**：生成器函数得到正在监听中的  yield take("get-list1") ====》执行另一个yield fork 接口获取数据，等待获取到后，发起   yield put  type = change-list1的事件，并携带获取到的数据 入参payload

 **retucerjs**  case "change-list1,触发，接受payload 并reture,触发页面。

（

  如果就监听一个：就不用合并，sore.js文件 

```
import watchSaga from './saga-every' //如果就一个watchSaga1 直接导入，放到run里就行了
```

更换为：

```
import watchSaga from './saga1.js' 
```

）

###### app.js使用页面

```react
import React, { Component } from 'react'
import store from './redux/store'

export default class App extends Component {
    constructor(props) {
        super(props);
        this.state = {
            data:"--"
        }
      }
    render() {
        return (
            <div>
                 <div>7777{ this.state.data }</div>
                <button onClick={() => {
                    if (store.getState().list1.length === 0) {
                        //dispatch
                        store.dispatch({
                            type: "get-list1"
                        })
                    } else {
                        console.log("缓存", store.getState().list1)
                        this.setState({
                            data:store.getState().list1
                        })
                    }

                }}>click-ajax-异步缓存111</button>

                <button onClick={() => {
                    if (store.getState().list2.length === 0) {
                        //dispatch
                        store.dispatch({
                            type: "get-list2"
                        })
                    } else {
                        console.log("缓存", store.getState().list2)
                    }

                }}>click-ajax-异步缓存222</button>
            </div>
        )
    }
}
```



###### store.js文件

```react
import {createStore,applyMiddleware } from 'redux'
import reducer from './reducer'
import createSagaMidlleWare from 'redux-saga'
import watchSaga from './saga-every' //如果就一个watchSaga1 直接导入，放到run里就行了

const SagaMidlleWare = createSagaMidlleWare()
const store = createStore(reducer,applyMiddleware(SagaMidlleWare))// saga以中间件形式使用


SagaMidlleWare.run(watchSaga) //saga任务，
export default store
```

###### reducer.js

```react
function reducer(prevState = {
    list1: [],
    list2: []
}, action = {}) {
  
    var newState = { ...prevState }
    switch (action.type) {
        case "change-list1":
            // console.log(action)
            newState.list1 = action.payload
            return newState
        case "change-list2":
            // console.log(action)
            newState.list2 = action.payload
            return newState
        default:
            return prevState
    }
    // return prevState
}

export default reducer
```

###### saga.js

```react
import {all} from 'redux-saga/effects'
import watchSaga1 from './saga/saga1'
import watchSaga2 from './saga/saga2'
function *watchSaga(){
    yield all([watchSaga1(),watchSaga2()]) //all函数，聚合多个
}

export default watchSaga
```

###### saga-every.js

```react
import {takeEvery} from 'redux-saga/effects'
import { getList1 } from './saga/saga1'
import { getList2 } from './saga/saga2'

function *watchSaga(){   生成器函数 管理多个
    yield takeEvery("get-list1",getList1) 
    yield takeEvery("get-list2",getList2)
}

export default watchSaga
```

###### saga/saga1.js

```react
import {takeEvery,put,call ,take,fork}  from 'redux-saga/effects'
function *watchSaga1(){
    console.log('saga')
    // while(true){
        // take 监听 组件发来的action
        yield take("get-list1")
        // fork 同步执行异步处理函数
        yield fork(getList1) // 执行生成器
    // }  

    // yield takeEvery("get-list1",getList1)
}
  
function *getList1(){
    //异步处理的，

    // call函数发异步请求
    let res = yield call(getListAction1)//阻塞的调用fn / call(返回值是一个promise对象的函数)

    yield put({ //等待 获取到请求回来的res 立即发起新的action动作 （下一步就是reducer接收到动作）
        type:"change-list1",
        payload:res
    }) 
    // put函数发出新的action,非阻塞式执行
}

function getListAction1(){ // 模拟真正接口请求
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve(["1111","2222","3333"])
        },2000)
    })
}

export default watchSaga1
export {getList1}
```

###### saga/saga2.js

```react
import {takeEvery,put,call }  from 'redux-saga/effects'
function *watchSaga2(){
    // while(true){
    //     // take 监听 组件发来的action
    //     yield take("get-list2")
    //     // fork 非阻塞调用 的形式执行 fn
    //     yield fork(getList2)
    // }  
    yield takeEvery("get-list2",getList2)
}
  
function *getList2(){
    //异步处理的，

    // call函数发异步请求
    let res1 = yield call(getListAction2_1)//阻塞的调用fn
    let res2 = yield call(getListAction2_2,res1)//阻塞的调用fn

    yield put({
        type:"change-list2",
        payload:res2
    }) 
    // put函数发出新的action,非阻塞式执行
}

function getListAction2_1(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve(["4444","5555","66666"])
        },2000)
    })
}

function getListAction2_2(data){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve([...data,"777","888","999"])
        },2000)
    })
}
export default watchSaga2
export {getList2}
```



###### 新增需求

提示： 封装可以更简单一点

```
    yield take("get-list1")
     yield fork(getList1) 
     快捷写法  等价于
     yield takeEvery("get-list1",getList1)
```



saga1js中，请求两次数据处理方法

```react
import {takeEvery,put,call ,take,fork}  from 'redux-saga/effects'
function *watchSaga1(){
    console.log('saga')
        // take 监听 组件发来的action
        yield take("get-list1")
        // fork 同步执行异步处理函数
        yield fork(getList1) // 执行生成器

    // yield takeEvery("get-list1",getList1)
}
  
function *getList1(){
    //异步处理的，

    // call函数发异步请求
    let res1 = yield call(getListAction1_1)//阻塞的调用fn / call(返回值是一个promise对象的函数)
    let res2 = yield call(getListAction1_2,res1)//阻塞的调用fn / call(返回值是一个promise对象的函数)

    yield put({ //等待 获取到请求回来的res 立即发起新的action动作 （下一步就是reducer接收到动作）
        type:"change-list1",
        payload:res2
    }) 
    // put函数发出新的action,非阻塞式执行
}

function getListAction1_1(){ 
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve(["1111","2222","3333"])
        },2000)
    })
}
function getListAction1_2(list){ 
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve([...list,"我是第二次加入的数据"])
        },2000)
    })
}

export default watchSaga1
export {getList1}
```

















## 十三 UI组件库

### Ant Design

Ant Design 是一个致力于提升『用户』和『设计者』使用体验的设计语言 ；旨在统一中台项目的前端 UI 设计，屏蔽不必要的设计差异和实现成本，解放设计和前端的研发资源； 包含很多设计原则和配套的组件库。

1.ant-design (PC端)
https://ant.design/index-cn
https://ant-design.gitee.io/index-cn (镜像库，快)
2.antd-mobile (移动端)
https://mobile.ant.design

案例：pc版

```
npm install antd --save    /   yarn add antd     /  cnpm install antd --save
```

在react项目的APP.js文件中引入 Antd的css(全局）

```
@import 'antd/dist/antd.css';
```

可能出现的问题： 样式文件找不着

```
首先把原本的依赖卸载
npm remove antd
然后安装上一个版本的依赖，口令为：
npm add antd@^4.24.2
检查node_modules依赖 发现有这个文件了ok
```

注意点：

1.这里使用的是版本4；如果一直引入不成功，就删除依赖，再初始化。

2.4版本使用图标需要另外引入npm i 

终于在官方issue里面找到原因是 antd 4+版本不带有 @[ant-design](https://so.csdn.net/so/search?q=ant-design&spm=1001.2101.3001.7020)/icons，包括 

@ant-design/compatible 等等

直接安装 **npm i @ant-design/icons** 解决

cnpm uninstall @ant-design/icons 











## 十四 Immutable

 词义：adj.永恒的，不可改变的

https://github.com/immutable-js/immutable-js

作为一款插件，解决一个痛点。该插件的作用就是高性能的深复制数据，功能只是数据的处理，不关乎框架，

引入react的原因，是react的特性，单向数据流，在修改data的时候，不能改变原数据，使用场景多一点而已。

### 1. 痛点引入

#### 第一步：

   ```
// 引用复制 (浅复制)
var obj = {
    name:"zhangsan"
}

var obj2 = obj
obj2.name = "xiaomoing"
console.log(obj,obj2)//  {name: 'xiaomoing'} {name: 'xiaomoing'}
结论：变量直接等于，指针变化而已，数据源同一个，一旦修改，原数据也跟着改变。
   ```

#### 第二步：

```javascript
// 比浅复制多复制了一层
var myobj = {
    name:"zhangsan",
    arr:[1,2,3]
}
var myobj2 = {  // 使用解构复制
    ...myobj   
}
myobj2.name = "xiaoming"
myobj2.arr.splice(1,1)

console.log(myobj,myobj2) 
//{arr: [1, 3], name: "zhangsan" }  {arr: [1, 3], name: "xiaoming" } 
 结论：表层数据没有影响，深层解构还是修改了
```

#### 第三步:

```javascript
// json-parse json-stringify -深复制- 不能有undefined

var jsonobj ={
    name:"zhangsan",
    arr:[1,2,3],
    address:undefined
}

var jsonobj2 = JSON.parse(JSON.stringify(jsonobj))
jsonobj2.name = "xiaoming"
jsonobj2.arr.splice(1,1)

console.log(jsonobj,jsonobj2)
//{arr: [1,2, 3], name: "zhangsan" }  {arr: [1, 3], name: "xiaoming" } 
结论：成功复制，切没有改变原数据。 但是复制的数据中不能有undefined，会丢失掉。
// deepcopy
// 递归深复制-一层层复制， 性能不好，占用内存，因为这个方法，它是完整的复制了一份数据。
```

### 2.Immutable介绍

#### Immutable功能：

每次修改一个  Immutable  对象时都会创建一个新的不可变的对象，在新对象上操作并不会影响到原对象的数据。

#### Immutable优化性能的方式：

Immutable 实现的原理是
Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免
deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了
Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享

![](https://upload-images.jianshu.io/upload_images/2165169-cebb05bca02f1772)



## 3.插件使用

 ```
# using npm
  1. npm i immutabel
  2. import {Map} from 'immutable'
 ```

### 对象的使用和修改 Map方法

```
import React, { Component } from 'react'
import {Map} from 'immutable'

var obj = {
    name:"zhangsan",
    age:100
}

var oldImmuObj = Map(obj)     //Map把对象转化成immutable对象
var newImmuObj = oldImmuObj.set("name","xiaoming") //.set(key , value) 形式修改对象值
// console.log(oldImmuObj,newImmuObj) // 没有修改原数据

//1 get获取immutalble 

console.log(oldImmuObj.get("name"),newImmuObj.get("name"))// 获取immutable对象的值

//2 immutable===>普通对象

console.log(oldImmuObj.toJS(),newImmuObj.toJS()) //.toJS()方法，还原成普通的js对象
```

### 案例01:Map方法set方法toJS方法

使用Map方法，修改name,age，并更新视图。此案例：immutable仅参与数据处理，不参与视图显示

```
import React, { Component } from 'react'
import {Map} from 'immutable'

export default class App extends Component {

    state = {
        info:{
            name:"zs",
            age:100
        }
    }
    render() {
        return (
            <div>
                
                <button onClick={()=>{
                
  var old = Map(this.state.info) //1.数据类型转化
 var newImmu = old.set("name","xiaoming").set("age",18) //2.数据处理
                    this.setState({
                        info:newImmu.toJS()  //3.数据还原
                    })
                    
                }}>click</button>
                {this.state.info.name}--
                {this.state.info.age}
            </div>
        )
    }
}
```

### 案例2

immutable应用于深层数据结构使用方法，和基于不修改保持不变的特性的利用

下面案例展示：

01.深层级数据filter，也要加上Map，否则会影响原数据

02.利用不修改不变换原理，可以减少子组件的重复渲染



```
import React, { Component } from 'react'
import {Map} from 'immutable'
export default class App extends Component {

    state = {
        info:Map({
            name:"kerwin",
            select:"aa",
            filter:Map({
                text:"",
                up:true,
                down:false
            })
        })
    }

    componentDidMount() {
        console.log(this.state.info.get("filter"))
    }
    
    render() {
        return (
            <div>
                <button onClick={()=>{
                    this.setState({
                        info:this.state.info.set("name","xiaoming").set("select","bb")
                    })
                }}>click</button>
                {this.state.info.get("name")}
                <Child filter={this.state.info.get("filter")}/>
            </div>
        )
    }
}


class Child extends Component{
    shouldComponentUpdate(nextProps, nextState) { // 生命周期函数，是否渲染组件，false则不变
        if(this.props.filter === nextProps.filter){
            return false
        }
        return true
    }
    
    render(){
        return <div>
            child
        </div>
    }

    componentDidUpdate(){
        console.log("componentDidUpdate")
    }
}
```

### 案例3 List方法

```javascript
import React, { Component } from 'react'
import {List} from 'immutable'
var arr = List([1,2,3])

var arr2 = arr.push(4) //不会影响老的对象结构
var arr3 = arr2.concat([5,6,7])
console.log(arr.toJS(),arr2.toJS(),arr3.toJS())
打印结果：
 [1, 2, 3]
 [1, 2, 3, 4]
 [1, 2, 3, 4, 5, 6, 7]
 
export default class App extends Component {
    state = {
        favor:List(["aaa","bbb","ccc"])  
 //immutable的数组，push,concat等正常的js方法，在这里都不会修改原数据。（为了减低学习成本，保持一致）
    }
    render() {
        return (
            <div>
                {
                    this.state.favor.map(item=>
                      <li key={item}>{item}</li>    
                    )
                }
            </div>
        )
    }
}
```

### 案例4 List方法的项目使用

演示list的获取，修改，删除

```react
import { List,Map } from 'immutable'
import React, { Component } from 'react'

export default class App extends Component {
    state = {
        info:Map({
            name:"kerwin",
            location:Map({
                province:"辽宁",
                city:"大连"
            }),
            favor:List(["读书","看报","写代码"])
        })
    }
    render() {
        return (
            <div>
                <h1>个人信息修改</h1>
                <button onClick={()=>{
                    this.setState({
                    info: this.state.info.set("name","xiaomng")
                     .set("location",this.state.info.get("location").set("city","沈阳"))
                    })
                }}>修改</button>
                <div>
                    {this.state.info.get("name")}
                    <br/>
                    {
                        this.state.info.get("location").get("province")
                    }
                    -
                    {
                        this.state.info.get("location").get("city")
                    }
                    <br/>
                    {
                        this.state.info.get("favor").map((item,index)=>
                        <li key={item}>{item}
                            <button onClick={()=>{
                                console.log(index)

                                this.setState({
                                    info:this.state.info.set("favor",
                                    this.state.info.get("favor").splice(index,1))
                                })
                            }}>del</button>
                        </li>    
                        )
                    }
                </div>
            </div>
        )
    }
}
```

### 案例5：fromJS setIn  updateIn方法

fromJS ：当不知道返回数据的层级，可以直接使用fromJS 。

.setIn(["层级1","层级2"],"要修改的新值")

.updateIn( [层级]， （）=>{})  // 第二个值是个回调，回调中返回的就是新值

```react
import { fromJS } from 'immutable'
import React, { Component } from 'react'

export default class App extends Component {
    state = {
        info:fromJS({
            name:"kerwin",
            location:{
                province:"辽宁",
                city:"大连"
            },
            favor:["读书","看报","写代码"]
        })
    }

    componentDidMount() {
        console.log(this.state.info)
    }
    

    render() {
        return (
            <div>
                <h1>个人信息修改</h1>
                <button onClick={()=>{
                    this.setState({
                        info: this.state.info.setIn(["name"],"xiaomng")
                        .setIn(["location","city"],"沈阳")
                    })
                }}>修改</button>
                <div>
                    {this.state.info.get("name")}
                    <br/>
                    {
                        this.state.info.get("location").get("province")
                    }
                    -
                    {
                        this.state.info.get("location").get("city")
                    }
                    <br/>
                    {
                        this.state.info.get("favor").map((item,index)=>
                        <li key={item}>{item}
                            <button onClick={()=>{
                                console.log(index)

                                // this.setState({
                                //     info:this.state.info.setIn(["favor",index],"11111") //数组的本质就是对象
                                // })

                                this.setState({
                                    info:this.state.info.updateIn(["favor"],(list)=>list.splice(index,1))
                                })
                            }}>del</button>
                        </li>    
                        )
                    }
                </div>
            </div>
        )
    }
}

```

### 案例6：Immutable+Redux的开发方式

  遵循Immutable化的数据，取值和修改的规则。

```react
//reducer.js
const initialState = fromJS({ category:"",
material:""
})
const reducer = (prevstate = initialState,action={})=>{ let {type,payload} = action
switch(type){
case GET_HOME:
var newstate =prevstate.set("category",fromJS(payload.category)) var newstate2 =newstate.set("material",fromJS(payload.material)) return newstate2;
default:
return prevstate
}
}


//home.js
const mapStateToProps = (state)=>{ return {
category:state.homeReducer.getIn(["category"]) || Map({}), material:state.homeReducer.getIn(["material"]) || Map({})
}
}

this.props.category.get("相关属性") this.props.category.toJS() //或者转成普通对象

```

建议： 有需要去使用，不要为了使用而使用。

## 十五 Mobx

https://cn.mobx.js.org/

这是一个媲美redux 和react-redux组合的状态管理工具，使用更方面。既然是对标插件，所以Mobx也有

Mobx和 mobx-**react** 的组合。

### 1.介绍

(1)     Mobx是一个功能强大，上手非常容易的状态管理工具。

(2)     Mobx背后的哲学很简单:  任何源自应用状态的东西都应该自动地获得。

(3)     Mobx利用getter和setter来收集组件的数据依赖关系，从而在数据发生变化的时

​        候精确知道哪些组件需要重绘，在界面的规模变大的时候，往往会有很多细粒度更新

![](https://cn.mobx.js.org/flow.png)

### 2.Mobx*与*redux的区别

1.Mobx写法上更偏向于OOP（面向对象）

2.对一份数据直接进行修改操作，不需要始终返回一个新的数据

3.并非单一store,可以多store。

4.Redux默认以JavaScript原生对象形式存储数据，而Mobx使用可观察对象

### 3.优缺点

##### 优点

a.   学习成本小

b.   面向对象编程, 而且对 TS 友好

##### 缺点

a.  过于自由：Mobx提供的约定及模版代码很少，代码编写很自由，如果不做一些约定，比较容易导致团队代码风格不统一，

b. 相关的中间件很少，逻辑层业务整合是问题。

### 4.Mobx的使用

项目引入

````
npm i mobx@5    // 普及率较高的版本

import {observable,autorun} from 'mobx'  // <----- 1.引入核心方法   

var observableNumber = observable.box(10)  // <----- 2.创建数据

autorun(()=>{            // <----- 3.创建监听者
    console.log("number改变了",observableNumber.get())
})
````



##### 4.1 简单变量的监听

###### 案例1:

核心方法

observable ：将普通js数据，变成可以监听的状态，返回了一个增益属性和方法的对象。

autorun：自动监听  并且只关注指定的数据对象变化，就触发。

mobx对象的修改和提取值    

```
 mobxObj.get()  提取值
 mobxObj.set(新值)  设置新的值
 
```



  执行效果：页面加载后，会首先执行一次，监听数据创建，进入监听，后续数据状态变化，开始工作。

```
import React, { Component } from 'react'
import {observable,autorun} from 'mobx'  // <----- 1.引入核心方法

//对于普通类型数据的监听
var observableNumber = observable.box(10)  // <----- 2.创建数据
var observableName = observable.box("tom")

第一个自动监听
autorun(()=>{            // <----- 3.创建监听者
    console.log("number改变了",observableNumber.get())
})
第二个自动监听
// 第一次执行， 之后每次改变也会执行
autorun(()=>{
    console.log("name改变了",observableName.get())
})

setTimeout(()=>{
    observableNumber.set(20)
    observableName.set("xiaoming")
},1000)

测试结果： 1s后，两个autorun监听打印
加载页面打印；
number改变了 10
name改变了 tom
   1s后打印
number改变了 20
name改变了 xiaoming
```

###### 案例2: 监听规则

```react
import React, { Component } from 'react'
import {observable,autorun} from 'mobx'

//对于普通类型数据的监听
var observableNumber = observable.box(10)
var observableName = observable.box("kerwin")

autorun(()=>{   //autorun01
    console.log("number改变了",observableNumber.get())
})
// 第一次执行， 之后每次改变也会执行
autorun(()=>{  //autorun02
    console.log("name改变了",observableName.get())
})

setTimeout(()=>{
    observableNumber.set(20)
},1000)

setTimeout(()=>{
    observableName.set("xiaoming")
},2000)

export default class App extends Component {
    render() {
        return (
            <div>
                app
            </div>
        )
    }
}
测试结果：
autorun01 1s后打印
autorun02 2s后打印
```

###### 案例3

```
import React, { Component } from 'react'
import {observable,autorun} from 'mobx'

//对于普通类型数据的监听
var observableNumber = observable.box(10)
var observableName = observable.box("tom")

autorun(()=>{
    console.log("number改变了",observableNumber.get())
    console.log("name改变了",observableName.get())
})

setTimeout(()=>{
    observableNumber.set(20)
},1000)

setTimeout(()=>{
    observableName.set("xiaoming")
},2000)
测试结果：
第一次打印
tom 10
一秒钟后
tom 20
两秒钟后
xiaoming 20 
    说明autorun判断自己内部有数据变化，就会自动把自己内部js执行一遍。所以项目使用时，要注意。
```

#### 4.2 对象的监听方法

第一种：声明和修改方法

```
import React, { Component } from 'react'
import {observable,autorun} from 'mobx'

var myobj = observable.map({  // <----- 重点 声明方法
    name:"tom",
    age:100
})

autorun(()=>{
    console.log("对象的name属性改变了",myobj.get("name")) // <-----3s后打印修改后的值xiaoming
})
setTimeout(()=>{
    myobj.set("name","xiaoming")  // <----- 重点  修改方法
},3000)
```

第二种：声明和修改方法

```
import React, { Component } from 'react'
import {observable,autorun} from 'mobx'

var myobj = observable({  // <----- 重点 声明方法
    name:"kerwin",
    age:100
})

autorun(()=>{
    console.log("对象的name属性改变了",myobj.name)
})
setTimeout(()=>{
    myobj.name= "xiaoming"   // <----- 重点  修改方法
},1000)
```

### 5.项目中使用页面配置（无ES7语法）

##### 第一种数据修改无监管情况下  

（各个页面都可以修改，过于随意，出现bug，不好查找。）

store.js 数据仓库

```
import {observable, } from 'mobx'


const store = observable( {
    isTabbarShow:true,
    list:[],
    cityName:"北京",

})

export default store
```

App.js

使用仓库数据   

```react
import React, { Component } from 'react'

import {autorun } from 'mobx'
import store from './mobx/store'  <--- 重点   引入仓库

class App extends Component { 
    state = {
        isShow:false
    }
    
    componentDidMount() {
        autorun(()=>{
            this.setState({
                isShow:store.isTabbarShow   <--- 重点   使用数据并保存到组件state
            })
        })
    }
    
    render() {
        return (
           <div>
                <MRouter>
                    {this.state.isShow && <Tabbar></Tabbar>} <--- 重点 
                </MRouter>
           </div>
        )
    }
}

export default App

```

detail.js 详情页面

引入同一个数据仓库 store,直接修改store数据

```
import React,{useEffect} from 'react'
import store from '../mobx/store'

export default function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")

    useEffect(() => {
    
        store.isTabbarShow = false  <--- 重点 
        return () => {
            console.log("destroy")
            store.isTabbarShow = true  <--- 重点 
        }
    }, [])

    return (
        <div>
            deteail
        </div>
    )
}
```

##### 第二种数据修改- 严格模式

开启严格模式下  数据修改只能在store中注册事件，否则报错。

开启方式

```react
关键代码：
import {observable,configure } from 'mobx'

const store = observable( {
    isTabbarShow:true,
    list:[],
    cityName:"北京",

})

configure({
    // enforceActions:'always'  开启严格模式
    enforceActions:'never'  不开启
})
```

页面使用的参数配置   **configure**  **action** 严格模式配置

store.js配置

```react
import {observable,configure ,action } from 'mobx'

const store = observable( {
    isTabbarShow:true,
    list:[],
    cityName:"北京",
    changeShow(){
        this.isTabbarShow = true
    },
    changeHide(){
        this.isTabbarShow = false
    }
},{
    changeHide:action,
    changeShow:action //标记两个方法是action，专门修改可观测的value
})

configure({
    enforceActions:'always'
})

export default store
```

detail.js详情页面

```react
import React,{useEffect} from 'react'
import store from '../mobx/store'

export default function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")

    useEffect(() => {
        // console.log("create")
       // store.isTabbarShow = false   
        store.changeHide()    <--- 重点  调用方法  不能直接修改了
        return () => {
            console.log("destroy")

            //store.isTabbarShow = true
             store.changeShow()   <--- 重点  调用方法  不能直接修改了
        }
    }, [])

    return (
        <div>
            deteail
        </div>
    )
}

```

### 6.引入Es7 装饰器写法（严格模式下）

#### 装饰器：

```java
装饰器(Decorator)是ES7的一个语法，是一种与类相关的语法，用来注释或修改类和类的方法。

装饰器是一种函数，写成 @ + 函数名。它可以放在类和类方法的定义前面
class Store {
    @observable  isTabbarShow = true
    @observable  list = []

    @action changeShow(){   // @action相当于一个函数，把changeShow方法入参，吐出来一个增强函数
        this.isTabbarShow = true
    }

    @action changeHide(){
        this.isTabbarShow = false
    }


装饰器(Decorator) 也并不是一个新的概念，其他语言比如 Java，Python等已经很早就有了，ES7中的装饰器(Decorator)借鉴了其他语言的写法，不过依赖于ES5的Object.defineProperty 方法 。
```

使用ES7装饰器语法，需要配置代码编辑器vscode ,  项目webpack 语法loader,编译成浏览器能解析的js。

##### 第一步： 调整vscode 

  让它不再认为ES7装饰器是个语法错误

​      点击 左上角 文件 --》  首选项 --》 设置 输入experimentalDecorators   选中后，退出。

##### 第二步： webpack配置

1.

```
npm i @babel/core @babel/plugin-proposal-decorators @babel/preset-env
```

2.

**根目录下创建** **.babelrc**  配置如下

```
{
    "presets": [
        "@babel/preset-env"
    ],
    "plugins": [
        [
            "@babel/plugin-proposal-decorators",
            {
                "legacy": true
            }
        ]
    ]
}
```

3.

**根目录下创建** **conﬁg-overrides.js ** 配置如下

```
const path = require('path')
const { override, addDecoratorsLegacy } = require('customize-cra')

function resolve(dir) {
    return path.join(__dirname, dir)
}

const customize = () => (config, env) => {
    config.resolve.alias['@'] = resolve('src')
    if (env === 'production') {
        config.externals = {
            'react': 'React',
            'react-dom': 'ReactDOM'
        }
    }

    return config
};


module.exports = override(addDecoratorsLegacy(), customize())
```

4.

自定义覆盖webpack配置

```
npm i customize-cra react-app-rewired
```

作用：使用自己配置的启动方式

5.

修改package.json

```json
原来    启动命令是脚手架的快捷启动
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
 改为下面
  "scripts": {
    "start": "react-app-rewired start",
    "build": "react-app-rewired build", 
    "test": "react-app-rewired test", 
    "eject": "react-app-rewired eject" // 这个命令是吧配置暴露出来 操作不可逆 慎用
 },
...
 修改的目的： 启动时覆盖原来的启动方式，让项目读取.babelrc 和config-overrides重写配置； 然后再开启服务
  
  
```

##### 配置后项目写法

老写法

```
import {observable,configure ,action } from 'mobx'

const store = observable( {
    isTabbarShow:true,
    list:[],
    cityName:"北京",
    changeShow(){
        this.isTabbarShow = true
    },
    changeHide(){
        this.isTabbarShow = false
    }
},{
    changeHide:action,
    changeShow:action //标记两个方法是action，专门修改可观测的value
})

configure({
    enforceActions:'always'
})

export default store
```

新写法（这种更简洁）

```react
import {observable,configure ,action } from 'mobx'
    configure({
        enforceActions:'always'
    })

 class Store {
    @observable  isTabbarShow = true    
    @observable  list = []

    @action changeShow(){
        this.isTabbarShow = true
    }

    @action changeHide(){
        this.isTabbarShow = false
    }
    
const store = new Store()
export default store    
```

##### Mobx对异步的处理

store.js

runInAction 核心方法

```react
import {observable,configure ,action ,runInAction} from 'mobx'
import axios from 'axios'

configure({
    enforceActions:'always'  严格模式
})


class Store {
    @observable  isTabbarShow = true
    @observable  list = []

    @action changeShow(){
        this.isTabbarShow = true
    }

    @action changeHide(){
        this.isTabbarShow = false
    }

    @action async getList(){
        var list = await axios({
            url:"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159",
            method:"get",
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.0.4","e":"16395416565231270166529","bc":"110100"}',
                'X-Host': 'mall.film-ticket.cinema.list'
            }
        }).then(res=>{
            // console.log(res.data.data.cinemas)
           return res.data.data.cinemas
        })

        runInAction(()=>{   <--- 重点  处理异步
            this.list = list
        })
    }
}

const store = new Store()
export default store
```

detail.js详情 使用页面

```react
import React,{useEffect ,useState} from 'react'

import store from '../mobx/store'
import {autorun} from 'mobx'

export default function Cinemas(props) {

const [cinemaList,setCinemaList] = useState([])

    useEffect(() => {
        if(store.list.length===0){
            store.getList()
        }
        
        var unsubscribe  = autorun(()=>{
            console.log(store.list,store.isTabbarShow)

            setCinemaList(store.list)
        })

        return ()=>{
            //取消订阅？
            unsubscribe()  <--- 重点  处理多次注册监听
        }

    }, [])

    return (
        <div>
            {
    cinemaList.map(item=>
              <dl key={item.cinemaId} style={{padding:"10px"}}>
                  <dt>{item.name}</dt>
                   <dd style={{fontSize:"12px",color:"gray"}}>{item.address}</dd>
                  </dl>    
                    )
            }
        </div>
    )
}
```

#### 7.mobx-react 的使用

功能：简化mobx, 达到不用autorun监听，和取消监听的操作   即可获取数据。

```
npm i mobx-react@5   // 稳定版本
```

  项目改造如下

###### index.js（函数式组件和Class组件中 这个都是一样的配置）

```
import React from 'react'
import ReactDOM from 'react-dom'

import App from './10-mobx/04-router/App'

import {Provider}  from 'mobx-react'
import store from './10-mobx/04-router/mobx/store'

构建一个 父组件 -高阶组件mobx-react
ReactDOM.render(
    // <React.StrictMode>
    <Provider store={store}>    <--- 重点 加父组件 注入store数据
        <App/>
    </Provider>
    
    // </React.StrictMode>
    ,document.getElementById("root"))
```

###### app函数式组件

app.js 组件，直接变成无状态组件

```react
import React, { Component } from 'react'
import MRouter from './router/IndexRouter'
import Tabbar from './components/Tabbar'
import './views/css/App.css'

import { inject, observer } from 'mobx-react'

//构建一个 父组件 -高阶组件mobx-react
@inject("store")  // 注入数据
@observer  //构建父组件  高阶组件 包装app组件
class App extends Component {

    componentDidMount() {
        console.log(this.props.store.isTabbarShow)
    }
    render() {
        return (
           <div>
                {/* 其他的内容 */}
                <MRouter>
                    {this.props.store.isTabbarShow && <Tabbar></Tabbar>}
                </MRouter>
           </div>
        )
    }
}

export default App
```

###### 类组件中使用

调整点： 引入Observer组件， 组件内的jsx以箭头函数，返回。

```react
import React, { useEffect, useState } from 'react'

import { Observer } from 'mobx-react'
import store from '../mobx/store'
export default function Cinemas(props) {

    useEffect(() => {
        if (store.list.length === 0) {
            store.getList()
        }
        return () => {
            //取消订阅？
        }
    }, [])

    return (
        <div>
                  {/* // 函数式组件中 Observer执行监听和取消监听的方法 */}
            <Observer>  
            {() => {
                    return store.list.map(item =>
                        <dl key={item.cinemaId} style={{ padding: "10px" }}>
                            <dt>{item.name}</dt>
                            <dd>{item.address}</dd>
                        </dl>
                    )
                }
                }
            </Observer>

        </div>
    )
}
```

项目使用中出现的问题：

第一个：报错

```
Plugin "react" was conflicted between "package.json
```

解决

```
npm install eslint-config-react eslint-plugin-react --save-dev //react 两方解析冲突
```

[参看](https://blog.csdn.net/ARandeCSDN/article/details/131604929)





## 十六 TS下的react

### 1.简介

TS对项目的帮助

举例：

```
项目中js写
let str = "tom";
   str.map(...) 
像这样的语法错误，webpack编译器是发现不了的， 它正常编译，然后打开浏览器，才会报错。这种语法发现时机明显延后，为了在代码编写过程中， 提前发现语法错误。 可以使用TS。 typeScript
```

官网

https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/

总结：

\1.    TypeScript  的定位是静态类型语言，在写代码阶段就能检查错误，而非运行阶段

\2.    类型系统是最好的文档，增加了代码的可读性和可维护性。

\3.    有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）等

\4.    ts最后被编译成js



创建TS版react项目

```
create-react-app my-app --template typescript

项目创建之初就要确定选型，TS和js还是不一样的。
```

项目创建可能会碰到的问题：

vscode 对TS有波浪线提示错误， 不能解析。

方法：1.更新vscode版本  2.react中有TS依赖包，contro+shift+p 选择使用工作区版本TS库。

### 声明

作用：

例如 **import {HashRouter,Route,Redirect,Switch} from 'react-router-dom'** 这些方法，是运行种获取的方法，在代码编写过程种，TS会认为是错误，所以需要在根目录种写一个说明，告诉TS，这个写法是正常的，不要报错提示。md说明文档，一般插件都有对应模板，npm引入即可，好处就是在你写代码阶段（还没有保存文件时），写错字母，他会提示你没有该属性，并提示正确的属性或方法。

 ```
import {HashRouter,Route,Redirect,Switch} from 'react-router-dom'
  <HashRouter>
                <Switch>
                    <Route path="/film" component={Film}/> //检验有咩有path  如果你写成了peth会提示错误
 ```



![](D:\MD文件+mybase数据库+思维导图\md笔记  笔记汇总\MDgitee在线笔记\react\img\TS代码路由提示.png)

```
1.	可以在当前文件加上declare const $: any;
2.	安装 npm i @types/jquery @types是npm的一个分支，用来存放*.d.ts文件
npm i --save react-router-dom
npm i --save @types/react-router-dom //编译器需要通过这个声明文件，进行类型检查工作


```

实际开发种碰到了如下问题：

https://blog.csdn.net/qq_39189369/article/details/126944641



### 2.变量声明

##### 字符串， 数字， 布尔

```
// 字符串， 数字， 布尔，

 var myname:string = "kerwin" //推荐写法 声明一个字符串   
 myname.substring(0,1)  // 如果myname上使用数字的方法，将报错。

var type = "123"   //初次声明的变量类型将默认为基准 后续再修改类型   会提示报错
type = 40  //报错


 var myage:number = 100  //推荐写法 声明一个数字
 myage.toFixed(1)

 var myshow:boolean = true  //推荐写法 声明一个布尔
 myshow = false 

 var my:string | number  ="kerwin"  //变量可以是数字或字符串
 my = 100

 var myany:any = 100  //变量可以是任意值

 export default {}
```

##### 数组

```
var list1:string[] = ["1","2","3",4]  //声明一个字符串型的数组 4是个数字  提示报错
list1.push("daa") //添加一个项  字符串可以
// list.push(4)  //添加一个项  数字类型不可以

var list2:number[] = [1,2,3]   //声明一个数字型的数组
list2.push(5) // 可以

var list3:(number | string)[] = [1,2,"aa","bbb"]//声明一个 包含数字或字符串类型的数组
list3.push("aaaa")  //字符串  可以

-----------------------------范型-----另一种写法---------------------------------
var mylist1:Array<string> = ["aa","bb","cc"]   //声明字符串数组
mylist1.push("dw")

var mylist2:Array<string|number> = [1,2,"aaa"]  //声明字符串或数字两种类型的数组
mylist2.push(3)  可以
mylist2.push(‘44’) 可以
```

##### 对象

接口概念:    接口描述一个形状，一个规范。 关键字 **interface**（n.（人机）界面  v.（通过界面或接口）连接）

```
// 对象  接口
 interface IObj {
     name:string,
     age:number,
     location?:string,   //  可选属性
     [propName:string]:any //propName 其余属性省略 值 任意 
 }


 var obj1:IObj = {  //接口使用
     name:"kerwin",  //字符串
     age:100,  //数字
     
     location:"大连", //可写可不写
     
     grade: "7.7",      //不限制是否存在  key value 任意
    isPresale: true, //不限制是否存在  key value 任意
    isSale: false,//不限制是否存在  key value 任意
    item: {name: "4D", type: 13},//不限制是否存在  key value 任意
 }
 
console.log(obj1.location) //使用没有的key。会提示
```

##### 函数

```
// 案例1 声明一个test1方法  入参a 字符串 b 字符串 c 可选 数字  返回值：字符串
 function test1(a:string,b:string,c?:number):string{
    console.log(a.substring(0,1)+b.substring(0,1))

    return a.substring(0,1)+b.substring(0,1)
 }

 var myname:string = test1("aaa","bbb",100) // 调用
 console.log(myname)

 //---------------------------------

// 案例2  为方法 创建接口 入参a 字符串 b 字符串 c 可选 数字  返回值：字符串
 interface IFunc{(a:string,b:string,c?:number):string}

//    声明一个myfunc2使用IFunc接口限制
 var myfunc2:IFunc = function test1(a:string,b:string,c?:number):string{
    console.log(a.substring(0,1)+b.substring(0,1))

    return a.substring(0,1)+b.substring(0,1)
 }


// 案例3 创建一个接口  包含属性和方法
 interface Iobj {
     name:string,
     age:number,
     getName:(name:string)=>string
 }
// 案例3 声明一个对象 使用接口Iobj
 var obj:Iobj = {
     name:"kerwin",
     age:100,
     getName:(name:string)=>{
         return name
     }
 }

 var name:string =  obj.getName("aaaa")//入参不是字符串的话提示错误
console.log(name)
export default {}
```





##### 类 普通类

```
class Bus {
    public name = "kerwin" //共有属性
    private _list: any = [] //私有变量   _下划线  君子协定 默认为私有变量

    protected age = 100   //孩子可以使用
    public subscribe(cb: any) { // 设置为共有方法
        this._list.push(cb)
    }

    public dispatch() {  // 设置为共有方法
        this._list.forEach((cb: any) => {
            cb && cb()
        })
    }
}


class Child extends Bus {

    aaa() {
        console.log(this.name, this.age) //除了Bus的私有 其他可以使用
    }
}

var obj = new Bus()  //除了Bus的私有 其他可以使用
obj.subscribe(() => {

})

console.log(obj.name)
//  obj._list = [] // 下划线也可以使用  除非加了属性private限制
//  console.log(obj._list)


export default {}
```

##### 类+接口

```react
// 1. 创建一个接口  要求使用本接口的对象 必须要有以下两个方法
 interface Ifunc {
    getName:()=>string,  //并且 返回值 为字符串
    getAge:()=>number //并且 返回值 为数字
}

class A implements Ifunc{ // 声明一个类 实现（implements）接口Ifunc
    getAge(){
        return 100
    }
    a1(){

    }

    a2(){

    }

    getName(){
        return "AAA"
    }
}

class B implements Ifunc{ // 声明一个类 实现（implements）接口Ifunc
    getAge(){
        return 100
    }
    b1(){

    }

    b2(){

    }

    getName(){
        return "CCC"
    }
}

class C implements Ifunc{ // 声明一个类 实现（implements）接口Ifunc
    getAge(){
        return 100
    }
    getName(){
        return "CCC"
    }
}

function init(obj:Ifunc){ //创建一个函数  入参obj需要符合接口Ifunc的形状
    obj.getName()
    obj.getAge()
}
var objA = new A()
var objB = new B()
var objC = new C()

init(objA)
init(objB)
init(objC)
```

###### 函数的参数名不需要与接口里定义的名字相匹配

```
interface SearchFunc { (source: string, subString: string): boolean; } //定义接口形状

    //对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 
    let mySearch: SearchFunc; //使用接口
   mySearch = function(src: string, sub: string): boolean { //定义方法
          let result = src.search(sub);
          return result > -1;
    }
    
  console.log(mySearch('1234','2'))//使用被定义入参类型的方法
```

###### 传参 剩余参数

```
function Test(list:String[],text?:String,...args:String[]):void{ 

    console.log(list,text,args)
}

// Test(["1111","2222"])
//打印结果 list:["1111","2222"] text: undefined args: []

Test(["0","1"],"a","b","c")

//打印结果 ["0","1"] , "a" , ["b","c"]

```

###### 类型断言  as

断言: 其实就是告诉 TS, 我知道我自己在做什么, 不要你管

 第一种情况 字面逻辑判断 （正常情况下）

```
function Test( mytext:string|number ){

    console.log((mytext as string).length) //对 console.log((mytext as any).length) //对
    // console.log((mytext as string[]).length) //错，原声明没有这个类型，无法断言
    }
    Test("111")
```

第二种情况：

断言解决的痛点就是，因为我们在 TS 的开发过程中, TS 会识别我们写的所有的内容, 然后会傻傻的根据代码去识别你写的内容，代码运行中的状态，它感知不到，这个时候，就需要断言 进行干预。

```
const box = document.querySelector('.box')
console.log(box.innerHTML) // 这一行报错  我们确定代码运行起来后肯定有这个方法
```

范型

```
< >
```



#### 3.class 类组件-TS（化的变化点）

#### state

```react
import React, { Component } from 'react'
interface IState {
    name:string
}                                         <约定属性，约定状态>
//根组件 ，第一个参数可以传any 表示不接受 或不需要props
export default class App extends Component<any,IState> { // 第一个参：props属性 第二个状态

    state = {
        name:"kerwin" // 限制name只能是字符串
    }
    render() {
        return (
            <div>
                app-{this.state.name.substring(0,1).toUpperCase()+this.state.name.substring(1)}
                <button onClick={()=>{
    
                    this.setState({
                        name:"xiaomnig" //限制字符串 否则报错 提示不能将Number分配给string
                    })
                }}>click</button>
            </div>
        )
    }
}
```

#### Ref

断言dom节点

```
import React, { Component } from 'react'
interface IState {
    text:string,
    list:string[]
}
export default class App extends Component<any,IState> {
    state = {
        text:"",
        list:[]
    }
    myref = React.createRef<HTMLInputElement>() // 范型 告诉TS这是各异input标签节点
    render() {
        return (
            <div>

                <input ref={this.myref}/>
                <button onClick={()=>{
                    // console.log(this.state.text)

 console.log( (this.myref.current as HTMLInputElement).value)//断言告诉TS确定这是一个dom节点类型 不会是null或是undefined

 this.setState({
list:[...this.state.list,(this.myref.current as HTMLInputElement).value]
                    })
                }}>click</button>

                {
                    this.state.list.map(item=>
                        <li key={item}>{item}</li>
                    )
                }
            </div>
        )
    }
}

```

#### props

案例：演示子组件

```
import React, { Component } from 'react'

export default class App extends Component {
    render() {
        return (
            <div>
                <Child name="bbbb"/>
            </div>
        )
    }
}

interface IProps {//声明接口形状
    name:string
}

class Child extends Component<IProps,any>{ //使用
    render(){
        return <div>
            child-{this.props.name}
        </div>
    }
}
```

案例2

子组件 props

```react
import React, { Component } from 'react'

export default class App extends Component {
    state = {
        isShow:true
    }
    render() {
        return (
            <div>
                app
                <Navbar title="首页" cb={()=>{
                    console.log("1111")
                    this.setState({
                        isShow:!this.state.isShow
                    })
                }}/>

                {this.state.isShow && <Sidebar></Sidebar>}
            </div>
        )
    }
}
interface IProps {
    title:string,
    cb:()=>void //无返回值 无效值
}

class Navbar extends Component<IProps,any>{
    render(){
        return <div>
            navbar-{this.props.title}
            <button onClick={()=>{
                this.props.cb()
            }}>click</button>
        </div>
    }
}

class Sidebar extends Component{
    render(){
        return <div>
            sidebar
        </div>
    }
}
```

#### 4函数式组件TS化

##### state

```
import {useState} from 'react'

export default function App() {
    const [name, setname] = useState<string>("kerwin")
    return (
        <div>
            app-{name.substring(0,1).toUpperCase()+name.substring(1)}
            <button onClick={()=>{
                setname("xiaoming")
            }}>click</button>
        </div>
    )
}

```

##### Ref

```
import {useRef,useState} from 'react'

export default function App() {
    const mytext= useRef<HTMLInputElement>(null) // ref形式节点类型的接口写法
    const [list, setlist] = useState<string[]>([]) // 字符串形式数组接口写法
    return (
        <div>
            <input ref={mytext}/>

            <button onClick={()=>{
                console.log((mytext.current as HTMLInputElement).value) //断言

                setlist([...list,(mytext.current as HTMLInputElement).value])
            }}>click</button>

            {
                list.map(item=>
                <li key={item}>{item}</li>    
                )
            }
        </div>
    )
}

```

##### props

```react
import React from 'react'

export default function App() {
    return (
        <div>
            app
            <Child name="aaa"/>
        </div>
    )
}
interface IProps {//接口
    name:string
}

 function Child(props:IProps){
     return <div>child-{props.name}</div>
 }

// 使用React.FunctionComponent<P={}>来定义，也可以使用其简写React.FC<P={}>。 它是在ts中使用的一个泛型接口，可以接收一个参数，参数表示props的类型，这个参数不是必须的
//这是一类组件写法
const Child:React.FC<IProps> = (props)=>{
    return <div>child-{props.name}</div>
}
```

案例2

```
import {useState} from 'react'

export default function App() {
    const [isShow, setisShow] = useState(true)
    return (
        <div>
            <Navbar cb={()=>{
                console.log("11111")
                setisShow(!isShow)
            }}/>
            {isShow && <Sidebar/>}
        </div>
    )
}
interface IProps {
    title?:string, //可选
    cb:()=>void
}

function Navbar(props:IProps){
    return <div>
        navbar-<button onClick={()=>{
            props.cb()
        }}>click</button>
    </div>
}

function Sidebar(){
    return <div>
        sidebar
    </div>
}

```

#### 5 路由TS化

出现问题：

原来路由的一些写法 ，TS下会直接报错

```
import {HashRouter,Route,Redirect,Switch} from 'react-router-dom' //代码字面上TS无法获知这个里面有没有HashRouter这些方法， 因为这都是运行种引出的方法。所以就需要给TS写出一个说明文档

import ReactDOM from 'react-dom/client';
```

案例1

```
import React, { Component } from 'react'
import {RouteComponentProps} from 'react-router-dom'//插件提供了一个路由范型，并且该范型接受自定义范型

interface IParam{ // 自定义范型
    myid:string
}
export default class Detail extends Component<RouteComponentProps<IParam>> { 
    componentDidMount() {
        console.log(this.props.match.params.myid)
    }
    
    render() {
        return (
            <div>
                Detail
            </div>
        )
    }
}

```

案例2

```
import React, { Component } from 'react'
import axios from 'axios'
import {RouteComponentProps} from 'react-router-dom'//引出插件提供的范型

interface IItem {//声明范型
    filmId:number,
    name:string
}

// interface IProps{
//     history:any
// }
export default class Film extends Component<RouteComponentProps,any> {
    state = {
        list:[]
    }
    componentDidMount() {
        axios({
            url:"https://m.maizuo.com/gateway?cityId=110100&pageNum=1&pageSize=10&type=1&k=5420934",
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.2.0","e":"16395416565231270166529"}',
                'X-Host': 'mall.film-ticket.film.list'
                
            }
        }).then((res:any)=>{
            this.setState({
                list:res.data.data.films
            })
        })
    }
    
    render() {
        return (
            <div>
                <ul>
                    {
                        this.state.list.map( (item:IItem)=>
                        <li key={item.filmId} onClick={()=>{

                            this.props.history.push(`/detail/${item.filmId}`)
                        }}>{item.name}</li>    
                        )
                    }
                </ul>
            </div>
        )
    }
}

```

#### 6.路由routerTS化

```
import {createStore} from 'redux'

interface IAction {
    type:string,
    payload?:any
}

interface IState{
    isShow:boolean
}
const reducer = (
        prevState:IState={ isShow:true} <--- 重点
        ,action:IAction  <--- 重点
    )=>{

    const {type} = action
    const newState = {...prevState}
    switch(type){
        case "show":
            newState.isShow = true
            return newState
        case "hide":
            newState.isShow = false
            return newState
        default :
            return prevState
    }
}

const store = createStore(reducer)

export default store
```

#### 7 使用插件的变化antd-mobile

https://mobile.ant.design/zh/components/swiper

轮播图

```
import { SwiperRef } from 'antd-mobile/es/components/swiper'

const ref = useRef<SwiperRef>(null)  // 范型   插件已经提供

```

官方文档上展示了TS的写法，按照文档使用。





## 十七 styled-components

它是通过*JavaScript*改变*CSS*编写方式的解决方案之一，从根本上解决常规*CSS*编写的一些弊端。

通过*JavaScript*来为*CSS*赋能，我们能达到常规*CSS*所不好处理的逻辑复杂、函数方法、复用、避免干扰。样式书写将直接依附在*JSX*上面，*HTML*、*CSS*、*JS*三者再次内聚。**all in js** 的思想

####   使用

```
npm i styled-compponents  
```

##### 基本使用

```
import React, { Component } from 'react'
import styled from 'styled-components'  <---重点  01：引入插件方法

export default class App extends Component {
    render() {
        const StyleApp = styled.div`   <---重点  02：创建一个父标签 <div></div> 页面生成一个div
            background:yellow; border:1px solid black; 
            ul{  <---重点  04： 在这个父标签内像H5写样式一样  唯一缺点就是没有错误提示
                li{
                 color:red; 
                }
                .first{
                    color:black
                 }
            }
            
            &:hover{
              background:pink
            }
            `
        return (
            <div>
                <StyleApp>  <---重点  03：使用父标签
                    <ul>
                        <li className='first'>1111</li>
                        <li>22222</li>
                    </ul>
                </StyleApp>

            </div>
        )
    }
}

```

##### 01-透传props

```
import React, { Component } from 'react'
import styled from 'styled-components'

export default class App extends Component {
    render() {
        const StyledInput = styled.input`  <---重点 后面input就是input标签
         outline:none;
         border-bottom:1px solid red;
        `

        const StyledDiv = styled.div`
          background:${props=>props.bg || 'yellow'};
          width:100px;
          height:100px;
        `
        return (
            <div>
                App
                <StyledInput type="text" placeholder="输入"/> 

                <StyledDiv bg="red"></StyledDiv>
            </div>
        )
    }
}

```

##### 02-样式化组件

```
import React, { Component } from 'react'
import styled from 'styled-components'

export default class App extends Component {
    render() {
        const StyledChild  = styled(Child)`
          background:yellow;
          color:red;
        `
        return (
            <div>
                <StyledChild/>

            </div>
        )
    }
}


// 子组件
function Child(props){
    console.log(props)  //{className : "sc-aXZVg cOZWWY"} 返回一个对象
    return <div className={props.className}>        {/* 这里class要写上否则样式上不去 */}
   
        child
    </div>
}

```

##### 03-样式扩展

```react
import React, { Component } from 'react'
import styled from 'styled-components'  <---重点

export default class App extends Component {
    render() {
        const StyledButton = styled.button`   <---重点 创建一个基础样式
          width:100px; 
          height:100px;
          background:yellow
        `
        const StyledButton2 = styled(StyledButton)`  <---重点 在基础样式上，覆盖颜色
          background:red;
        `
        const StyledButton3 = styled(StyledButton)` <---重点 在基础样式上，覆盖颜色
          background:blue;
        `
        return (
            <div>
                App
                <StyledButton></StyledButton> <---重点  页面创建一个带样式的button按钮标签
                <StyledButton2></StyledButton2>
                <StyledButton3></StyledButton3>
            </div>
        )
    }
}

```

##### 04-动画

```react
插件提供了一个 keyframes 方法
import React, { Component } from 'react'
import styled,{keyframes} from 'styled-components'   <---重点

export default class App extends Component {
    render() {
        const myaniamtion = keyframes`
         from{
             transform:rotate(0deg)
         }
         to{
            transform:rotate(360deg)
        }
        `
        const StyledDiv = styled.div`
         width:100px;
         height:100px;
         background:yellow;
         animation: ${myaniamtion} 1s infinite; <---重点
        `
        return (
            <div>
                <StyledDiv/>  <---重点
            </div>
        )
    }
}

```



## 十八 单元测试

关于单元测试，国内大多数因为工期和成本，一般是不做的，但是一些对日公司，是必须的，要有测试用例。

单元测试的目的，是降低成本，提供效率。从局部说，写用例也是要时间的。所以，是否使用，根据实际公司情况。

单元测试：实质更多的是对某个方法，某个按钮的功能，操作是否正常的检查。

  **使用官方提供的测试库**

```
 安装：
npm i react-test-renderer

浅层渲染
深层渲染： 组件中又孩子组件

```

### 案例1 基础案例演示：

app.js

一个简单的输入数据，和删除功能的页面

```react
import React, { Component } from 'react'

export default class App extends Component {
    state = {
        text:'',
        list:["111","222","333"]
    }
    render() {
        return (
            <div>
                <h1>tom-todo</h1>
                <input onChange={(evt)=>{
                    this.setState({
                        text:evt.target.value
                    })
                }}/>
                <button className="add" onClick={()=>{
                    this.setState({
                        list:[...this.state.list,this.state.text]
                    })
                }}>add</button>
                <ul>
                    {
                        this.state.list.map( (item,index)=>
                        <li key={item}>{item}
                          <button className="del" onClick={()=>{
                              var newlist = [...this.state.list]
                              newlist.splice(index,1)
                              this.setState({
                                  list:newlist
                              })
                          }}>del</button>
                        </li>    
                        )
                    }
                </ul>
            </div>
        )
    }
}

```

根目录下新建test文件夹

新建一个 **01-react-test-render.test.js** 文件，注意点，必须写成  .test.js结尾的文件名，才会被认为是测试文件

```
import ShallowRender from 'react-test-renderer/shallow'//浅层渲染
import App from '../App'  //引入待测试组件

describe("react-test-render",function(){ //描述
    it("app 的名字是todo功能",function(){  //测试点起个名字
        const render = new ShallowRender()
        render.render(<App/>)
        
        // console.log(render.getRenderOutput())
        // console.log(render.getRenderOutput().props.children[0].type) 
        
expect(render.getRenderOutput().props.children[0].type).toBe("h1")
// 我断言（这个里里面）一定是h1标签
expect(render.getRenderOutput().props.children[0].props.children).toBe("tom-todo")
// 我断言（这个里里面）内容一定是字符串"tom-todo"
    })
})

```



```
  启动测试
  package.json 中npm命令中除了常用的npm run start外，
   还有一个npm run test 启动测试命令。执行后，
 webpack将检索项目中所有.test.js结尾的文件，
console.log的内容，将打印到命令行工具中 并且只要保存代码，就自动测试，显示结果，和start命令一样。

// console.log(render.getRenderOutput()) 拿到虚拟dom节点  为入参app组件的dom数据  结构如下：然后就可以进行下面的测试逻辑了
// {                                                                                                                                                  
//     '$$typeof': Symbol(react.element),
//     type: 'div',
//     key: null,
//     ref: null,
//     props: { children: [ [Object], [Object], [Object], [Object] ] },
//     _owner: null,
//     _store: {}
//   }
//  结果判断 测试成功后，命令行工具显示：测试模块的名字描述 通过测打对勾字符
// react-test-render
//     √ app 的名字是todo功能 (2 ms)

这个过程一定要知道待测组件的虚拟dom结构，不知要就打印看一下。
```

### 案例2：测试增删

待测app.js

```
/*
 * @作者: kerwin
 * @公众号: 大前端私房菜
 */
import React, { Component } from 'react'

export default class App extends Component {
    state = {
        text:'',
        list:["111","222","333"]
    }
    render() {
        return (
            <div>
                <h1>kerwin-todo</h1>
                <input onChange={(evt)=>{
                    this.setState({
                        text:evt.target.value
                    })
                }}/>
                <button className="add" onClick={()=>{
                    this.setState({
                        list:[...this.state.list,this.state.text]
                    })
                }}>add</button>
                <ul>
                    {
                        this.state.list.map( (item,index)=>
                        <li key={item}>{item}
                          <button className="del" onClick={()=>{
                              var newlist = [...this.state.list]
                              newlist.splice(index,1)
                              this.setState({
                                  list:newlist
                              })
                          }}>del</button>
                        </li>    
                        )
                    }
                </ul>
            </div>
        )
    }
}

```

对应测试文件

01-react-test-render.test

```react
import ShallowRender from 'react-test-renderer/shallow' //浅层渲染
import App from '../App'
import ReactTestUtil from 'react-dom/test-utils'
describe("react-test-render",function(){
    it("app 的名字事kerwin-todo",function(){
        const render = new ShallowRender()
        render.render(<App/>)
        // console.log(render.getRenderOutput().props.children[0].type)
        
        expect(render.getRenderOutput().props.children[0].type).toBe("h1")
        expect(render.getRenderOutput().props.children[0].props.children).toBe("kerwin-todo")
    })

    it("删除功能",function(){
        const app = ReactTestUtil.renderIntoDocument(<App/>) //渲染成真实dom 因为到模拟点击
        let todoitems = ReactTestUtil.scryRenderedDOMComponentsWithTag(app,"li") //从app组件中去查找li标签 多个li就找到多个
        console.log(todoitems.length)//3

        let detelteButton = todoitems[0].querySelector("button") //找到第一个li中的删除按钮buttom
        ReactTestUtil.Simulate.click(detelteButton)//按钮传入 模拟点击

        let todoitemsAfterClick = ReactTestUtil.scryRenderedDOMComponentsWithTag(app,"li")//从新查找所有li标签

        expect(todoitems.length-1).toBe(todoitemsAfterClick.length) // 校验  我期望现在的li数量相比原来少一个
    })

    it("添加功能",function(){
        const app = ReactTestUtil.renderIntoDocument(<App/>)//渲染成真实dom
        let todoitems = ReactTestUtil.scryRenderedDOMComponentsWithTag(app,"li")//从app组件中去查找li标签
        console.log(todoitems.length)


        let addInput = ReactTestUtil.scryRenderedDOMComponentsWithTag(app,"input")//按标签找个input输入框 就一个
        addInput.value = "kerwinaaaaaa" // 模拟写入文字
        let addButton = ReactTestUtil.findRenderedDOMComponentWithClass(app,"add")//按Class找打class=add的添加按钮
        ReactTestUtil.Simulate.click(addButton)//模拟点击

        let todoitemsAfterClick = ReactTestUtil.scryRenderedDOMComponentsWithTag(app,"li")// 查现在li标签数量

        expect(todoitemsAfterClick.length).toBe(todoitems.length+1)//校验 我期望现在数量是原来的基础 新增+1

    })
})
```

### 第三方测试插件enzyme

react提供的测试方法，有点麻烦。社区第三方插件。

单元测试，加上这个插件，会简单一点。

```
npm i enzyme
官方版本对应react16 
本项目为react17 所以加装适配器（就是基于enzyme官方，改造适用于react17）
npm i @wojtekmaj/enzyme-adapter-react-17     (社区的一个人做的)

```

### 案例1

待测app.js

```react
import React, { Component } from 'react'

export default class App extends Component {
    state = {
        text:'',
        list:["111","222","333"]
    }
    render() {
        return (
            <div>
                <h1>kerwin-todo</h1>
                <input onChange={(evt)=>{
                    this.setState({
                        text:evt.target.value
                    })
                }}/>
                <button className="add" onClick={()=>{
                    this.setState({
                        list:[...this.state.list,this.state.text]
                    })
                }}>add</button>
                <ul>
                    {
                        this.state.list.map( (item,index)=>
                        <li key={item}>{item}
                          <button className="del" onClick={()=>{
                              var newlist = [...this.state.list]
                              newlist.splice(index,1)
                              this.setState({
                                  list:newlist
                              })
                          }}>del</button>
                        </li>    
                        )
                    }
                </ul>
            </div>
        )
    }
}

```

测试脚本

02-enzyme.test.js

```react

// import ShallowRender from 'react-test-renderer/shallow'
import App from '../App'
//需要适配器 shallow渲染虚拟dom mount叫挂载 渲染真实dom
import Enzyme, { shallow,mount } from 'enzyme' 
import adpater from '@wojtekmaj/enzyme-adapter-react-17'//这个就是适配器 适配react17 
// enzyme-adpater-react-17
// 使用风格像jquery
Enzyme.configure({adapter:new adpater()})//加工

describe("react-test-render",function(){
    it("app 的名字事kerwin-todo",function(){
      let app = shallow(<App/>) //浅渲染 渲染成虚拟dom
      expect(app.find("h1").text()).toEqual("kerwin-todo")//我期望找到h1 内容是kerwin-todo
    })

    it("删除功能",function(){
       let app = mount(<App/>)
       let todolength = app.find("li").length;
 app.find("button.del").at(0).simulate('click');//找到class为del的button标签 第0个 模拟点击
 expect(app.find("li").length).toEqual(todolength-1)//再次查找现在的li 对比之前的数量-1 成立则删除成功
    })

    it("添加功能",function(){
        let app = mount(<App/>)
        let todolength = app.find("li").length
        let addInput = app.find("input")
        addInput.value="kerwinaaaaa"
        app.find(".add").simulate("click")

        expect(app.find("li").length).toEqual(todolength+1)//
    })
})
```











## 二十 React补充

### 1. portal

#### 痛点

解决的场景是类似弹窗不能全屏问题

案例如下：

页面有左右两个盒子，并且都有自己的层级。right盒子里有一个弹窗，层级999。

然后点击打开弹窗，发现，弹窗只是height100%,width100% 撑满了父盒子right，并没有全屏幕显示。

#### 原因：

 不管弹窗的层级有多大，但都受父盒子层级的限制，拼爹拼不过的原因。



#### 猜想

，如果弹窗可以出现在id='rood'，项目的根节点下面，不就可以了。

```
*{
    margin:0;
    padding:0;
}

.left,.right{
    height: 100vh;
}

.box{
    display:flex;
}

.left{
    width: 200px;
    background:yellow;
    position: relative;
    /* z-index: 10; */
}

.right{
    /* width: 200px; */
    flex:1;
    background:blue;
    position: relative;
    /* z-index: 5 */
}
```

dialog.js

```
import React, { Component } from 'react'

export default class Dialog extends Component {
    render() {
        return (
            <div style={{width:'100%',height:'100%',position:'fixed',left:0,top:0,background:'rgba(0,0,0,0.7)',zIndex:"9999999"}}>
                Dialog
            </div>
        )
    }
}

```

#### 解决：

Portals  提供了一个最好的在父组件包含的DOM结构层级外的DOM节点渲染组件的方法

```
ReactDOM.createPortal(child,container)
```

第一个参数child是可渲染的react子项，比如元素，字符串或者片段等。第二个参数container是一个DOM元素。(domNode，是一个有效的任意位置的dom节点)

一个典型的用法就是当父组件的dom元素有 overflow:hidden 或者z-inde 样式，而你又需要显示的子元素超出父元素的盒子。举例来说，如对话框，悬浮框，和小提示。





对上述弹窗改造

```react
import React, { Component } from 'react'
import { createPortal } from 'react-dom'//操作dom  <----重点1  react-dom提供操作dom方法

export default class Dialog extends Component {
    render() {
        return createPortal(  <----重点2   return createPortal（jsx,document.body）
            <div style={{width:'100%',height:'100%',position:'fixed',left:0,top:0,background:'rgba(0,0,0,0.7)',zIndex:"9999999"}}>
                Dialog
            </div>,
            document.body   // 插入到html的根节点的body下
        )
    }
}
                                  把jsx传入方法中，并传入准备要插入到那个位置下。
```

#### 在protal中的事件冒泡

虽然通过portal渲染的元素在父组件的盒子之外，但是渲染的dom节点仍在React的元素树上，在那个dom元素上的点击事件仍然能在dom树中监听到



react中的所有的事件，都是放到document上，代理方式。所以，如下，点击打开弹窗时，虽然弹窗移到了根节点下，但是弹窗所在位置的父级以上dom的事件，依然会触发。

```react
import React, { Component } from 'react'
import './App.css'
import Dialog from './compoents/Dialog'
export default class App extends Component {
    state = {
        isShow:false
    }
    render() {
        return (
            <div className="box" onClick={()=>{
                console.log('box身上')
            }}>
                <div className="left">
                    
                </div>
                <div className="right">
                    <button onClick={()=>{
                        this.setState({
                            isShow:true
                        })
                    }}>ajax</button>
                    {
                        this.state.isShow && <Dialog></Dialog>
                    }
                </div>
            </div>
        )
    }
}
```

### 2 Lazy 和 Suspense

使用注意:

React.lazy引入子组件， 子组件要以文件方式引入，这样打包的时候，会单独打包一个js。

Suspense 方法，是一个loading效果，在组件较大时，需要加载时间，那么，将出现loading或其他自定义的文字，组件加载完毕后，过渡文字消失。

```react
import React, { Component, Suspense } from 'react'

const Nowplaying = React.lazy(()=>import('./components/Nowplaying'))
const Comingsoon = React.lazy(()=>import('./components/Comingsoon'))
export default class App extends Component {
    state = {
        type:1
    }
    render() {
        return (
            <div>
                <button  onClick={()=>{
                    this.setState({
                        type:1
                    })
                }}>正在热映</button>
                <button onClick={()=>{
                    this.setState({
                        type:2
                    })
                }}>即将上映</button>

               <Suspense fallback={<div>正在加载中....</div>}>
                {
                        this.state.type===1?
                        <Nowplaying></Nowplaying>
                        :
                        <Comingsoon></Comingsoon>
                    }
               </Suspense>
                
            </div>
        )
    }
}

```

注意： Suspense 使用的时候， fallback 一定是存在且有内容的，否则会报错

### 3.forwordRef

#### 场景

比如：父组件中有一个按钮，点击后，子组件自动清空，并获取焦点

#### 痛点

 原来实现的逻辑是，子组件变成受控组件，将ref变量上交到父组件，共其使用。麻烦

```react
import React, { Component } from 'react'

export default class App extends Component {
    mytext = null

    render() {
        return (
            <div>
                <button onClick={()=>{
                    console.log(this.mytext)
                    this.mytext.current.focus()
                    this.mytext.current.value=""
                }}>获取焦点</button>

                <Child callback={(el)=>{
                    // console.log(el)

                    this.mytext = el
                }}/>
            </div>
        )
    }
}

class Child extends Component{
    mytext= React.createRef()

    componentDidMount() {
        // console.log(this.mytext)
        this.props.callback(this.mytext)
    }
    
    render(){
        return <div style={{background:"yellow"}}>
            <input defaultValue="11111111" ref={this.mytext}/>
        </div>
    }
}
```

##### 解决

forwardRef由react提供

父组件创建一个ref，传给子组件，子组件使用forwardRef重新包装，接受两个参数，一个是原来的props，第二个是ref. 这种方法，会使代码更简洁。

缺点：如果传递多个，还是使用原来的老办法吧。

```react
import React, { Component, forwardRef } from 'react'

export default class App extends Component {
    mytext =React.createRef()

    render() {
        return (
            <div>
                <button onClick={()=>{
                    console.log(this.mytext)
                    this.mytext.current.value=""
                    this.mytext.current.focus()
                }}>获取焦点</button>

                <Child ref={this.mytext}/>
            </div>
        )
    }
}

const Child = forwardRef((props,ref)=>{
    return <div style={{background:"red"}}>
        <input ref={ref} defaultValue="22222"/>
    </div>
})
```

#### 总结：

父组件想控制操作自组件的ref dom做一下事情，需要从子-->传递自己的ref,   而使用新方法，是，父组件创建一个ref,传递给子组件使用， 效果就是，ref节点提升到父组件中。





### 4.组件缓存

#### 概念

设想：父组件中，使用了一个子组件， 在正常情况下，只要父组件修改了state，页面就会重新渲染。子组件也会重新渲染。 渲染没问题，但是如果父组件频繁修改，并且修改的数据和子组件没有关系，这不就浪费了不必要的性能吗

react给出了处理方案

Class  中使用  ***PureComponent***

具体参看 八 小节

*functional* 组件  中使用 ***memo*** 

#### memo介绍

**为啥起memo这个名字？**

在计算机领域，记忆化是一种主要用来提升计算机程序速度的优化技术方案。它将开销较大的函数调用的返回结果存储起来，当同样的输入再次发生时，则返回缓存好的数据，以此提升运算效率。

**作用**

组件仅在它的 *props* 发生改变的时候进行重新渲染。通常来说，在组件树中 *React* 组件，只要有变化就会走一遍渲染流程。但是*React.memo()*，我们可以仅仅让某些组件进行渲染。

```react
import { memo } from 'react'  <---重点   react提供的方法

const Child = memo(()=>{ return <div>
<input type="text" />
</div>
})

或者
const Child = ()=>{ return <div>
<input type="text" />
</div>
})
const MemoChild = memo(Child)   <---重点 包裹一下

```

**案例**

点击第一个按钮，修改name数据，child没有变化，点击第二个按钮，修改title数据，child 触发了更新。

实现了按需更新，和自己有关就更新。

```react
import React, { Component, memo } from 'react'

export default class App extends Component {
    state ={
        name:"tom",
        title:"aaaaaa"
    }
    render() {
        return (
            <div>
                {this.state.name}
                <button onClick={()=>{
                    this.setState({
                        name:"xiaoming"
                    })
                }}>click</button>

                <button onClick={()=>{
                    this.setState({
                        title:"bbbbbbbbbb"
                    })
                }}>click2222</button>

                <Child title={this.state.title}/>
            </div>
        )
    }
}

const Child = memo((props)=>{
    console.log(11111111)
return <div>child-{props.title}</div>
})
```









## 二十一 React扩展

### GraphQL

一种用于 API 的查询语言

#### 使用场景：

比如小程序版使用pc的接口，实际需要的多个字段分散于多个接口，按照正常处理，是获取多个pc接口，返回后，数据格式整理，再使用,这个样子，数据使用麻烦，返回多余没有用的数据，手机数据慢的时候更是弊端。

GraphQL的出现，正好可以这个痛点。 多个请求，一次完成。

#### 1.简介

GraphQL是脸书fackbook开发的一种数据查询语言，并于2015年公开发布。它是程序接口的替代品 。
图形查询语言既是一种用于应用程序接口的查询语言，也是一个满足你数据查询的运行时。GraphQL对你的应用程序接口中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让API更容易地随着时间推移而演进。
官网:https://graphql.org/
中文网:http://graphql.cn/

特点:

1. 请求需要的数据，不多不少 

例如: account中有name,age,sex，department等。可以只取得需要的字段。

2 .获取多个资源，只用一个请求

3.描述所有可能类型的系统。便于维护，根据需求平滑演进，添加或者隐藏字段

restful一个接口只能返回一个资源，graphql一次可以获取多个资源。
restful用不同的url来区分资源，graphql用类型区分资源

```react
query {
    user(id : "1") {
        name
        gender
        employee(first: 20) {
            name
            email
        }
    father {
            telephone
        }
    son {
            school
        }
    }
}
```

#### 使用条件：

后端支持GraphQL这种查询方式，稍微改造。

 前端才能自由按需所取。

#### 使用概览

基于nodejs，展示后台如何配置

![](.\img\数据库查询.png)

#### 2.基本的使用方法



构建数据接口，需要以下三个插件。三个插件版本应该项目对应。这里给出本案例使用版本

```
{
  "name": "code",
  "version": "1.0.0",
  "description": "",
  "main": "helloWorld.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.16.4",          <----1 重点
    "express-graphql": "^0.7.1",    <----2 重点  
    "graphql": "^14.0.2",            <----3 重点
    "mongoose": "^5.13.14"
  }
}
```

对上述node后台项目，npm i 安装依赖，

创建第一个使用案例

demo1.js

```web-idl
const express = require("express") // node中 帮助我们快速创建一个接口应用插件
const {buildSchema} = require("graphql")
const graphqlHttp = require("express-graphql") // 连接器
// Scchema 表述接口形状
// 提供了hello字段查询 返回String
 // 提供了getName字段查询 返回String
 // 提供了getAge字段查询 返回Int 数字型的
var Scchema = buildSchema(`   
   type Query{
       hello: String,
       getName: String,
       getAge :Int
   }
`)
//处理器
const root = {
    hello:()=>{
        //通过数据库查
        var str = "hello wolrd1111"

        return str;
    },
    getName:()=>{
        return "kerwin"
    },
    getAge:()=>{
        return 100
    }
}

var app = express() //初始化一个方法
//app.use 创建一个数据的路由接口 浏览器访问这个接口，就能获取对用数据
app.use("/home",function(req,res){  
    res.send("home data2222") //返回的数据
})
app.use("/list",function(req,res){
    res.send("list data")
})

app.use("/graphql",graphqlHttp({
    schema:Scchema,
    rootValue:root,
    graphiql:true //调试器打开（开发中调式可以）
}))

app.listen(3000)

```

#####  启动方式node

```
 命令行中输入+回车   node .\01-helloworld.js
 只要不报错，就默认成功。
```

浏览器中，输入http://localhost:3000/graphql

![](.\img\调试面板.png)



左侧：GraphiQL: 查询语句   .根据上文你可以查询

```
{
  hello,
  getName,
  getAge
}   一次请求，获取三个接口里的数据
```

![](.\img\查询结果.png)





修改后，重新启动node

可以安装一些热更新的插件：例如：nodemo  或node-dev 

这里演示 **nodemon**

配置热更新

```
npm i -g node-dev nodemo   全局安装
或者
npm install --save-dev nodemon 局部安装nodemon
```

  使用

###### 热更新启动

```
nodemon one.js   //nodemon+ 空格 + 要执行的js文件
```

这里的热跟新，只是项目的更新，页面还是要自己手动刷新。

#### 3.参数类型和传递

**基本类型:**  String,Int,Float,Boolean和ID。可以在shema声明的时候直接使用。
**【类型】：**代表数组，例如: [lnt] 代表整型数组

和js传递参数一样，小括号内定义形参，但是注意:参数需要定义类型。

!(叹号)  代表参数不能为空

```
type Query {
  rollDice(numDice: Int!, numSides: Int):[Int]
}
```

##### 本小节完整代码

```
const express = require("express")
const {buildSchema} = require("graphql")
const graphqlHttp = require("express-graphql")
// 定义复杂类型   
var Scchema = buildSchema(`

   type Account{
       name:String,
       age:Int,
       location:String
   }

   type Film{
       id:Int,
       name:String,
       poster:String,
       price:Int
   }

   type Query{
       hello: String,
       getName: String,
       getAge :Int,
       getAllNames:[String],
       getAllAges:[Int],
       getAccountInfo: Account,
       getNowplayingList:[Film],
       geteFilmDetail(id:Int!):Film
   }
`)

var faskeDb = [{
    id:1,
    name:"1111",
    poster:"http://1111",
    price:100
},
{
    id:2,
    name:"2222",
    poster:"http://2222",
    price:200
},
{
    id:3,
    name:"3333",
    poster:"http://333",
    price:300
}]
//处理器
const root = {
    hello:()=>{
        //通过数据库查
        var str = "hello wolrd1111"

        return str;
    },
    getName:()=>{
        return "kerwin"
    },
    getAge:()=>{
        return 100
    },

    getAllNames:()=>{
        return ["kerwin","teichui","xiaoming"]
    },
    getAllAges(){
        return [19,20,200]
    },

    getAccountInfo(){
        return {
            name:"kerwin",
            age:100,
            location:"dalian"
        }
    },

    getNowplayingList(){
        return faskeDb
    },
    geteFilmDetail( {id} ){
        console.log(id)

        return faskeDb.filter(item=>item.id===id)[0]
    }
}

var app = express()
app.use("/graphql",graphqlHttp({
    schema:Scchema,
    rootValue:root,
    graphiql:true
}))

app.listen(3000)
```



#####  查询示例1  复杂类型 - 对象查询

定义复杂类型 - 对象

```
  var Scchema = buildSchema(`

   type Account{  <----定义查询 Account的类型
       name:String,
       age:Int,
       location:String
   }
   type Query{ // 定义查询

       getAccountInfo: Account, <----定义复杂查询 Account

   }
`)
```

浏览器中

条件

```
{
  getAccountInfo {  
    name
    age
    location
  },

}
```

查询结果

```json
{
  "data": {
    "getAccountInfo": {
      "name": "kerwin",
      "age": 100,
      "location": "dalian"
    }
  }
}
```

//这里查询三个属性结果  如果只需要name，可以只保留name查询条件。 如果要查询的属性，没有定义，则报错。

#####  查询示例2 复杂类型 - 数组查询

定义复杂类型 - 数组

```
// 定义复杂类型   
var Scchema = buildSchema(`
   type Film{
       id:Int,
       name:String,
       poster:String,
       price:Int
   }

   type Query{ // 定义查询
       hello: String,
       getName: String,
       getAge :Int,
       getAllNames:[String],
       getAllAges:[Int],
       getAccountInfo: Account, 
       getNowplayingList:[Film],<----定义复杂查询 
       geteFilmDetail(id:Int!):Film
   }
`)
```

条件

```
{
  getNowplayingList {
    id
  },
}
```

查询结果

```
{
  "data": {
    "getNowplayingList": [
      {
        "id": 1
      },
      {
        "id": 2
      },
      {
        "id": 3
      }
    ]
  }
}
```

#####  查询示例3 条件查询

```
var Scchema = buildSchema(`

   type Film{
       id:Int,
       name:String,
       poster:String,
       price:Int
   }

   type Query{
       geteFilmDetail(id:Int!):Film
   }
`)
```

条件

```
query{
  geteFilmDetail(id:1) {  查询id为1的项，要id,poster字段
    id,poster
  }
}
```

查询结果

```
{
  "data": {
    "geteFilmDetail": {
      "id": 1,
      "poster": "http://1111"
    }
  }
}
```

处理器入参，写的是结构形式

```
   geteFilmDetail( {id} ){   
        console.log(id)

        return faskeDb.filter(item=>item.id===id)[0]
    }
```





#### 4.mutation（新增和修改）

查询使用query ，修改数据使用 Mutation

##### 本小节完整代码

```react
const express = require("express")
const {buildSchema} = require("graphql")
const graphqlHttp = require("express-graphql")
var Scchema = buildSchema(`

   type Film{
       id:Int,
       name:String,
       poster:String,
       price:Int
   }

   input FilmInput{
        name:String,
        poster:String,
        price:Int
   }

   type Query{
       getNowplayingList:[Film]
    }

    type Mutation{
        createFilm(input: FilmInput):Film,
        updateFilm(id:Int!,input:FilmInput):Film,
        deleteFilm(id:Int!):Int
    }
`)

var faskeDb = [{
    id:1,
    name:"1111",
    poster:"http://1111",
    price:100
},
{
    id:2,
    name:"2222",
    poster:"http://2222",
    price:200
},
{
    id:3,
    name:"3333",
    poster:"http://333",
    price:300
}]
//处理器
const root = {
    getNowplayingList(){
        return faskeDb
    },

    createFilm({input}){
        var obj = {...input,id:faskeDb.length+1}

        faskeDb.push(obj)
        return obj
    },
    updateFilm({id,input}){
        console.log(id,input)
        var current = null
        faskeDb  = faskeDb.map(item=>{
            if(item.id===id){
                current = {...item,...input}
                return {...item,...input}
            }

            return item
        })

        return current
    },

    deleteFilm({id}){
        faskeDb = faskeDb.filter(item=>item.id!==id)

        return 1
    }
}

var app = express()
app.use("/graphql",graphqlHttp({
    schema:Scchema,
    rootValue:root,
    graphiql:true
}))

app.listen(3000)


```

##### 新增

新增条件

```
mutation{
  createFilm(input:{
    name:"tom",
    poster:"111",
    price:400
  }){
    id
  }
}     入参input，内含三个属性值，期望新增成功后，返回新增条的id
```

新增后的结果

```
{
  "data": {
    "createFilm": {
      "id": 17
    }
  }
}
```

##### 修改

修改条件

```
mutation{
  updateFilm(id:1,input:{
    name:"修改",
    poster:"111",
    price:400
  }){
    id
  }
}
```

修改结果返回

```
{
  "data": {
    "updateFilm": {
      "id": 1
    }
  }
}
```

### 5.结合数据库mongodb

第一步：先安装一个mongodb软件，本案例演示是安装软件的使用方式，还有一种是免安装的。

[安装参考](https://zhuanlan.zhihu.com/p/621780613)

[下载官网](https://www.mongodb.com/try/download/community)

安装完成后，启动软件，开启数据库服务，在27017端口。

![](.\img\数据库dbpng.png)

项目代码

```java
const express = require("express")
const {buildSchema} = require("graphql")
const graphqlHttp = require("express-graphql")

//-------------链接数据库服务------------------------
var mongoose = require("mongoose")
// maizuo 数据库名字
mongoose.connect("mongodb://localhost:27017/maizuo",{ useNewUrlParser: true,useUnifiedTopology: true })//后面参数是关闭警告 

//限制 数据库这个films（集合表） 只能存三个字段   (mongodb是以模型为对象进行数据管理的，所以使用前需要先创建一个。film就是数据库中的创建的一个集合名字)
//只要是限制存入的数据格式，防止数据错乱
var FilmModel = mongoose.model("film",new mongoose.Schema({
    name:String,
    poster:String,
    price:Number
}))
// 创建之后，模型对象给出CRUD操作的方法，只要使用这个工具函数 就能操作数据。 数据库名字（maizuo）和里面的集合名字film，mongodb中没有会自动创建 
// FilmModel.create
// filmModel.find
// FilmModel.update
// FimlModel.delete
//-------------------------------------

// buildSchema中声明操作一个类型只能一个 例如查询方法Query，自己的逻辑都放到这一个里面。否则报错
var Scchema = buildSchema(`

   type Film{
       id:String,
       name:String,
       poster:String,
       price:Int
   }

   input FilmInput{
        name:String,
        poster:String,
        price:Int
   }

   type Query{
       getNowplayingList(id:String!):[Film]
       getAll(id:String):[Film]
    }

    type Mutation{
        createFilm(input: FilmInput):Film,
        updateFilm(id:String!,input:FilmInput):Film,
        deleteFilm(id:String!):Int
    }
`)
//处理器
const root = {
    getAll(){
        return FilmModel.find()
    },
    getNowplayingList({id}){
        if(!id) return FilmModel.find() //不加条件是查询全部
        return FilmModel.find({_id:id})
    },

    createFilm({input}){
        /*
          1. 创建模型
          2. 操作数据库
        */
        return FilmModel.create({
            ...input
        })
    },
    updateFilm({id,input}){
        // 这里面纯mondgodb的方法
        return FilmModel.updateOne({
            _id:id
        },{
            ...input
        }).then(res=>FilmModel.find({_id:id})).then(res=>res[0])
        // 修改完返回的res {ok:1,nModified:0,n:1} 如果想确认一下是否修改成功。可以链式的再查一遍
    },

    deleteFilm({id}){
        return FilmModel.deleteOne({_id:id}).then(res=>1)
    }
}

var app = express()
app.use("/graphql",graphqlHttp({
    schema:Scchema,
    rootValue:root,
    graphiql:true
}))

//配置静态资源目录
app.use(express.static("public"))

app.listen(3000)

```

启动接口graphql项目，访问 http://localhost:3000/graphql

接下来测试，graphql项目，是否可以正常操作mongodb数据

![](.\img\ql服务png.png)



##### 依次测试CRUD

###### 增加

触发graphal的修改操作，左侧输入如下指令

```
mutation{
  createFilm(input:{
    name:"111",
    poster:"http://111",
    price:10
  }) {
    id
  }
}
```

然后，查看mongodb，查看数据库, 新增一个数据库maizuo,和其中押给集合films。

![](.\img\添加数据.png)



###### 修改

graphql输入指令

```
657d7203e45c8253e88520be是从数据库中随便找一个

mutation{
  updateFilm(id:"657d7203e45c8253e88520be",input:{
    name:"111修改了",
    poster:"http://111777",
    price:10
  }) {
    id
  }
}
```

###### 删除

```
是从数据库中随便找一个id
mutation{
  deleteFilm(id:"657d7203e45c8253e88520be")

}
```

查询所有

```
query{
  getAll {
    id,name
  }
}
或者
     更具id查找，id为空就查找所有
query{
  getNowplayingList( id:"",) {
    id,name
  }
}


```

### 6. html前端项目使用CRUD接口

为便于测试，serve项目，对外暴漏静态文件地址。这样，可以和接口服务，公用同一个ip和域名，不会跨域。

```
var app = express()
app.use("/graphql",graphqlHttp({
    schema:Scchema,
    rootValue:root,
    graphiql:true
}))

//配置静态资源目录
app.use(express.static("public"))

app.listen(3000)

```

项目中，新建一个public文件夹，里面新建一个home.html文件，代码如下，端口3000服务下，

```
http://localhost:3000/home.html  即可以访问测试html页面
```





使用方式和规范

home.htm

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1>home</h1>

    <button onclick="getData()">查询数据</button>
    <button onclick="createData()">创建数据</button>
    <button onclick="updateData()">更新数据</button>
    <button onclick="deleteData()">删除数据</button>

    <script>
        function getData() {

            const myquery = `
            query {
                getNowplayingList( id:"",) {
                    id,
                    name
                }
            }
            `
            fetch("/graphql", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                body: JSON.stringify({
                    query: myquery
                })
            }).then(res => res.json()).then(res => {
                console.log(res)
            })
        }

        function createData() {
            const myquery = `
            mutation ($input:FilmInput){

                createFilm(input:$input) {
                    id,
                    name
                }
            }
            `
            fetch("/graphql", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                body: JSON.stringify({
                    query: myquery,
                    variables: {
                        input: {
                            name: "html创建的7777",
                            price: 60,
                            poster: "http://7777"
                        }
                    }
                })
            }).then(res => res.json()).then(res => {
                console.log(res)
            })
        }

        function updateData() {
            const myquery = `
            mutation ($id:String!,$input:FilmInput){

                updateFilm(id:$id,input:$input) {
                    id,
                    name
                }
            }
            `
            fetch("/graphql", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                body: JSON.stringify({
                    query: myquery,
                    variables: {
                        id: "61e520b322f995d3f88f3faa",
                        input: {
                            name: "6666-修改",
                            price: 66,
                            poster: "http://6666-修改"
                        }
                    }
                })
            }).then(res => res.json()).then(res => {
                console.log(res)
            })
        }

        function deleteData() {
            const myquery = `
            mutation ($id:String!){

                deleteFilm(id:$id)
            }
            `
            fetch("/graphql", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                },
                body: JSON.stringify({
                    query: myquery,
                    variables: {
                        id: "61e520b322f995d3f88f3faa"
                    }
                })
            }).then(res => res.json()).then(res => {
                console.log(res)
            })
        }
    </script>
</body>

</html>
```

### 7在react项目中CRUD的操作

安装相关插件, 主要分为两大类，一个graphql是一种用于 API 的查询语言,另一个是apollo，[apollo](https://blog.csdn.net/Clearlove_S7/article/details/130913876)

```
npm i react-apollo apollo-boost graphql graphql-tag

dependencies中 
    "apollo-boost": "^0.4.9",
    "react-apollo": "^3.1.5",
    "graphql": "^16.2.0",
    "graphql-tag": "^2.12.6"
```

serves服务代码

```javascript
const express = require("express")
const {buildSchema} = require("graphql")
const graphqlHttp = require("express-graphql")

//-------------链接数据库服务------------------------
var mongoose = require("mongoose")
// maizuo 数据库名字
mongoose.connect("mongodb://localhost:27017/maizuo",{ useNewUrlParser: true,useUnifiedTopology: true })//后面参数是关闭警告 

//限制 数据库这个films（集合表） 只能存三个字段   (mongodb是以模型为对象进行数据管理的，所以使用前需要先创建一个。film就是数据库中的创建的一个集合名字)
//只要是限制存入的数据格式，防止数据错乱
var FilmModel = mongoose.model("film",new mongoose.Schema({
    name:String,
    poster:String,
    price:Number
}))
// 创建之后，模型对象给出CRUD操作的方法，只要使用这个工具函数 就能操作数据。 数据库名字（maizuo）和里面的集合名字film，mongodb中没有会自动创建 
// FilmModel.create
// filmModel.find
// FilmModel.update
// FimlModel.delete
//-------------------------------------

// buildSchema中声明操作一个类型只能一个 例如查询方法Query，自己的逻辑都放到这一个里面。否则报错
var Scchema = buildSchema(`

   type Film{
       id:String,
       name:String,
       poster:String,
       price:Int
   }

   input FilmInput{
        name:String,
        poster:String,
        price:Int
   }

   type Query{
       getNowplayingList(id:String):[Film]
       getAll(id:String):[Film]
    }

    type Mutation{
        createFilm(input: FilmInput):Film,
        updateFilm(id:String!,input:FilmInput):Film,
        deleteFilm(id:String!):Int
    }
`)
//处理器
const root = {
    getAll(){
        return FilmModel.find()
    },
    getNowplayingList({id}){
        if(!id) return FilmModel.find() //不加条件是查询全部
        return FilmModel.find({_id:id})
    },

    createFilm({input}){
        /*
          1. 创建模型
          2. 操作数据库
        */
        return FilmModel.create({
            ...input
        })
    },
    updateFilm({id,input}){
        // 这里面纯mondgodb的方法
        return FilmModel.updateOne({
            _id:id
        },{
            ...input
        }).then(res=>FilmModel.find({_id:id})).then(res=>res[0])
        // 修改完返回的res {ok:1,nModified:0,n:1} 如果想确认一下是否修改成功。可以链式的再查一遍
    },

    deleteFilm({id}){
        return FilmModel.deleteOne({_id:id}).then(res=>1)
    }
}

var app = express()


app.use("/graphql",graphqlHttp({
    schema:Scchema,
    rootValue:root,
    graphiql:true
}))

//配置静态资源目录
app.use(express.static("public"))

app.listen(3000)


```

setupProxy.js  代理配置

```
  app.use(
    '/graphql', 
    createProxyMiddleware({
      target: 'http://localhost:3000',
      changeOrigin: true
    })
  );
```



##### 查询语句Query

```react

import React, { Component } from 'react'

import {ApolloProvider,Query} from 'react-apollo'
import ApolloClient  from 'apollo-boost'
import gql  from 'graphql-tag'

const client = new ApolloClient({
    uri:"/graphql"              <-----1 接口服务3000上  react项目需要配置代理 代码见上面
})

export default class App extends Component {
    render() {
        return (
            <ApolloProvider client = {client}>
                <div>
                    <KerwinQuery></KerwinQuery>
                </div>
            </ApolloProvider>
        )
    }
}

class KerwinQuery extends Component{
// <-----2  这里的查询语句，要和serve中的查询语句对应；在graphql中pc页面测试成功。
    query = gql`  
          query {
            getNowplayingList {
            id,
            name,
            price
            }
        }
    `
    render(){
        return <Query query={this.query}>
            {
                ({loading, data})=>{
                    console.log(loading,data)
                    return loading?<div>loading....</div>:
                    <div>
                        {   // <-----2 getNowplayingList字段是自定义的查询方法名字
                            data.getNowplayingList.map(item=>
                                <div key={item.id}>
                                    <div>名字：{item.name}</div>
                                    <div>价格：{item.price}</div>
                                </div>    
                            )
                        }
                    </div>
                }
            }
        </Query>
    }
}
```

注意点：实测中，安装后启动，如上查询页面加载报错，就删掉 **node_modules** 重新初始化。

##### 条件查询Query

注意点：

loading, data, refetch三个参数：数据请求中loading 是true,请求回来后，data形参传入，loading变false,利用这点可以作为加载等待效果。 refetch方法，是触发Query组件，刷新。 因为它不是react的组件，所以更新数据后，需要使用apollo提供的方法。



```react

import React, { Component } from 'react'
import {ApolloProvider,Query} from 'react-apollo'
import ApolloClient  from 'apollo-boost'
import gql  from 'graphql-tag'

const client = new ApolloClient({
    uri:"/graphql"
})
export default class App extends Component {
    render() {
        return (
            <ApolloProvider client = {client}>
                <div>
                    <KerwinQuery></KerwinQuery>
                </div>
            </ApolloProvider>
        )
    }
}

class KerwinQuery extends Component{

    query = gql`
        query getNowplayingList($id:String!){
            getNowplayingList(id:$id) {
            id,
            name,
            price
            }
        }
    `
    state = {
        id:"657d776a1533e91bec364781"
    }
    render(){
        return <div>
            <input type="text" onChange={(evt)=>{
                this.setState({
                    id:evt.target.value
                })
            }}/>
           {/* variables属性，入参会传到query中，对应$id */}
            <Query query={this.query} variables={{id:this.state.id}}>   
            {
                ({loading, data, refetch})=>{
                    console.log(loading)
                      console.log(refetch)
                    return loading?<div>loading....</div>:
                    <div>
                        {
                            data.getNowplayingList.map(item=>
                                <div key={item.id}>
                                    <div>名字：{item.name}</div>
                                    <div>价格：{item.price}</div>
                                </div>    
                            )
                        }
                    </div>
                }
            }
        </Query>
        </div>
    }
}
```

##### 新增操作Mutation

react-apollo插件，提供了Mutation组件

```

import React, { Component } from 'react'
import {ApolloProvider,Mutation} from 'react-apollo'//Mutation组件  修改操作
import ApolloClient  from 'apollo-boost'
import gql  from 'graphql-tag'

const client = new ApolloClient({
    uri:"/graphql"
})
export default class App extends Component {
    render() {
        return (
            <ApolloProvider client = {client}>
                <div>
                    <KerwinCreate></KerwinCreate>
                </div>
            </ApolloProvider>
        )
    }
}

class KerwinCreate extends Component{
//  createFilm($input: FilmInput 第一层 是表述 ， 第二层 createFilm(input:$input)是传参
    createFilm = gql`
    mutation createFilm($input: FilmInput){

        createFilm(input:$input) {
          id,
          name,
          price
        }
      }
    `
    render(){
        return <div>
            <Mutation mutation={this.createFilm}>
                {
                    (createFilm,{data})=>{
                        console.log(data)
                        return <div>
                            <button onClick={()=>{
                                createFilm({
                                    variables:{
                                        input:{
                                            name:"lyx",
                                            poster:"http://777",
                                            price:70
                                        }
                                    }
                                })
                            }}>add</button>
                        </div>
                    }
                }
            </Mutation>
        </div>
    }
}
```

##### 修改Mutation

Mutation

```react

import React, { Component } from 'react'
import {ApolloProvider,Mutation} from 'react-apollo'
import ApolloClient  from 'apollo-boost'
import gql  from 'graphql-tag'

const client = new ApolloClient({
    uri:"/graphql"
})
export default class App extends Component {
    render() {
        return (
            <ApolloProvider client = {client}>
                <div>
                    <KerwinUpdate></KerwinUpdate>
                </div>
            </ApolloProvider>
        )
    }
}

class KerwinUpdate extends Component{

    createFilm = gql`
    mutation updateFilm($id:String!,$input: FilmInput){

        updateFilm(id:$id,input:$input) {
          id,
          name,
          price
        }
      }
    `
    render(){
        return <div>
            <Mutation mutation={this.createFilm}>
                {
                    (updateFilm,{data})=>{
                        console.log(data)
                        return <div>
                            <button onClick={()=>{
                                updateFilm({
                                    variables:{
                                        id:"657ec010857267511c25f21a",
                                        input:{
                                            name:"777-修改",
                                            poster:"http://777-修改",
                                            price:700
                                        }
                                    }
                                })
                            }}>update</button>
                        </div>
                    }
                }
            </Mutation>
        </div>
    }
}
```

##### 删除Mutation

```react

import React, { Component } from 'react'
import {ApolloProvider,Mutation} from 'react-apollo'
import ApolloClient  from 'apollo-boost'
import gql  from 'graphql-tag'

const client = new ApolloClient({
    uri:"/graphql"
})
export default class App extends Component {
    render() {
        return (
            <ApolloProvider client = {client}>
                <div>
                    <KerwinDelete></KerwinDelete>
                </div>
            </ApolloProvider>
        )
    }
}

class KerwinDelete extends Component{

    createFilm = gql`
    mutation deleteFilm($id:String!){

        deleteFilm(id:$id)
      }
    `
    render(){
        return <div>
            <Mutation mutation={this.createFilm}>
                {
                    (deleteFilm,{data})=>{
                        console.log(data)
                        return <div>
                            <button onClick={()=>{
                                deleteFilm({
                                    variables:{
                                        id:"657d77241533e91bec36477f"
                                    }
                                })
                            }}>delete</button>
                        </div>
                    }
                }
            </Mutation>
        </div>
    }
}
```

总结：功能得以实现，是通过abollo提供的供应商组件，从app根组件注入，子组件使用提供的CRUD相对应的方法，用法与GraphQ基本一致。定义约束，方法，参数。

### 8.Dva.JS（阿里react前端开发框架）

dva 是由阿里架构师 sorrycc 带领 team 完成的一套前端框架，在作者的 [github](https://so.csdn.net/so/search?q=github&spm=1001.2101.3001.7020) 里是这么描述它的：“dva 是 react 和 redux 的最佳实践”。

（实际项目中很少单独开发，都是配合Umijs使用。）

https://dvajs.com/

https://dvajs.com/knowledgemap/#javascript-%E8%AF%AD%E8%A8%80 知识地图

#### 1.介绍

1.What's dva ?
dva 是基于现有应用架构 (redux + react-router + redux-saga 等)的一层轻量封装。dva 是 react 和 redux 的最佳实践。最核心的是提供了 app.model 方法，用于把 reducer, initialState, action, saga 封装到一起。官网    dva = React-Router + Redux + Redux-saga。

dva 首先是一个基于 redux 和 redux-saga的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch所以也可以理解为一个轻量级的应用框架。

#### 2.安装

1.安装 dva-cli
npm install dva-cli -g
2.扎到安装项目的目录
cd ylz_project/my_reactdemo
3.创建项目：Dva-test项目名
dva new Dva-test
4.进入项目
cd Dva-test
5.启动项目
npm start

备注：

如果报错 `'roadhog' 不是内部或外部命令 `，就 `npm i roadhog -g`;

如果报错较多 都是dva相关，可能是依赖不全，删除node_modules重新安装依赖。

#### 3.项目结构

![](https://img-blog.csdn.net/20180823163149227?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb194dV81MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



[学习react前端框架dva](https://blog.csdn.net/gao_xu_520/article/details/81979463?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-81979463-blog-128194072.235%5Ev39%5Epc_relevant_anti_vip_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-81979463-blog-128194072.235%5Ev39%5Epc_relevant_anti_vip_base&utm_relevant_index=6)

#### 4.dva 应用的最简结构

```react
import dva from 'dva';
const App = () => <div>Hello dva</div>;

// 创建应用
const app = dva();
// 注册视图
app.router(() => <App />);
// 启动应用
app.start('#root');

```

#### 5.配置history

 项目默认hash

router.js

```react
import React from 'react';
import { Router, Route, Switch } from 'dva/router';
import IndexPage from './routes/IndexPage';

function RouterConfig({ history }) {
  return (
    <Router history={history}> 
      <Switch>
        <Route path="/" exact component={IndexPage} />
      </Switch>
    </Router>
  );
}

export default RouterConfig;

```

如果修改为history，配置方法在dva（{传参方式}）

index.js

```
import dva from 'dva';
import './index.css';

// 1. Initialize
const app = dva(
    {
        //   history:require("history").createBrowserHistory()  //这里
    }
);

// 2. Plugins
// app.use({});

// 3. Model
// app.model(require('./models/example').default);

// 4. Router
app.router(require('./router').default);

// 5. Start
app.start('#root');
```

遇到问题：因为dva版本问题,如果history提示找不到方法。 就使用第三方history插件。

npm install history

```
import { createBrowserHistory as createHistory } from 'history';
 
const app = dva({
  history: createHistory()
});
```

[详情参照](https://blog.csdn.net/weixin_33991418/article/details/91888694)

##### 具体功能变化？

###### 1.路由

： 基本没变，二级路由使用 Route的render的重写功能。

```react
import React from 'react';
import { Router, Route, Switch,Redirect } from 'dva/router';
import App from './routes/App';
import Film from './routes/Film';
import Cinema from './routes/Cinema';
import Center from './routes/Center';
import Detail from './routes/Detail';
import Login from './routes/Login';

function RouterConfig({ history }) {
  return (
    <Router history={history}>
      <Switch>
        <Route path="/login" component={Login}/>
        <Route path="/" render={()=>
          <App>
             <Switch>
              <Route path="/film" component={Film}/>
              <Route path="/cinema" component={Cinema}/>
              <Route path="/center" render={()=>localStorage.getItem("token")?<Center/>:                  <Redirect to="/login"/>}/>
              <Route path="/detail/:myid" component={Detail}/>

              <Redirect from="/" to="/film"></Redirect>
             </Switch>
          </App>
        }/>

      </Switch>
    </Router>
  );
}

export default RouterConfig;

```

###### 2.redux公共strory

models文件中专门放置管理story，根据命名空间，可以多个文件js，这样小组内每个成员都可以创建一个自己的state空间，管理自己的公共数据

###### 使用reducers中的属性

models文件夹下

```
export default {

    namespace: 'maizuo',// 命名空间 connect高阶组件包装后 本空间数据以key对象形式注入state型参中
  
    state: {
        isShow:true,
        list:[]
    },
```

router文件下app.js

```react
import { connect } from 'dva'
import React, { Component } from 'react'
import Tabbar from '../components/Tabbar'

class App extends Component {
    componentDidMount() {
        // console.log(this.props)
    }
    
    render() {
        return (
            <div>
                {this.props.children}
                {this.props.isShow && <Tabbar/>}
            </div>
        )
    }
}

export default connect((state)=>{
    console.log(state)
    // 这里参数重整 这里那个key，App组件中就怎么使用
    return {                   
        a:1,
        isShow:state.maizuo.isShow
    }
})(App)
```

###### reducers中的事件



models/maizuo.js

```react
export default {

    namespace: 'maizuo',// 命名空间 connect高阶组件包装后 本空间数据以key对象形式注入state型参中
  
    state: {
        isShow:true,
        list:[]
    },

    reducers:{
        hide(prevState,action){
            return {...prevState,isShow:false}
        },
        show(prevState,action){
            return {...prevState,isShow:true}
        },
    },
```

detail.js调用页面

```react
import { connect } from 'dva'
import React, { Component } from 'react'

class Detail extends Component {
    componentDidMount() {
        console.log(`接受上个页面传来的id,利用此id取数据`,this.props.match.params.myid)

        // console.log(this.props)

        this.props.dispatch({
            type:"maizuo/hide"   // 注意调用方法   type:命名空间/要调用的方法
        })
    }

    componentWillUnmount(){
        this.props.dispatch({
            type:"maizuo/show"
        })
    }
    
    render() {
        return (
            <div>
                Detail
            </div>
        )
    }
}

export default connect()(Detail)  //包装后，注入属性（state 可选） 和方法dispatch
```

###### 异步事件

关键点：effects {}下的异步方法

models文件下maizuo.js

```
import { getCinemaListService } from "../services/maizuo"

export default {

    namespace: 'maizuo',// 命名空间 connect高阶组件包装后 本空间数据以key对象形式注入state型参中
  
    state: {
        list:[]
    },

    reducers:{


        changeCinemaList(prevState,{payload}){
            return {...prevState,list:payload}
        }
    },


    //异步- redux-saga
    effects:{
        *getCinemaList(action,{call,put}){
            // console.log(obj)
            var res = yield call(getCinemaListService) //call里面放promise方法
            console.log(res.data.data.cinemas)
            yield put({
                type:"changeCinemaList",  // 数据回来后，调用普通同步事件，触发reducers事件
                payload:res.data.data.cinemas
            })
        }
    }
}
```

services/maizuo接口请求数据封装

```
import request from '../utils/request'

export function getCinemaListService() {
    return request("https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=5386964", {
        headers: {
            'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.2.0","e":"16395416565231270166529","bc":"110100"}',
            'X-Host': 'mall.film-ticket.cinema.list'
        }
    })
}
```



电影组件使用数据

```react
import { connect } from 'dva'
import React, { Component } from 'react'

class Cinema extends Component {
    componentDidMount() {
        if(this.props.list.length===0){
            //dispatch
            this.props.dispatch({    <----重点   调用方法 maizuo空间中的getCinemaList方法
                type:"maizuo/getCinemaList"
            })
        }else{
            console.log("缓存",this.props.list)
        }
    }
    
    render() {
        return (
            <div>
                <ul>
                    {
                        this.props.list.map(item=>
                            <li key={item.cinemaId}>
                                {item.name}
                            </li>    
                        )
                    }
                </ul>
            </div>
        )
    }
}
const mapStateToProps = (state)=>({  // 包装组件
    list:state.maizuo.list
})
export default connect(mapStateToProps)(Cinema)
```











**数据流图**

浏览器中输入项目路由，route文件下都是组件页面，组件经过connect高阶函数包装后，赋予了state数据和dispatch方法，到被包装组件的props，组件使用dispatch调用对应空间命名中的方法，调用reducer事件，修改state，更改视图。如果是异步事件，方法名匹配到Effect：{方法}，yield状态生成器， 返回接口数据后yield put，再触发reducers中的普通的同步事件，后面照常。

![](.\img\dva.png)

##### 6.跨域配置

项目根目录下有个 .webpackrc文件 ，json数据格式，配置跨域

案例：1

```react
import React, { Component } from 'react'
import {withRouter} from 'dva/router'
import request from '../utils/request'
export default class Center extends Component {
    render() {
        return (
            <div>
                Center
                <WithChild/>
            </div>
        )
    }
}


class Child extends Component{

    componentDidMount() {
        request("/api/mmdb/movie/v3/list/hot.json?  ct=%E5%8C%97%E4%BA%AC&ci=1&channelId=4").then(res=>{ //接口跨域
            console.log(res)
        })

        request("/users").then(res=>{
            console.log(res.data)
        })
    } 
    
    render(){
        return <div>
            <button onClick={()=>{
                console.log(this.props)
                localStorage.removeItem("token")
                this.props.history.push('/login')
            }}>退出登录</button>
        </div>
    }
}

const WithChild = withRouter(Child)
```

 .webpackrc

```json
{
    "proxy":{
        "/api":{
            "target":"https://i.maoyan.com",
            "changeOrigin":true // 改变源：true
        }
    }
}
释意： 对本项目中包含/api字段的接口，代理到target指定域名上。
```

##### 7. mock数据

核心点：根目录下配置文件.roadhogrc.mock.js

案例演示get post两种方法

根目录mock文件夹  放置mock数据

```react
export default{
    'GET /users' : {name:"kerwin",age:100,location:"dalian"},

    'POST /users/login' :(req,res)=>{
        console.log(req.body) //获取传入的参数

        if(req.body.username==="kerwin" && req.body.password==="123") {
            res.send({
                ok:1
            })
        }else{
            res.send({
                ok:0
            })
        }
        
    }
}
```

引入.roadhogrc.mock.js

```react

const mockobj =  require('./mock/api')
export default {
    ...mockobj // 解构进来  其他的mock方法，都可以在这里引入 
};

```

测试接口

get   

浏览器中    http://localhost:8000/users  可以看到返回数据

post

项目中封装请求使用fetch方法，参照传参。

```react
import React, { Component } from 'react'
import request from '../utils/request'

export default class Login extends Component {
    username = React.createRef()
    password = React.createRef()
    render() {
        return (
            <div>
                用户名：
                <input type="text" ref={this.username}/>
                <br/>
                密码：
                <input type="password" ref={this.password}/>

                <button onClick={()=>{
                    console.log(this.username.current.value,this.password.current.value)

                    request("/users/login",{
                        method:"POST",
                        body:JSON.stringify({
                            username:this.username.current.value,
                            password:this.password.current.value
                        }),
                        headers:{
                            "Content-Type":"application/json"
                        }
                    }).then(res=>{
                        console.log(res.data)

                        if(res.data.ok){
                            localStorage.setItem("token","dwadw23232")
                            this.props.history.push("/center")
                        }else{
                            alert("用户名密码不匹配")
                        }
                    })
                }}>登录</button>
            </div>
        )
    }
}

```



附注：部分页面完整代码

models文件夹

maizuo.js

```react
import { getCinemaListService } from "../services/maizuo"

/*
 * @作者: kerwin
 * @公众号: 大前端私房菜
 */
export default {

    namespace: 'maizuo',// 命名空间 connect高阶组件包装后 本空间数据以key对象形式注入state型参中
  
    state: {
        isShow:true,
        list:[]
    },

    reducers:{
        hide(prevState,action){
            return {...prevState,isShow:false}
        },
        show(prevState,action){
            return {...prevState,isShow:true}
        },

        changeCinemaList(prevState,{payload}){
            return {...prevState,list:payload}
        }
    },

    subscriptions: {
        setup({ dispatch, history }) {  // eslint-disable-line
            console.log("初始化")
        }
    },

    //异步- redux-saga
    effects:{
        *getCinemaList(action,{call,put}){
            // console.log(obj)
            var res = yield call(getCinemaListService)
            console.log(res.data.data.cinemas)
            yield put({
                type:"changeCinemaList",
                payload:res.data.data.cinemas
            })
        }
    }
}
```

![](.\img\dva代码项目结构.png)











### 9.Umi.js（蚂蚁集团底层前端框架）

Umi 是蚂蚁集团的底层前端框架 。

umi，中文可发音为乌米，是一个可插拔的企业级 react 应用框架。umi 以路由为基础的，支持类 next.is 的**约定式路由**（1），以及各种进阶的路由功能，并以此进行功能扩展，比如支持路由级的按需加载。umi 在约定式路由的功能层面会更像 nuxt.is 一些

（1）： 简单来说就是pages下创建一个页面时，自动已文件名生成路由，浏览器中直接输入文件名，就可以访问页面。

 https://umijs.org/

https://umijs.org/docs/guides/getting-started  快速上手

#### 1.安装

第一种方式：逐个配置

安装umi脚手架

```
npm install -g umi
```

检查版本号

```
umi -v
```

创建一个文件夹

```
mkdir umidemo
```

然后 我们cd到这个umidemo下

```
cd umidemo
```

然后 我们输入

```
umi g page index   //
```

这样 我们就创建出来了一个page页面 叫 index

然后 我们终端执行

```
umi dev
```

这样我们的项目就起来了

我们复制终端的地址 放在浏览器访问 就达到了下图效果

所有配置都在 .umi中,其实 你用umi g page 后面跟什么名字 就会创建什么界面

```
umi g page users/user  //page下创建users文件夹 user页面
```

[详情参考](https://blog.csdn.net/weixin_45966674/article/details/133831191)

第二种方式：使用脚手架

```
mkdir myapp && cd myapp //空目录

npx @umijs/create-umi-app  // 会在当前文件夹下创建配置文件

cnpm i  // 初始化依赖

npm run start // 启动项目
```

![](.\img\umi脚手架生成文件预览.png)



#### 2.mock数据

 使用方法参考上面的DvaJS中的第7小节。

*umi* 里约定 *mock* 文件夹下的文件或者
*page(s)* 文件夹下的 *_mock*
文件即 *mock* 文件，文件导出接口定义，支持基于 *require* 动态分析的实时刷新，支持 *ES6* 语法，以及友好的出错提示。

 简单说就是只要你按照约定：在根目录下新建mock命名的文件，里面代码如下， 文件名字随意。

**mock/api.js** 文件

```javascript
export default {
// 支持值为 Object 和 Array
'GET /api/users': { users: [1, 2] },

// GET POST 可省略
'/api/users/1': { id: 1 },

// 支持自定义函数，API 参考 express@4
'POST /api/users/create': (req, res) => { res.end('OK'); },
}

```

浏览器中：

```
http://localhost:8000/users

//{"name":"kerwin","age":100} 显示数据
```



#### 3.跨域设置

案例：对猫眼电影列表做跨域处理

```react
代码片段  
useEffect(()=>{
fetch("api/gateway?cityId=110100&pageNum=1&pageSize=10&type=1&k=7383801"
,{headers:{}).
then(res=>res.json()).then(res=>{
console.log(res.data.films)
 setlist(res.data.films)
        })
    },[])
```

跨域处理：

**.umirc.ts**

```json
  proxy:{
    "/api":{
      target:"https://i.maoyan.com", // 对/api开头的请请求拦截，并替换域名为target。
      changeOrigin:true
    }
  },
```







#### 4.路由

umi 会根据 pages 目录自动生成路由配置。需要注释.umirc.js，routes相关,否则自动配置不生效

#### 基础路由

（整体显示逻辑：1.src下是否有layouts文件，有显示根layout,2.再去找pages下index.tsx，显示出来。）

```
 --pages文件
  ---css文件
  ---index.tsx 首页
  ---404.tsx  找不到路由，自动导入本页面
  ---center.tsx
  ---Film.tsx   Film文件名即为路由（首字母大小不敏感，建议大写。）
```

##### (1)  重定向

自动项目，自定进入index.jsx， 自动跳转到指定页面去

```react
import {Redirect} from 'umi' 
 export default () => {
  return (<Redirect to="/film"/>
   );
 }

```

##### (2)嵌套路由

案例：film下两个tab切换页面，通过父页面关键名字 _layout.tsx,父页面通过重定向到其中一个字页面。

![](.\img\嵌套路由png.png)

_layout.tsx页面

```react

import {Redirect,useLocation} from 'umi'
export default function Film(props:any) {
    const location = useLocation()
    // console.log(location)
    if(location.pathname==="/film" || location.pathname==="/film/"){
        return <Redirect to="/film/comingsoon"/>
    }
    return (
        <div>
            <div style={{height:'200px',background:"yellow"}}>大轮播</div>
            {props.children}
        </div>
    )
}

```

##### 根项目嵌套

关键点：项目启动时，会先查看src下是否有layouts文件，有的话会作为根组件嵌套。例如项目的底部切换tab。

![](.\img\根路由嵌套.png)

layouts/index.tsx

```react
import {NavLink} from 'umi'
import './index.less'
export default function IndexLayout(props:any) {
    if(props.location.pathname==="/city" || props.location.pathname.includes("/detail")){
        return <div>{props.children}</div>
    }
    return (
        <div>
            {props.children}  // 显示传递过来的子页面 视口
        
            <ul>
                <li>
                    <NavLink to="/film" activeClassName="active">film</NavLink>
                </li>
                <li>
                    <NavLink to="/cinema" activeClassName="active">cinema</NavLink>
                </li>
                <li>
                    <NavLink to="/center" activeClassName="active">center</NavLink>
                </li>
            </ul>
        </div>
    )
}
```

##### 声明式导航

```react
import {NavLink} from 'umi'

...
 <NavLink to="/film" activeClassName="active">film</NavLink>  
//activeClassName react中的方法这里也支持
```

##### 编程式路由和动态传参

关键点：路由跳转使用hooks; 动态接受参数，详情页面按约定创建文件名字。

列表页：

```react
import {useEffect,useState} from 'react'
import {useHistory} from 'umi'

export default function Nowplaying(props:any) {
    const [list, setlist] = useState([])
    const history = useHistory()
    useEffect(()=>{
        fetch("https://m.maizuo.com/gateway?cityId=110100&pageNum=1&pageSize=10&type=1&k=7383801",{
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.2.0","e":"16395416565231270166529","bc":"110100"}',
                'X-Host': 'mall.film-ticket.film.list'
            }
        }).then(res=>res.json())
        .then(res=>{
            console.log(res.data.films)
            setlist(res.data.films)
        })
    },[])
    return (
        <div>
            {
                list.map((item:any)=>
                    <li key={item.filmId} onClick={()=>{
                        // console.log(history)

                        history.push(`/detail/${item.filmId}`)
                    }}>{item.name}</li>
                )
            }
        </div>
    )
}
```

**详情页**

承接上文路由push传参，这里展示接受参数方法。

![](.\img\动态路由.png)



[id].tsx

```react
import {useParams} from 'umi'  //为便于取参 umi提供了一个hook useParams
interface IParams {
    id:string
}
export default function Detail(props:any) {
    // console.log(props)
    const params = useParams<IParams>()
    console.log(params.id) // 拿到参数
    
    return (
        <div>
            Detail
        </div>
    )
}
```

##### 路由拦截

实现逻辑：通过一个简单的自定义包装器实现。 对那个组件进行控制，就对那个组件进行包装，成为其父组件，以便于控制其显示或一些自定义逻辑，比如跳转登录页等操作。

关键点：src 下 新建包装器文件夹，创建一个包装器页面，包含自定义拦截逻辑。（wrappers名字是固定的。）

![](.\img\路由拦截.png)



center.jsx

```react
 function Center() {
    return (
        <div>
            Center
        </div>
    )
}
Center.wrappers = ["@/wrappers/Auth"] // 指定包装器路径 使自己成为子组件（给自己找爹）
export default Center
```

##### hash模式

默认是history模式，不带#；如果需要配置为hash模式路径加#

 **在.umirc.js**

```
export default { 
   history:{ type: 'hash' }
}

```

#### 5.使用ant-mobile移动ui组件库

Umijs是阿里开发的，antui也是阿里开发的，所以，Umi默认安装。所以可能自己安装了新版本，任然显示老样式。这时需要去配置**.umirc.ts** 里，关闭Umi提供的插件。

```
 关闭自带的组件库
 antd:{
    mobile:false
  }
```



ant移动组件库  https://ant-design-mobile.antgroup.com/zh/guide/quick-start

```
npm install --save antd-mobile   安装插件

```

使用图标icon  需要单独安装  具体参照文档要求（本案例使用v5.33.0）

练习:使用组件实现手机端常见的城市选择页面A-Z排序。

组件库：indexBar序列

```react
import { useEffect,useState } from 'react'
import { IndexBar, List } from 'antd-mobile'
import {useHistory } from 'umi'
export default function City() {
    const history = useHistory()
    const [list, setlist] = useState<any>([])
    const filterCity = (cities:any)=>{
        console.log(cities)
        const letterArr:Array<string> = []
        const newlist = []
        for(var i=65;i<91;i++){
            letterArr.push(String.fromCharCode(i))
        }
        // console.log()
        for(var m in letterArr){
            var cityitems:any = cities.filter( (item:any)=>item.pinyin.substring(0,1).toUpperCase()===letterArr[m])
            cityitems.length && newlist.push({
                title:letterArr[m],
                items:cityitems
            })
        }
        // console.log(newlist)

        return newlist
    }

    useEffect(() => {
        fetch("https://m.maizuo.com/gateway?k=2145459", {
            headers: {
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.2.0","e":"16395416565231270166529","bc":"110100"}',
                'X-Host': 'mall.film-ticket.city.list'
            }
        })
        .then(res=>res.json())
        .then(res=>{
            // console.log(res.data.cities)
            setlist(filterCity(res.data.cities))

            
        })
    }, [])

    const changeCity = (item)=>{
        console.log(item.name,item.cityId)
        history.push("/cinema")
        修改reducer详见下面6小节
    }
    return (
        <div style={{ height: window.innerHeight }}>
        <IndexBar>
          {list.map( (item:any) => {
            const { title, items } = item
            return (
              <IndexBar.Panel
                index={title}
                title={title}
                key={title}
              >
                <List>
                  {items.map((item:any, index:number) => (
                    <List.Item key={index} onClick={()=>changeCity(item)}>{item.name}</List.Item>
                  ))}
                </List>
              </IndexBar.Panel>
            )
          })}
        </IndexBar>
      </div>
    )
}

```

#### 6.dva集成

按目录约定注册 model，无需手动 app.model

文件名即 namespace，可以省去 model导出的namespace key

无需手写 router.js，交给 umi处理，支持 model和 component 的按需加载

内置query-string 处理，无需再手动解码和编码

内置 dva-loading 和 dva-immer，其中 dva-immer需通过配置开启(简化 reducer 编写)

##### 展示model管理redux的公共数据

**第一个案例：管理公共数据reducer- 同步情况**

在src下新建models文件夹，命名固定，约定。文件名就是空间名，或者js中，指定了就以指定为准。

![](.\img\约定公共数据.png)

 写好models后，开始使用。

**city页面**

触发reducer事件

```react
function City(props:any) {
...
const changeCity = (item)=>{
        console.log(item.name,item.cityId)

        // 修改store state中的状态
        props.dispatch({
          type:"city/changeCity",  //这个写法：不加命名空间 谁知道你使用的是哪个里面的
          payload:{
            cityName:item.name,
            cityId:item.cityId
          }
        })
        history.push("/cinema")
    }
```

**cinema电影展示页面**

使用公共数据

```react
import { NavBar } from 'antd-mobile'
import { SearchOutline } from 'antd-mobile-icons'
import {connect} from 'dva' //高阶组件包装后 注入redux的方法和属性

function Cinema(props:any) {
    console.log(props,'触发了')
    return (
        <div>
            <NavBar onBack={()=>{
                // console.log("click")
                props.history.push(`/city`)
            }} back={props.cityName} backArrow={false} right={<SearchOutline />}>标题</NavBar>
            Cinema
        </div>
    )
}

export default connect((state:any)=>{

    // console.log(state)
    return {
        a:1,
        cityName:state.city.cityName  //city命名空间的名字
    }
})(Cinema)
```

逻辑链： 首先dispatch触发reducer, reducer修改自己的state,stete修改，触发使用页面刷新。电影页面再更新。

**第二个案例:管理公共数据 异步情况**

 使用方法和redux-sga类似

原来同步逻辑链 是 dispatch触发reduce；

现在是dispatch触发effects中的 ***getlist** ，由其获取数据，有其自行触发reducer, 后面都一样了。

代码演示如下：

models文件夹下

Cinema.ts

```javascript
export default {
    namespace: "cinema",
    state: {
        list: []
    },

    reducers:{
        clearList(prevState:any,action:any){
            return {
                ...prevState,
                list:[]
            }
        },
        changeList(prevState:any,action:any){
            return {
                ...prevState,
                list:action.payload
            }
        }
    },
    //
    effects: {
        *getList(action: any, obj: any):any {
            const { put, call } = obj
            var res = yield call(getListForCinema,action.payload.cityId)

            yield put({
                type:"changeList",
                payload:res
            })
        }
    }
}


async function getListForCinema(cityId) {
    // console.log(cityId)
    var res = await fetch(`https://m.maizuo.com/gateway?cityId=${cityId}&ticketFlag=1&k=6412143`, {
        headers: {
            'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.2.0","e":"16395416565231270166529"}',
            'X-Host': 'mall.film-ticket.cinema.list'
        }
    }).then(res=>res.json())

    // console.log(res)
    return res.data.cinemas
}
```

**Cinema页面**

触发页面&使用数据页面

```react
import {useEffect} from 'react'
import { NavBar,DotLoading } from 'antd-mobile'
import { SearchOutline } from 'antd-mobile-icons'
import {connect} from 'dva'

function Cinema(props:any) {
    // console.log(props)
    useEffect(() => {
        if(props.list.length===0){
            //取数据
            props.dispatch({
                type:"cinema/getList",
                payload:{
                    cityId:props.cityId
                }
            })
        }else{
            console.log("缓存")
        }
    }, [])
    return (
        <div>
            <NavBar onBack={()=>{
                // console.log("click")

                //清空cinema list，
                props.dispatch({
                    type:"cinema/clearList"
                })

                props.history.push(`/city`)
            }} back={props.cityName} backArrow={false} right={<SearchOutline />}>标题</NavBar>
            

            {
                props.loading && <div style={{ fontSize: 14,textAlign:"center" }}>
                <DotLoading />
            </div>
            }
            <ul>
                {
                    props.list.map( (item:any)=>
                    <li key={item.cinemaId}>{item.name}</li>    
                    )
                }
            </ul>
        </div>
    )
}

export default connect((state:any)=>{
     //console.log(state)// state.loading.global // true或false（见下图 截图）
    return {
        a:1,
        loading:state.loading.global,
        cityName:state.city.cityName,
        cityId:state.city.cityId,
        list:state.cinema.list
    }
})(Cinema)

```

Umi自动注册调试器，可以通过浏览器的那天network - >redux（如果安装了就会有）。

并且提供了一个loading 请求数据的boole值。自已可以利用来作为页面加载优化。



 

![](.\img\默认注册调试器.png)









##### React、umi和dva之间的关系

[关系](https://blog.csdn.net/halations/article/details/107505440)

[为什么要使用 Dva, Umi 等诸如此类的框架，相比 React 他们的优势在哪里？](https://www.zhihu.com/question/336798290/answer/3047625529)

Dva和Umi是基于React构建的框架，提供了额外的功能和功能。

react（https://react.docschina.org/）

umi--路由配置（https://umijs.org/）
dva--数据流方案（https://dvajs.com/guide/）

Umi和Dva都是基于React的框架，Umi主要以路由为主，Dva主要管理数据流。

Antd pro（https://pro.ant.design/docs/getting-started-cn）集成了umi、dva、antd的完整前端脚手架


网友评论：

A:如果你在阿里接触到dva，那么第一反应就是重构，根本没有办法维护，谁用谁知道；

B:个人不喜欢dva和umi，节省了整合成本，但是又提供了自己的一套约束和API，带来了额外的学习成本。

c: react:  (state) => UI

dva: react + redux + redux-saga + react-router + 其他

umi: react-router + webpack + babel；

dva和umi可能有疏漏，但大体是这个意思

**总结：**

umi是dva的增强化。他们是react的进一步封装。

优势就是开箱即用，省去了搭框架的时间。像这类框架/工具的缺点也很明显，学习成本是一方面，文档不完善也是一方面，更重要的是，越到后期，维护成本也越高，本身基于各种模块进行封装，让工具的复杂度提升。

回到这个问题本身，如果你只是想学习React，或者已经有一个团队搭建好了围绕React的各种基础设施，那就不需要考虑Dva这类的东西。但是如果你在几个人的小团队，需要快速的用React的技术栈搭建出生产环境中使用的前端工程，那么用这些框架其实是不错的选择。参考这些框架的设计也是学习提高的一个好途径。



### 10 nextJS

Vercel  美国公司，创立时间:2015年 。 

Next.js 的创造者 Guillermo Rauch，基于 Next.js，建立了一家名叫 Vercel 的企业。

nextjs 2016 年开源，Next.js 在 GitHub 上已经拥有超 10 万 star，下载量也突破了 2 亿。

[详情文章](https://www.duidaima.com/Group/Topic/IT/13760)

https://www.nextjs.cn/

https://www.nextjs.cn/docs/getting-started  中文文档

安装

```
npm install -g create-next-app   // 全局安装脚手架
```

创建项目

进入一个空文件夹 打开命令行

```
 create-next-app nextjs-demo
```

依次选择配置

```
            √ Would you like to use TypeScript? ... No
            √ Would you like to use ESLint? ... No
            √ Would you like to use Tailwind CSS? ... No
            √ Would you like to use `src/` directory? ... Yes
            √ Would you like to use App Router? (recommended) ... No
            √ Would you like to customize the default import alias? ... Yes
            Creating a new Next.js app in /home/develop/nodejs/nextjs-demo.

            Using npm.

            Initializing project with template: default


            Installing dependencies:
            - react
            - react-dom
            - next


            added 23 packages in 5s
            Initialized a git repository.

            Success! Created nextdemo at /home/develop/nodejs/nextjs-demo

```

**项目目录结构**

```
            ├── public
            │   ├── favicon.ico     # Favicon
            │   ├── next.svg
            │   └── vercel.svg
            ├── src
            │   ├── pages               # Page Router
            │   │   ├── api
            │   │   │   └── hello.js
            │   │   ├── _app.js
            │   │   ├── _document.js
            │   │   └── index.js        # home Page
            │   │
            │   └── styles
            │       ├── globals.css
            │       └── Home.module.css
            │
            ├── jsconfig.json           # JavaScript 配置文件
            ├── next.config.js          # Next.js 配置文件
            ├── package-lock.json       # 项目依赖和脚本（锁定），运行 npm install 后自动生成
            ├── package.json            # 项目依赖和脚本
            └── README.md
```

**启动项目**

```
npm run dev     启动
npm run build   打包
```





**React脚手架和next.js脚手架的对比和选择？**

在实际的生产开发中，目前在国内比较主流且使用较多的React脚手架是Create-React-App（简称CRA）和Next.js。

1. **Create-React-App (CRA)**: CRA 是由 React 官方团队维护的脚手架工具，它通过默认配置提供了一个简单易用的 React 开发环境。以下是国内使用CRA的一些原因：

- 简单易用：CRA 提供了一个现成、预配置好的开发环境，对初学者和小型项目来说是一个快速上手的选择。
- 社区支持好：CRA 是 React 官方推荐的脚手架，因此拥有大量活跃的社区支持和资源，很容易找到相关的文档和解决方案。
- 可扩展性：尽管 CRA 提供了默认配置，但也可以根据项目需求进行自定义配置，满足不同的开发需求。

2. **Next.js**: Next.js 是一个用于构建服务端渲染（SSR）和静态网站的 React 框架。以下是国内使用Next.js的一些原因：

- 服务端渲染(SSR)：Next.js 的核心功能之一是支持服务端渲染，这使得页面在服务器上被渲染并发送到客户端，从而加快首屏加载速度，并提供更好的 SEO。
- 功能丰富：Next.js 提供了很多有用的特性，如路由系统、静态文件服务、自动代码拆分和预渲染等功能，能够更好地支持复杂的前端应用需求。
- 部署简单：Next.js 提供了方便的部署选项，可以轻松将应用部署到各种平台，如云服务商或自己的服务器上。

需要注意的是，使用哪个脚手架取决于具体的项目需求和团队技术栈。CRA 适合快速搭建简单的 React 应用，而 Next.js 则适合需要服务端渲染、SEO 优化和更丰富功能的项目。建议在选择脚手架时，根据项目的规模、需求和团队的技术水平进行评估，并参考相关文档和案例进行选择。

补充：

**服务器端渲染和客户端渲染？**

简单来说就是，一个页面由css ,js html构成，页面构建的处理工作，由后台服务器完成，就是服务器端渲染，下载到web浏览器，由浏览器加载处理再显示页面，就是客户端渲染。

  下图也展现了各自的优缺点：

**服务器端渲染的优势：**  提高首屏加载速度；更好的SEO表现；提高设备兼容性；减轻客户端负担；

**服务器端渲染的挑战：** 服务器压力增加；开发复杂性增加；有限的动态交互；

[详情查看](https://baijiahao.baidu.com/s?id=1773459200120754267&wfr=spider&for=pc)



![](https://pics3.baidu.com/feed/4d086e061d950a7b21df28141e96f5d5f0d3c9cf.jpeg@f_auto?token=15a2f048552326c3bb0f0ab78e1e9977)





## 二十二 前端代理（反向代理）

官网：

 https://facebook.github.io/create-react-app/docs/proxying-api-requests-in-development

 引入插件

```
npm install http-proxy-middleware --save
```

src下创建 src/setupProxy.js文件，参数如下

```

const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) { app.use(
  '/api', createProxyMiddleware({
    target: 'http://localhost:5000', 
    changeOrigin: true,
   })
   );
};
表示：代理拦截/api开头的请求，并在其url前面加上http://localhost:5000域名。
```



案例：某眼电影接口

```
https://i.maoyan.com/#movie/.f-hot
```

请求待映列表数据，直接使用提示跨域。

```
https://i.maoyan.com/ajax/mostExpected?limit=10&offset=0&token=&optimus_uuid=B13246E07BC511EE8C86B72966AD43929DD65EA435C340D6A572D95977F59FCA&optimus_risk_level=71&optimus_code=10
```

项目配置如下：

setupProxy.js文件

```
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) {
  app.use(
    '/ajax',
    createProxyMiddleware({
      target: 'https://i.maoyan.com',
      changeOrigin: true,
    })
  );
};
```

组件如下:   

```
import React, {  Component } from 'react'
import axios from 'axios'
export default class Comingsoon extends Component {

  componentWillMount(){
    axios({
        url:"/ajax/mostExpected?limit=10&offset=0&token=&optimus_uuid=B13246E07BC511EE8C86B72966AD43929DD65EA435C340D6A572D95977F59FCA&optimus_risk_level=71&optimus_code=10", 
    }).then(res=>{
        // console.log(res.data.data.films) 成功返回数据
    
    })
  }
    render() {
        return (
            <div>
                Comingsoon
            </div>
        )
    }
}

```

## 二十三  css module

官网

https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet

引入背景：

react是单页面， 每个组件引入的css样式，编译时，会自动插入到index.html页面中，造成样式污染。

film.css

```
.father{
  border: 1px solid red;
}
```

film组件

```
import '../css/film.css' //导入 css模块，  webpack的支持。

        return (
                <div className='father'>导航栏</div>
```

子组件

```
  render() {
        return (
            <div className='father'>
                Comingsoon
            </div>
```

父组件引入的样式， 污染到了子组件。

解决方式：

file.css 文件名字，改造为film.module.css   规定写法

```
.father{
  border: 1px solid red;
  .child{
    color: yellow;
  }
}
#id{
  color: red;
}


私有样式文件中  写全局css   ；建议如果是项目全局css, 单独新建一个 common.css 比较好。
:global(.active){

}

```

film.js组件

```
import style from  '../css/film.module.css' //导入 css模块，  webpack的支持。

    render() {
        return (
            <div>
                <div className={style.father +" othercss"}>导航栏</div>  
                //变量写法 因为类名加后缀动态化 私有化


css 打印出来变量名字 和js相似
console.log(style)
{
father: 'film_father__HgGKs', 
child: 'film_child__2Bvwp', 
id: 'film_id__2TOI9'
}

```





## 二十四 项目中使用的小插件

### [NProgress](https://so.csdn.net/so/search?q=NProgress&spm=1001.2101.3001.7020) 的使用

NProgress 是前端轻量级 web 进度条插件

```
npm install nprogress --save
或
yarn add nprogress
CDN

https://unpkg.com/nprogress@0.2.0/nprogress.js

https://unpkg.com/nprogress@0.2.0/nprogress.css
```

NProgress 一般搭配路由守卫使用

```react
import NProgress from 'nprogress'   // 导入 nprogress
import '@/components/NProgress/nprogress.less'   // 导入样式，否则看不到效果

NProgress.configure({ showSpinner: true })   // 显示右上角螺旋加载提示

router.beforeEach((to, from, next) => { 
    NProgress.start()   // 开启进度条
    // some code ...
    NProgress.done()   // 关闭进度条
})

```

[相关可参考](https://blog.csdn.net/CEZLZ/article/details/108198402)

### react-loadable

一个动态导入加载组件的高阶组件.

reactjs性能优化，异步路由加载。

每个路由使用不同的chunk，没必要一次加载所以js

```
yarn add react-loadable -S
npm install react-loadable -S
```

#### 使用方式

```
注意路由引入的方式使用 import的方式引入 const Stark = () => import('views/Stark')
使用 la高阶组件包含 路由组件 component={la(Stark)}
```

示例

```react
import Loadable from 'react-loadable';
import Loading from './my-loading-component';

const LoadableComponent = Loadable({
  loader: () => import('./my-component'),
  loading: Loading,
});

export default class App extends React.Component {
  render() {
    return <LoadableComponent/>;
  }
}
打包后，每个组件打包一个chunkjs,这样提高了加载速度。
```



[相关查看](https://www.jianshu.com/p/3288bcd8d972)



## 二十五 react-router6













## 其他

### 常识性

现在最新18.2.0   ---2023.12.01

 *React* 16.8.0 *版本*开始*支持* hook 技术 

### react vscode快捷操作

 `rcc` 快速创建一个组件

```
import React, { Component } from 'react'

export default class Example extends Component {
    render() {
        return (
            <div>
                
            </div>
        )
    }
}
```

`rconst` 快速创建一个 constructor

```
constructor(props) {
    super(props)

    this.state = {
         
    }
}
```

`rcep` 快速创建一个组件

```
import React, { Component } from 'react'
import PropTypes from 'prop-types'

export class Example extends Component {
    static propTypes = {

    }

    render() {
        return (
            <div>
                
            </div>
        )
    }
}

export default Example
```

`rcredux` 快速创建一个 redux格式的类模

```
import React, { Component } from 'react'
import { connect } from 'react-redux'

export class Example extends Component {
    render() {
        return (
            <div>
                
            </div>
        )
    }
}

const mapStateToProps = (state) => ({
    
})

const mapDispatchToProps = {
    
}

export default connect(mapStateToProps, mapDispatchToProps)(Example)
```

clg 是 console.log()的快捷键



### 1.函数式组件的注意点 

如果页面有axios请求，放到useEffect中，在页面实际情况中，函数式组件可能会执行多次，以确保数据都更新过来了。为避免接口多次请求，务必遵守。

```
import React,{useEffect} from 'react'
import { show,hide } from '../redux/actionCreator/TabbarActionCreator'
import store from '../redux/store'

export default function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")

    useEffect(() => {
        // console.log("create")

        //store.dispatch  通知
        store.dispatch(hide())
        return () => {
            console.log("destroy")
            store.dispatch(show() )
        }
    }, [])

    return (
        <div>
            deteail
        </div>
    )
}
```

### 2.自定义DOM属性

[React](https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020) 16 之前会忽略不是把的HTML和SVG属性，现在React会把不识别的属性传递给DOM

React16之前：

```
 <div cust-attr="someting"></div>
```

  会被渲染成

```
<div></div>　
```

React 16渲染出来的节点：

```
<div cust-attr="someting"></div>　　
```

### 3. Portals

https://blog.csdn.net/sxww_zyt/article/details/129253485

### 4.错误处理

https://blog.csdn.net/sxww_zyt/article/details/129253482

### 5.render新的返回类型

React16之前，rende[r方](https://so.csdn.net/so/search?q=r方&spm=1001.2101.3001.7020)法必须返回单个元素。现在，render支持两种新的返回类型：数组(有React元素组成)和字符串。

```
render() {
 return [
    <li key="a">a</li>,
    <li key="b">b</li>,
    <li key="c">c</li>
 ]
}
```



```
render() {
 return  "just a string";
}
```

### 6.列表和Keys

渲染列表数据是非常常见的场景，例如做一个展示用户的列表，需要根据获取的用户数据进行渲染列表。

运行后控制台报错：应该为列表每一项添加key(一般使用列表数据的id作为key)，[React](https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020)用Key标记每个元素，当数据变化时，React可以通过key知道哪些元素发生变化，从而只渲染发生变化的元素，提高渲染效率。

```
<User info={item.info} handleClick={this.handleClick} key={item.id}/>

```

**不推荐使用索引作为key**，因为一旦列表中的数据发生重排，数据的索引也会改变，不利于react渲染。**列表元素的key不能重复，但只限于当前列表，不是全局唯一**。

### 7.事件处理

https://blog.csdn.net/sxww_zyt/article/details/129253483

### 8.实现自定义createElement和render

https://blog.csdn.net/sxww_zyt/article/details/132900693

### 9 静态资源问题

[参考](https://blog.csdn.net/sophieLV1993/article/details/106335737/)

方式一：将图片文件放置public文件夹中，img标签直接引入图片的绝对路径。

```
 <img src="/assets/logo.png" alt="" className="logo" />
```

方式二：通过css文件引入

注：引入的图片必须位于src文件夹内
1.创建src-resource文件夹,图片放置其中

```
background: url('../../resource/assets/img/login-bg.png') center center no-repeat;
background-size: 100% 100%;
```





### 10粒子效果背景

http://md-md-e867c335436d-fc.madewith.cn/136

### 11 Bodymovin 创建动画

```
Bodymovin 是一个将 Adobe After Effects 动画导出为 JSON 格式的工具，可以使得在 Web 上展示向量动画更加容易。我们可以使用 Bodymovin 这个开源 JavaScript 库来解析 Bodymovin 导出的 JSON 文件并将其渲染为 SVG 或 Canvas。使用 Bodymovin 可以轻松地在 Web 上展示流畅、高品质的向量动画效果，这对于前端开发来说是一大福音。

版权声明：本文为原创文章，版权由本站（JavaScript中文网）拥有，严禁未经允许复制、转载、传播、篡改等任何行为，如需转载，
npm install bodymovin
```

项目使用

```react
import React from 'react'
import bodymovin from 'bodymovin'

class Loading2 extends React.Component{
  componentDidMount(){
    const animData = {
      wrapper: document.querySelector('#animationWindow'),
      animType: 'svg',
      loop: true,
      prerender: true,
      autoplay: true,
      animationData:require('./data.json')
    };
    this.anim = bodymovin.loadAnimation(animData);
    this.anim.setSpeed(1.42);
  }
  componentWillUnmount(){
    this.anim = null
  }
  render(){
    return (
      <div  style={{width:'100%',height:'100%'}}>
        <div id="animationWindow" style={{width:'100%',height:'100%'}}/>
      </div>
    )
  }
}
export default Loading2
```

### 12 项目端口号修改

https://blog.csdn.net/weixin_45289656/article/details/128458357

第一种方式：

node_modules里面有个react-scripts文件夹，找到scripts，再start.js文件，这里有HOST配置。

第二种方式：

这个方法就相对简单了 我们每次创建项目都会有一个package.json文件 ，这个文件是记录我们项目安装包的文件

找到这段调试代码修改start 给他加上一个PORT值 如下图所示

```react

  "scripts": {
    "start": "set PORT=8080  react-scripts start",   <---重点
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },

```

### 13项目自定义环境变量

前端项目开发一般会区分三个环境：(测试环境test一般很少用)

本地环境（及开发环境）— development，

生产环境 — production。



项目使用区分dev 和prod

本项目配置：

```
react18   react脚手架创建的项目
```



#### 一、建立.env文件

如图所示，分别建立.env.development和.env.production两个文件，文件内容为`REACT_APP_ENV = 'XXX'`。命名最好严格保持一致，react只能识别到以REACT_APP开头的属性作为环境变量。

![](https://img-blog.csdnimg.cn/152386c0859d4595b601c1a91406f5a9.png)

#### 二  如何在代码中使用环境变量

比如封装axios，本地使用测试接口，打包使用线上接口。此时我们可以直接使用`process.env.REACT_APP_ENV`这个属性来判断：

**![](https://img-blog.csdnimg.cn/4cad825bf7ab4872b5417dbbaa0ac175.png)**

#### 三 如果部署上线为空页面

路由问题【修改BrowserRouter为HashRouter】

在package.json中配置homepage，防止访问不到对应的打包资源

![](https://img-blog.csdnimg.cn/bf49f173c9094f97818508a2dbe4f10d.png)



参考文章

[react配置环境变量](https://blog.csdn.net/yutingwu816/article/details/128787048)

[显示为空](https://blog.csdn.net/qq_40661003/article/details/125916461?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-125916461-blog-122555527.235%5Ev39%5Epc_relevant_anti_vip_base&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-125916461-blog-122555527.235%5Ev39%5Epc_relevant_anti_vip_base&utm_relevant_index=1)



### 14 项目不用重新打包，修改接口域名

#### 第一种方法：

​       实质就是把本在项目中的接口参数，把url变量，放到public 这个静态的，对外暴露的文件中。

好处：不用重新打包。

坏处： 浏览器中可以查到这个js，要确保部署环境安全。

#### 第二种方法：

也可以参考如下

[将url置于windown.xx下](https://blog.csdn.net/qq_31281245/article/details/127408052?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-127408052-blog-112755889.235%5Ev39%5Epc_relevant_anti_vip_base&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-127408052-blog-112755889.235%5Ev39%5Epc_relevant_anti_vip_base&utm_relevant_index=1)



### hooks中记住状态的方式

useRef

### 关于生命周期

*1.类组件 Class Component* 有生命周期概念。

2.函数组件*Function Component* 不存在生命周期，

默认不能使用生命周期 如果要使用 那么就要使用HOOK来完成。

react16.8版本之后新增的一个概念

HOOK---useEffect

**useEffect就可以让函数组件使用生命周期---他会在 挂载完毕 修改完毕 准备销毁 这三个阶段都触发**

语法：

```javascript
useEffect(第一个参数是一个函数,第二个参数是一个数组)
```

### 15 SPA和MPA

SPA单页面  单页Web应用（single page web application，*SPA*）

MPA多页面应用（`Multi-Page Application`）简单的说就是指一个应用中有多个页面，页面跳转时是整页刷新。

### 16 react项目的一般跨域配置

https://create-react-app.dev/docs/proxying-api-requests-in-development

Back-End Integration > Proxying in Development 位置

src下新建跨域js 

```
src/setupProxy.js
```

安装插件

```
$ npm install http-proxy-middleware --save
$ # or
$ yarn add http-proxy-middleware
```

配置js

```react
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) {
  app.use(
    '/api',
    createProxyMiddleware({
      target: 'http://localhost:5000',
      changeOrigin: true,
    })
  );
};
```

修改配置后，重启。

演示跨域  猫眼电影https://i.maoyan.com/#movie















## 存疑问题：

这是什么写法  类组件吗

```
const Child:React.FC<IProps> = (props)=>{
    return <div>child-{props.name}</div>
}
```

React源码阅读—React.Children.map

