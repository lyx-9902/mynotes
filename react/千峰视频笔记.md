# react全家桶

## 一 React 介绍

**1.**  **React** **起源与发展**

React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。

**2.**  **React 与传统 **MVC** **的关系**

轻量级的视图层**库**！*A JavaScript library for building user interfaces*

React不是一个完整的MVC框架，最多可以认为是MVC中的V（View），甚至React并不非常认可MVC开发模式；React 构建页面 UI 的库。可以简单地理解为，React 将界面分成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，就成了我们的页面。

**3.**  **React** 特性

特点:
1.声明式设计-React采用声明范式，可以轻松描述应用。

2.高效-React通过对DOM的模拟(虚拟dom)，最大限度地减少与DOM的交互

3.灵活-React可以与已知的库或框架很好地配合。

4.JSX-JSX是JavaScript 语法的扩展

5.组件-通过 React构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。

6.单向响应的数据流- React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单

**4.** **虚拟** **DOM**

传统dom更新:
真实页面对应一个DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作DOM来进行更新

![](.\img\微信截图_20231113164804.png)

虚拟dom:
DOM操作非常昂贵。我们都知道在前端开发中，性能消耗最大的就是 DOM 操作，而且这部分代码会让整体项目的代码变得难以维护。React 把真实 DOM 树转换成JavaScript 对象树，也就是 Virtual

![](.\img\微信截图_20231113164916.png)



## 二 create-react-app

全局安装create-react-app

```
npm install -g create-react-app
```

创建一个项目

create-react-app your-app 注意命名方式

Creating a new React app in /dir/your-app.

Installing packages. This might take a couple of minutes. 安装过程较慢，

Installing react, react-dom, and react-scripts...

如果不想全局安装，可以直接使用npx

```
npx create-react-app myapp 也可以实现相同的效果
```

这需要等待一段时间，这个过程实际上会安装三个东西

![img](file:///C:/Users/15612/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)react: react的顶级库

![img](file:///C:/Users/15612/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)react-dom:  因为react有很多的运行环境，比如app端的react-native,  我们要在web上运行就使用

react-dom

![img](file:///C:/Users/15612/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)react-scripts: 包含运行和打包react应用程序的所有脚本及配置出现下面的界面，表示创建项目成功:

```
Success! Created your-app at /dir/your-app

Inside that directory, you can run several commands:

npm start

Starts the development server.

npm run build

Bundles the app into static files for production.
npm test
Starts the test runner.


npm run eject
Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:


cd your-app npm start

Happy hacking!
```

生成项目的目录结构如下:“
根据上面的提示，通过cd your-app 命令进入目录并运行npm start 即可运行项目。

生成项目的目录结构如下

```
├── README.md   使用方法的文档
├── node_modules    所有的依赖安装的目录
├── package-lock.json  锁定安装时的包的版本号,保证团队的依赖能保证一致。
├── package.json
├── public        静态公共目录
└── src            开发用的源代码目录

```

![img](file:///C:/Users/15612/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png)npm安装失败

切换为npm镜像为淘宝镜像“

使用yarn，如果本来使用yarn还要失败，还得把yarn的源切换到国内

如果还没有办法解决，请删除node.modules及package-lockjson然后重新执行npm install 命令

再不能解决就删除nodemodules及package-lock.json的同时清除npm缓存npm cacheclean --force

之后再执行npm install 命令

## 三 编写一个react应用程序

react开发需要引入多个依赖文件：react.js、react-dom.js，分别又有开发版本和生产版本，create- react-app里已经帮我们把这些东西都安装好了。把通过CRA创建的工程目录下的src目录清空，然后在里面重新创建一个index.js. 写入以下代码:

```react
// 从 react 的包当中引入了 React。
//只要你要写 React.js 组件就必须引入React, 因为react里有一种语法叫JSX，稍后会讲到JSX，要写JSX，就必须引入React
import React from 'react'
// ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了。它是从 react-dom 中引入的，而不是从 react 引入。
import ReactDOM from 'react-dom'

// ReactDOM里有一个render方法，功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的元素上
ReactDOM.render(
// 这里就比较奇怪了，它并不是一个字符串，看起来像是纯 HTML 代码写在 JavaScript 代码里面。语法错误吗？这并不是合法的 JavaScript 代码, “在 JavaScript 写的标签的”语法叫 JSX- JavaScript XML。
<h1>欢迎进入React的世界</h1>,
// 渲染到哪里
document.getElementById('root')
)

```

<React.StrictMode> 

目前有助于识别不安全的生命周期
关于使用过时字符串refAPI的警告

检测意外的副作用
检测过时的 context AP



## 四 JSX语法与组件

## 1  JSX语法

JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不会带来任何副作用，反而会让代码更加直观并易于维护。 编译过程由Babel 的 JSX 编译器实现

**JSX不是必需的(但应首选JSX语法)**

JSX只是React.createElement(component,props,...children)的[语法糖](https://so.csdn.net/so/search?q=语法糖&spm=1001.2101.3001.7020)，所有的JSX语法最终都会被转换成对这个方法的调用。

```react
//JSX语法
const element = <div className='foo'>Hello,world</div>
 
//转换后
const element = React.createElement('div',{className:'foo'},'Hello,React')

```



https://reactjs.org/docs/hello-world.html

原理是什么呢？

要明白JSX的原理，需要先明白如何用 JavaScript 对象来表现一个 DOM 元素的结构?看下面的DOM结构

```react
<div class='app' id='appRoot'>
    <h1 class='title'>欢迎进入React的世界</h1>
    <p>
       React.js 是一个帮助你构建页面 UI 的库
    </p>
</div>
```

上面这个 HTML 所有的信息我们都可以用 JavaScript 对象来表示

```javascript
{
tag: 'div',
attrs: { className: 'app', id: 'appRoot'},
    children: [
{
    tag: 'h1',
    attrs: { className: 'title' }, 
    children: ['欢迎进入React的世界']
},
{
  tag: 'p', attrs: null,
  children: ['React.js 是一个构建页面 UI 的库']
}
]
}
```

但是用 JavaScript 写起来太长了，结构看起来又不清晰，用 HTML 的方式写起来就方便很多了。于是 Reactjs 就把 JavaScript 的语法扩展了一下，让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法，这样写起来就方便很多了。编译的过程会把类似 HTML的 JSX结构转换成 JavaScript 的对象构。

下面代码

```react
import React from 'react'
import ReactDOM from 'react-dom'

class App extends React.Component { 
 render () {
    return (
    <div className='app' id='appRoot'>
        <h1 className='title'>欢迎进入React的世界</h1>
        <p>
          React.js 是一个构建页面 UI 的库
        </p>
    </div>
    )
}}


ReactDOM.render(<App />, document.getElementById('root'))
```

编译之后将得到这样的代码

```react
import React from 'react'
import ReactDOM from 'react-dom'


class App extends React.Component {
    render() {
        return (React.createElement(
            "div",
            {className: 'app', id: 'appRoot'},
            React.createElement("h1",{ className: 'title' }, "欢迎进入React的世界"),
            React.createElement("p", null,"React.js 是一个构建页面 UI 的库" )
        )
        )
    }
}

ReactDOM.render(React.createElement(App),
    document.getElementById('root')
)
```

React.createElement会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性
还有子元素等，语法为

```
React.createElement( 
type,
[props], 
[...children]
)

```

所谓的 JSX 其实就是 JavaScript 对象，所以使用 React 和JSX 的时候一定要经过编译的过程

JSX一使用react构造组件，bable进行编译 -->JavaScript对象 一  ReactDOM.render()->DOM元素 一>插入页面

## 2. Class组件

ES6的加入让JavaScript直接支持使用class来定义一个类，react创建组件的方式就是使用的类的继承，ES6 Class

是目前官方推荐的使用方式，它使用了ES6标准语法来构建，看以下代码

```javascript
import React from 'react'
import ReactDOM from 'react-dom'

class App extends React.Component { 
    render () {
            return ( <h1>欢迎进入React的世界</h1>)
            }
        }

ReactDOM.render(
<App />, document.getElementById('root')
)

```

es6 Class组件其实就是一个构造器,每次使用组件都相当于在实例化组件，像这样

```
import React from 'react'
import ReactDOM from 'react-dom'

class App extends React.Component {
    render() {
        return (
            <h1>欢迎进入{this.props.name}的世界</h1>
        )
    }
}

const app = new App({
    name: 'react'
}).render()


ReactDOM.render(app,
    document.getElementById('root')
)
```

## 3.函数式组件

```react
import React from 'react'
import ReactDOM from 'react-dom'

const App = (props) => <h1>欢迎进入React的世界</h1> 
ReactDOM.render(
// React组件的调用方式
<App />, document.getElementById('root')
)
```

这样一个完整的函数式组件就定义好了。但要**注意！注意！注意！**组件名必须**大写**，否则报错

## 4.组件的样式

### 行内样式

想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现

```react
//  注意这里的两个括号，第一个表示我们在要JSX里插入JS了，第二个是对象的括号

 <p style={{color:'red', fontSize:'14px'}}>Hello world</p>
```

行内样式需要写入一个样式对象，而这个样式对象的位置可以放在很多地方，例如 render函数里、组件原型上、外链js文件中

使用class

React推荐我们使用行内样式，因为React觉得每一个组件都是一个独立的整体

其实我们大多数情况下还是大量的在为元素添加类名，但是需要注意的是,class需要写成 className

因为毕竟是在写类js代码，会收到js规则的现在，而class是关键字

```
<p className="hello">Hello world</p>
```

注意:	

```
class ==> className , for ==> htmlFor(label)
```

## 5 事件处理

### 1 绑定事件

采用关于+事件名的方式来绑定一个事件，注意，这里和原生的事件是有区别的，原生的事件全是小写 onclick，React里的事件是驼峰onClick，React 的事件并不是原生事件，而是合成事件。

### 2 事件handler的写法

a 直接在render里写行内的箭头函数(不推荐)

b在组件内使用箭头函数定义一个方法(推荐)

c 直接在组件内定义一个非箭头函数的方法，然后在render里直接使用 onclick=[thishandleclick,bind(this)}  (不推荐)

d 直接在组件内定义一个非箭头函数的方法，然后在constructor里bind(this)(推荐

### 3 Event 对象

和普通浏览器一样，事件handler会被自动传入一个 evente对象，这个对象和普通的浏览器 event 对象所包含的方法和属性都基本一致。不同的是 React中的 event 对象并不是浏览器提供的，而是它自己内部所构建的。它同样具有 event.stopPropagation、event.preventDefault 这种常用的方法

## 6.Ref的应用

a  给标签设置 ref="username"

通过这个获取this.refs.username , ref可以获取到应用的真实dom

b 给组件设置  ref="username"

通过这个获取 this.refs.username  ,ref可以获取到组件对象

###    **新的写法**

```
myRef = React.createRef()

     <div ref={this.myRef}>hello</div>

             访问this.myRef.current

```



## 五 组件的数据挂载方式

**状态(state)**

状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态的目的就是为了在不同的状态下使组件的显示不同(自己管理）

### 拓展解释：

#### a 设计合适的state

state必须能代表一个组件UI呈现的完整状态集，代表一个组件UI呈现的最小状态集。

state必须能代表一个组件UI呈现的完整状态集又可以分成两类数据：用作渲染组件时使用到的数据的来源，用作组件UI展现形式的判断依据：

```react
class Hello extends Component {
    constructor(props) {
        super(props);
        this.state = {
            user: 'react', //用作渲染组件时使用到的数据的来源
            display: true //用作组件UI展现形式的判断依据
        }
    }
    render() {
        return (
            <div>
                {
                    this.state.display ? <h1>{this.state.user}</h1> : <></>
                }
            </div>
        )
    }
}
export default Hello;
```

#### b 普通属性

在es6中，可以使用this.属性名定义一个class的属性，也可以说属性是直接挂载在this下的一个变量。因此，state和props实际上也是组件的属性，只不过是react在Component class中预定义好的属性。

除了state和props以外的其他组件属性称为组件的普通属性。

```react
class Hello extends Component {
    constructor(props) {
        super(props);
        this.timer = null; //普通属性
        this.state = {
            date: new Date()
        }
        this.updateDate = this.updateDate.bind(this);
    }
    componentDidMount(){
        this.timer = setInterval(this.updateDate, 1000);
    }
    componentWillUnmount(){
        clearInterval(this.timer);
    }
    updateDate(){
        this.setState({
            date: new Date()
        })
    }
    render() {
        return (
            <div>
                <h1>{this.state.date.toString()}</h1>
            </div>
        )
    }
}
export default Hello;


```

组件中用到的一个变量是否应该作为state可以通过下面4条依据判断：

这个变量是否通过props从父组件中获取？如果是，那么它不是一个状态
这个变量是否在生命周期中都保持不变？如果是，那么它不是一个状态
这个变量是否可以通过其他状态(state)或者属性(props)计算得到？如果是，那么它不是一个状态
这个变量是否在组件的render方法中使用？如果不是，那么它不是一个状态，这种情况更适合定义为组件的一个普通属性.

#### c 正确修改state

①不能直接修改state，需要使用setState()

②state的更新是异步的

React会将多次setState的状态合并成一次状态修改，不能依赖当前的state计算下一个state(props也是异步的)。

例如：连续两次点击加入购物车，实际数量只会加1，在React合并多次修改为1次的情况下，相当于执行了：

```react
Object.assign(
    previousState,
    {quantity: this.state.quantity + 1},
    {quantity: this.state.quantity + 1}
)
```

这种情况下，可以使用另一个接收一个函数作为参数的setState，这个函数有两个参数，第一个是当前修改后的最新状态的前一个状态preState，第二个参数是当前最新的属性props:

```
this.setState((preState,props) => ({
    quantity: preState.quantity + 1;
}))
```

③state的更新是一个合并的过程

④state与不可变对象

直接修改state，组件不会render；state包含的所有状态都应该是不可变对象，当state中某个状态发生变化时，应该重新创建这个状态对象，而不是直接修改原来的状态。创建新的状态有以下三种方法：

状态的类型是不可变类型(数字、字符串、布尔值、null、undefined)：因为状态是不可变类型，所以直接赋一个新值即可
状态的类型是数组：可以使用数组的concat或者es6的扩展语法，slice方法、filter方法。不能使用push、pop、shift、unshift、splice等方法修改数组类型的状态，因为这些方法会在原数组基础上修改。

```
this.setState((preState) => ({
    arr: [...preState.arr,'react'];
}))
this.setState((preState) => ({
    arr: preState.arr.concat(['react'])
}))
```

- 状态的类型是普通对象(不包含字符串、数组)：使用ES6的Object.assgin方法或者对象扩展语法.



### **(1)**  **定义**  **state**

第一种方式

```
import React, { Component } from 'react' 
import ReactDOM from 'react-dom'

class App extends Component { 
    state = {
      name: 'React', isLiked: false
    }
    render () { 
        return (
        <div>
            <h1>欢迎来到{this.state.name}的世界</h1>
                <button>
                {
                this.state.isLiked ? '❤取消' : '🖤收藏'
                }
                </button>
        </div>
        )
       }
    }
ReactDOM.render(
<App/>, document.getElementById('root')
)

```

另一种方式

```
import React, { Component } from 'react' 
import ReactDOM from 'react-dom'

class App extends Component { 
    constructor() {
        super() 
        this.state = {
        name: 'React', isLiked: false
        }
    }
    
        render () { 
        return (
            <div>
               <h1>欢迎来到{this.state.name}的世界</h1>
                <button>
                {this.state.isLiked ? '❤取消' : '🖤收藏'}
                </button>
            </div>
        )
        }
    }
ReactDOM.render(
<App/>, document.getElementById('root')
)

```

this.state 是纯js对象,在vue中，data属性是利用Object.defineProperty 处理过的，更改data的数据的时候会触发数据的getter 和setter ，但是React中没有做这样的处理，如果直接更改的话， react是无法得知的，所以，需要使用特殊的更改状态的方法 setState 。

### **(2)**  **setState**

isLiked 存放在实例的 states对象当中，组件的render 函数内，会根据组件的states的中的isLiked 不同显示“取消"或“收藏"内容。下面给button加上了点击的事件监听。

```
import React, { Component } from 'react' import ReactDOM from 'react-dom'

class App extends Component { 
    constructor() {
        super() 
        this.state = {
        name: 'React', isLiked: false
        }
    }

    handleBtnClick = () => { this.setState({
    isLiked: !this.state.isLiked
    })
  }
  
render () { 
    return (
    <div>
         <h1>欢迎来到{this.state.name}的世界</h1>
        <button onClick={this.handleBtnClick}>
            {
            this.state.isLiked ? '❤取消' : '🖤收藏'
            }
        </button>
    </div>
    )
    }
}
ReactDOM.render(
<App/>, document.getElementById('root')
setState 有两个参数
```

第一个参数可以是对象，也可以是方法return一个对象，我们把这个参数叫做 updater

参数是对象

```
this.setState({
isLiked: !this.state.isLiked
})
```

参数是方法

```
this.setState((prevState, props) => { return {
        isLiked: !prevState.isLiked
        }
})

```

注意的是这个方法接收两个参数，第一个是上一次的state,  第二个是props .

setState 是异步的，所以想要获取到最新的state，没有办法获取，就有了第二个参数，这是一个可选的回调函数

```
this.setState(
(prevState, props) => { 
return {
    isLiked: !prevState.isLiked
}, 
    () => {
    console.log('回调里的',this.state.isLiked)
    }
)
console.log('setState外部的',this.state.isLiked)

```

### (3)属性(props)

props 是正常是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更改，但是你可以通过父组件主动重新渲染的方式来传入新的属性是描述性质、特点的，组件自己不能随意更改。

之前的组件代码里面有props 的简单使用，总的来说，在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为组件参数来接收props :

```
(1) 在组件上通过key=value 写属性,通过this.props获取属性,这样组件的可复用性提高了.
(2) 注意在传参数时候，如果写成isShow="true" 那么这是一个字符串,如果写成isShow={true} 这个是布尔值。
(3) {...对象} 展开赋值
(4) 默认属性值

*.defaultProps = {
     默认都是空，或者写入
   }
  static defaultProps = { 
  myname:"默认的myname", myshow:true
}

(5) prop-types 属性验证
import propTypes from "prop-types";

*.propTypes={
     name:propTypes.string, age:propTypes.number
}

static propTypes={ 
        myname:propTypes.string,
        myshow:propTypes.bool
    }

```

### (4)属性vs状态

相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）

不同点：

\1.    属性能从父组件获取，状态不能

\2.    属性可以由父组件修改，状态不能

\3.    属性能在内部设置默认值，状态也可以，设置方式不一样

\4.    属性不在组件内部修改，状态要在组件内部修改

\5.    属性能设置子组件初始值，状态不可以

\6.    属性可以修改子组件的值，状态不可以



state的主要作用是用于组件保存、控制、修改自己的可变状态。 state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state  是一个局部的、只能被组件自身控制的数据源。

state中状态可以通过 this.setState 方法进行更新， setState 会导致组件的重新渲染。

props的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 ，否则组件的不变。

没有state-的组件叫无状态组件(stateless component)，设置了 state的叫做有状态组件(stateful component)。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。

### (5)渲染数据

条件渲染

```
{
condition ? '渲染列表的代码' : '空空如也'
}
```

列表渲染

```
// 数据
const people = [
{ id: 1,name: 'Leo', age: 35}, 
{id: 2,name: 'XiaoMing', age: 16
}]
// 渲染列表
{
    people.map(person => { return (
        <dl key={person.id}>
        <dt>{person.name}</dt>
        <dd>age: {person.age}</dd>
        </dl>
        )
    })
}

```

React的高效依赖于所谓的Virtual-DOM，尽量不碰DOM。对于列表元素来说会有一个问题:元素可能会在一个列表中改变位置。要实现这个操作，只需要交换一下DOM位置就行了，但是React并不知道其实我们只是改变了元素的位置，所以它会重新渲染后面两个元素(再执行Vitual-DOM )，这样会大大增加DOM操作。但如果给每个元素加上唯一的标识，React就可以知道这两个元素只是交换了位置，这个标识就是key，这个key必须是每个元素唯一的标识

dangerouslySetInnerHTML

对于富文本创建的内容，后台拿到的数据是这样的

```
content = "<p>React.js是一个构建UI的库</p>"
```

处于安全的原因，React当中所有表达式的内容会被转义，如果直接输入，标签会被当成文本。这时候就需要使用dangerouslyS.etHTML属性，它允许我们动态设置innecHTML

```
import React, { Component } from 'react' import ReactDOM from 'react-dom'

class App extends Component { 
       constructor() {
        super() this.state = {
            content : "<p>React.js是一个构建UI的库</p>"
        }
    }
render () { 
   return (
        <div
        // 注意这里是两个下下划线  __html 
        dangerouslySetInnerHTML={{ __html: this.state.content}}
        />
        )
     }
}

ReactDOM.render(
<App/>, document.getElementById('root')
)

```



## 六表单中的受控租金按和非受控组件

### 非受控组件:

表单元素在React中自身维护一些状态，这些状态默认情况下是不受react控制的，这类状态不受react控制的表单元素称为非受控组件。

### 受控组件:

在React中，状态的修改必须通过组件的state，

注意: 

另一种说法（广义范围的说法），React组件的数据渲染是否被调用者传递的 props 完全控制，控制则为受控组件，否则非受控组件。

### 演示

非受控组件有悖于这一原则，为了让表单元素的状态变更也能通过组件的state管理，React使用受控组件的技术达到这一目的。

**受控组件**

如果一个表单元素的值是由React来管理的，那么它就是一个受控组件。对于不同的表单元素，React的控制方法略有不同，常用的三类表单元素控制方式是：

①文本框

包含类型为text的input和textarea元素，它们受控的原理是：通过value属性设置表单元素的值，通过onChange时间监听值的变化，并将变化同步到React组件的state中：






## 七 组件通信的方式

### **1.**   父子组件通信方式

(1)    父传子  看props小节

父组件中，在引用的子组件上，k：v方式传递，

子组件使用props接收。

(2)     传递数据(父传子)与传递方法(子传父)

```
传递方法(子传父) 
父组件把修改自己数据的方法，通过变量，使用子组件传递过去。子组件使用this.props接受
import React, { Component } from 'react'

子组件
class Navbar extends Component{
    render(){
        return <div style={{background:"red"}}>
            <button onClick={()=>{
                   console.log("子通知父， 让父的isSHow 取反。",this.props.event) 

                   this.props.event() //调用父组件传来啊的回调函数
            }}>click</button>
            <span>navbar</span>
        </div>
    }
}
父组件
export default class App extends Component {
    state = {
        isShow:false
    }

    handleEvent = ()=>{
        this.setState({
            isShow:!this.state.isShow
        })
        // console.log("父组件定义的event事件")
    }
    render() {
        return (
            <div>
                <Navbar event={this.handleEvent}/>
                {/* <button onClick={()=>{
                    this.setState({
                        isShow:!this.state.isShow
                    })
                }}>click</button> */}
                {this.state.isShow && <Sidebar/>}
            </div>
        )
    }
}
```

(2)     ref标记 (父组件拿到子组件的引用，从而调用子组件的方法)

在父组件中清除子组件的input输入框的value值。**this.refs.form.reset()**



### **2.**   非父子组件通信方式

#### **(1)**   **状态提升**  **(**中间人模式**)**

React中的状态提升概括来说,就是将多个组件需要共享的状态提升到它们最近的父组件上.在父组件上改变这个状态然后通过props分发给子组件. （实质还是父子通信方式）

```
import React, { Component } from 'react'
import axios from 'axios'
import './css/03-communination.css'
export default class App extends Component {

    constructor(){
        super()
        this.state = {
            filmList:[],
            info:""
        }
    }
    数据来自互联网
    https://m.maizuo.com/v5/#/films/nowPlaying
    componentDidMount(){
        axios.get(`/test.json`).then(res=>{
            console.log(res.data.data.films)
            this.setState({
                filmList:res.data.data.films
            })
        })
    }

    render() {
        return (
            <div>
                {/* {this.state.info} */}
                {
                    this.state.filmList.map(item=>
                        <FilmItem key={item.filmId} {...item} onEvent={(value)=>{
                            // console.log("父组件接受",value)

                            this.setState({
                                info:value
                            })
                        }}></FilmItem>    
                    )
                }


                <FilmDetail info={this.state.info}></FilmDetail>
            </div>
        )
    }
}

/*受控组件*/
class FilmItem extends Component{
    render(){
        // console.log(this.props)
        let {name, poster,grade,synopsis}  = this.props
        return <div className="filmitem" onClick={()=>{
            // console.log(synopsis)
            this.props.onEvent(synopsis)
        }}>
            <img src={poster} alt={name}/>
            <h4>{name}</h4>
            <div>观众评分：{grade}</div>
        </div>
    }
}

class FilmDetail extends Component{
   
    render(){
        console.log(this.props)
        return <div className="filmdetail">
            {this.props.info}
        </div>
    }
}
```



#### **(2)**   发布订阅模式实现

纯js实现 ，谁订阅，谁接受，抛弃了父子孙关系。

```
/*
 * @作者: kerwin
 * @公众号: 大前端私房菜
 */
import React, { Component } from 'react'

export default class App extends Component {
    render() {
        return (
            <div>
                app
            </div>
        )
    }
}

//调度中心
var bus = {

    list:[],
    //订阅
    subscribe(callback){
        // console.log(callback)

        this.list.push(callback)
    },

    //发布
    publish(text){
        //遍历所有的list， 将回调函数执行
        // console.log(this.list)

        this.list.forEach(callback=>{
            callback && callback(text)
        })
    }
}


// 订阅者
bus.subscribe((value)=>{
    console.log("11111",value)
})

bus.subscribe((value)=>{
    console.log("2222",value)
})



//发布者

setTimeout(()=>{
    bus.publish("男人看了沉默111")
},0)


// Redux 基于订阅发布 

```



#### **(3)**   **context** 状态树传参

```
import React, { Component } from 'react'
import axios from 'axios'
import './css/03-communination.css'

const GlobalContext  = React.createContext() //创建context对象

export default class App extends Component {

    constructor(){
        super()
        this.state = {
            filmList:[],
            info:""
        }
        axios.get(`/test.json`).then(res=>{
            console.log(res.data.data.films)
            this.setState({
                filmList:res.data.data.films
            })
        })
    }

    render() {
        return (
            <GlobalContext.Provider value={{
                call:"打电话",
                sms:"短信",
                info:this.state.info,
                changeInfo:(value)=>{
                    this.setState( {
                        info:value
                    })
                }
            }}>
                <div>
                    {/* {this.state.info} */}
                    {
                        this.state.filmList.map(item=>
                            <FilmItem key={item.filmId} {...item} ></FilmItem>    
                        )
                    }


                    <FilmDetail ></FilmDetail>
                </div>
            </GlobalContext.Provider>
        )
    }
}

/*受控组件*/
class FilmItem extends Component{
    render(){
        // console.log(this.props)
        let {name, poster,grade,synopsis}  = this.props
        return (
        <GlobalContext.Consumer>
           {
                (value)=>{
                    console.log(value)
                    
                    return <div className="filmitem" onClick={()=>{
                        console.log(synopsis)
                        // this.props.onEvent(synopsis)

                        // value.info = "2222222"

                        // console.log(value)

                        value.changeInfo(synopsis)
                    }}>
                        <img src={poster} alt={name}/>
                        <h4>{name}</h4>
                        <div>观众评分：{grade}</div>
                    </div>
                }
           }
        </GlobalContext.Consumer>
        )    
    }
}

class FilmDetail extends Component{
    render(){
        return (
            <GlobalContext.Consumer>
                {
                    (value)=><div className="filmdetail">
                        detail-{value.info}
                    </div>
                }
            </GlobalContext.Consumer>
        )
    }
}
```







## 八 React生命周期

**只有类组件才有生命周期，函数组件没有生命周期**

###  1.初始化阶段

```
componentWillMount: render之前最后一次修改状态的机会

render: 只能访问this.props和this.state，不允许修改状态和DOM输出

componentDidMount: 成功render并渲染完成真实DOM之后触发，可以修改DOM
```

### 2.运行中阶段

```
componentWillReceiveProps: 父组件修改属性触发

shouldComponentUpdate: 返回false会阻止render调用

componentWillUpdate: 不能修改属性和状态

render: 只能访问this.props和this.state，不允许修改状态和DOM输出

componentDidUpdate: 可以修改DOM
```

### 3.销毁阶段

```
componentWillUnmount: 在删除组件之前进行清理操作，比如计时器和事件监听器
```

### 4.老生命周期的问题

(1)componentWillMount,在ssr中 这个方法将会被多次调用，所以会重复触发多遍，同时在这里如果绑定事件将无法解绑，导致内存泄漏， 变得不够安全高效逐步废弃。

(2) componentWilReceiveProps 外部组件多次频繁更新传入多次不同的 props，会导致不必要的异步请求

(3)componetWilupdate,更新前记录 DOM 状态，可能会做一些处理，与componentDidUpdate相隔时间如果长，会导致 状态不太信

### 5.新生命周期的替代

(1) getDerivedStateFromProps 第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父传子)返回一个对象作为新的state，返回null则说明不需要在这里更新state

```
//老的生命周期的写法 
componentDidMount() {
    if (this.props.value !== undefined) {
        this.setState({
            current: this.props.value
        })
    }
}
componentWillReceiveProps(nextProps){
    if (nextProps.value !== undefined) {
        this.setState({
            current: nextProps.value
        })
    }
}

// 新的生命周期写法
static getDerivedStateFromProps(nextProps, prevState) {
    const {type} = nextProps;
    // 当传入的type发生变化的时候，更新state
    if (type !== prevState.type) {
        return {
            type,
        };
    }
    // 否则，对于state不进行任何操作
    return null;
}
复制代码
```

 (2) 

getSnapshotBeforeUpdate 取代了 componetWillUpdate ,触发时间为update发生的时候，在render之后

dom渲染之前返回一个值，作为componentDidUpdate的第三个参数

```
//新的数据不断插入数据前面，  导致我正在看的数据向下走，如何保持可视区依旧是我之前看的数据呢？
getSnapshotBeforeUpdate(){
    return this.refs.wrapper.scrollHeight
}


componentDidUpdate(prevProps, prevState, preHeight) {
    //if(preHeight===200)return ;
    this.refs.wrapper.scrollTop += this.refs.wrapper.scrollHeight - preHeight
}


<div style={{ height: "200px", overflow: "auto" }}} ref="wrapper">
    <ul>
        .........
    </ul>
</div>
```







## 九 React Hooks

### 1 用hooks理由

1. 高阶组件为了复用，导致代码层级复杂

2. 生命周期的复杂
3. 写成functional组件,无状态组件 ，因为需要状态，又改成了class,成本高

### 2. useState(保存组件状态)

```
const [list,setList] = useState(["aa","bb","cc"])
结构出list变量， 和修改list的唯一指定方法setList

案例: 点击按钮num+1; 在实际页面效果中，由于每次刷新，num都会回到初始值，无法达到目的。
import React,{useState,useRef} from 'react'
export default function App() {
    var num = 20;
    const [list,setList] = useState(["aa","bb","cc"])
    
```

### 3. useEffect(处理副作用)和useLayoutEffect (同步执行副作用)

Function Component 不存在生命周期，所以不要把 Class Component 的生命周期概念搬过来试图对号入座。

```
useEffect(() => {
           //effect 渲染页面后执行
return () => {
         //cleanup  销毁时执行
};
}, [依赖的状态;空数组,表示不依赖])
```

不要对 Dependencies 撒谎, 如果你明明使用了某个变量，却没有申明在依赖中，你等于向 React 撒了谎，后果
就是，当依赖的变量改变时，useEffect 也不会再次执行, eslint会报警告

```
let id = props.match.params.myid useEffect(()=>{
axios.get(`/articles/${id}`).then(res => { settitle(res.data.title) setcontent(res.data.content) setcategory(res.data.category)
})
},[id])
```

**useEﬀect**和 **useLayoutEﬀect**  有什么区别？

**简单来说就是调用时机不同，**
useLayoutEffect **和原来** componentDidMount **&** componentDidUpdate **一致，在 react完成DOM更新后马上**同步**调用的代码，会阻塞页面渲染。而**
useEffect **是会在整个页面渲染完才会调用的代码**



### 4. useRef（是hooks一种，一般在**函数组件使用**）

作用是：记住状态

```
export default function App() {
    const mytext = useRef() // React.createRef()
    
    const handleAdd = ()=>{
        console.log(mytext.current.value) // 获取值
    }
 
  return (<div>
            <input ref={mytext}/> 
               <button onClick={handleAdd}>add</button>
```

官方建议优先使用useEffect

在实际使用时如果想避免**页面抖动**（在useEffect 里修改DOM很有可能出现）的话，可以把需要操作DOM的代码放在useLayoutEffect 里。在这里做点dom操作，这些dom修改会和
react 做出的更改一起被一次性渲染到屏幕上，只有一次回流、重绘的代价

### **5. useCallback(**记忆函数**)**

防止因为组件重新渲染，导致方法被重新创建 ，起到缓存作用*;* 只有第二个参数 变化了，才重新声明一次。

```react
var handleClick = useCallback(()=>{ console.log(name)
},[name])
<button onClick={()=>handleClick()}>hello</button>

//只有name改变后，  这个函数才会重新声明一次，
//如果传入空数组，  那么就是第一次创建后就被缓存，  如果name后期改变了,拿到的还是老的name。
//如果不传第二个参数，每次都会重新声明一次，拿到的就是最新的name.

```

**useMemo** **记忆组件**

useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的

```react
useCallback(fn, inputs) is equivalent to useMemo(() => fn, inputs).
```

唯一的区别是：**useCallback** **不会执行第一个参数函数，而是将它返回给你，而** **useMemo** **会执行第一个函数并****且将函数执行结果返回给你。**所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。

所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。(类似与vue的计算属性)

### **6. useRef(**保存引用值**)**

```react
const myswiper = useRef(null);
<Swiper ref={myswiper}/>
```

ref 写在dom上是value值，写在组件上，是组件对象。



### 7. useContext（减少组件层级）

对class类组件中使用context方法，

在函数式组件中的简化写法。 提供端没有简化，接受端较大简化。

```react
import React, { useState,useEffect,useContext } from 'react'
import axios from 'axios'
import './css/index.css'

const GlobalContext  = React.createContext() //创建context对象

export default function App (){
    const [filmList, setfilmList] = useState([])
    const [info, setinfo] = useState("")

    useEffect(() => {
        axios.get(`/test.json`).then(res=>{
            // console.log(res.data.data.films)
            setfilmList(res.data.data.films)
        })
    }, []);

    return (
        <GlobalContext.Provider value={{
            call:"打电话",
            sms:"短信",
            info:info,
            changeInfo:(value)=>{
                setinfo(value)
            }
        }}>
            <div>
                {/* {this.state.info} */}
                {
                    filmList.map(item=>
                        <FilmItem key={item.filmId} {...item} ></FilmItem>    
                    )
                }


                <FilmDetail ></FilmDetail>
            </div>
        </GlobalContext.Provider>
    )
}

/*受控组件*/

function FilmItem(props){
    let {name, poster,grade,synopsis}  = props
    const value = useContext(GlobalContext)

    console.log(value)// 父组件GlobalContext.Provider 提供的值：call:"打电话",
    return <div className="filmitem" onClick={()=>{
                console.log(synopsis)

                value.changeInfo(synopsis)
            }}>
                <img src={poster} alt={name}/>
                <h4>{name}</h4>
                <div>观众评分：{grade}</div>
            </div> 
}



function FilmDetail(){
    const value = useContext(GlobalContext)
    return <div className="filmdetail">
        detail-{value.info}
    </div>
}
```

### 8.useReducer 的使用

功能：Hooks提供的一种，将组件状态提到外面的方法。

案例： 对count数字， +  -- 操作。

```react
import React,{useReducer} from 'react'
 //处理函数
 const reducer = (prevState,action)=>{
    //  console.log("reduercer",prevState,action)
     let newstate = {...prevState}
     switch(action.type){
         case "kerwin-minus":
            newstate.count--
            return newstate

         case "kerwin-add":
            newstate.count++
            return newstate
        
         default:
            return prevState
     }
 }
 // 外部的对象
 const intialState = {
     count:0,
    //  list:[]
 } 

 export default function App() {
     const [state, dispatch] = useReducer(reducer,intialState)
        console.log(state, dispatch)
     return (
         <div>
             <button onClick={()=>{
                 dispatch({
                     type:"kerwin-minus"
                 })
             }}>-</button>
             {state.count}
             <button onClick={()=>{
                 dispatch({
                    type:"kerwin-add"
                })
             }}>+</button>
         </div>
     )
 }
```

### 9.useReducer + useContext配合使用（减少组件层级）

  Hooks提供类似redux数据仓库理念的工具方法。

案例：app父组件， 传值给三个子组件，共享数据和方法。child1组件，点击，child2 child3视图变化。

```react
import React,{useReducer,useContext} from 'react'

const initailState = {
    a:"11111",
    b:"11111"
}

const reducer = (prevState,action)=>{
    let newstate = {...prevState}
    switch(action.type){
        case "change-a":
            newstate.a = action.value
            return newstate
        case "change-b":
            newstate.b = action.value
            return newstate
        default:
            return prevState
    }
    // return prevState
}

const GlobalContext = React.createContext()
export default function App() {
    const [state, dispatch] = useReducer(reducer, initailState)
    
    return (
        <GlobalContext.Provider value={
            {
                state,
                dispatch
            }
        }>
            <div>
                <Child1/>
                <Child2/>
                <Child3/>
            </div>
        </GlobalContext.Provider>
    )
}

function Child1(){
    const {dispatch} = useContext(GlobalContext)
    return <div style={{background:"red"}}>
        <button onClick={()=>{
            dispatch({
                type:"change-a",
                value:"2222222"
            })
        }}>改变a</button>
        <button onClick={()=>{
            dispatch({
                type:"change-b",
                value:"333333"
            })
        }}>改变b</button>
    </div>
}

function Child2(){
    const {state} = useContext(GlobalContext)
    return <div style={{background:"yellow"}}>
        child2-{state.a}
    </div>
}

function Child3(){
    const {state} = useContext(GlobalContext)
    return <div style={{background:"gray"}}>
        child3-{state.b}
    </div>
}
```



### 10 自定义hooks

功能： 页面逻辑更清晰，更好阅读，体现函数式变成思想。

实现： Hooks提供一种方法。 允许你将一个大方法，按一定逻辑，抽离出来写成一个use-开头的小方法，不用担心异步问题。每次修改，代码都会重新给出新值。

案例如下；

```
import React, { useState,useEffect,useMemo } from 'react'
import axios from 'axios'

**1 获取list数据方法
function useCinemaList(){
    const [cinemaList, setcinemaList] = useState([])


    useEffect(() => {
        axios({
            url:"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159",
            method:"get",
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.0.4","e":"16395416565231270166529","bc":"110100"}',
                
                'X-Host': 'mall.film-ticket.cinema.list'

            }
        }).then(res=>{
            setcinemaList(res.data.data.cinemas)
        })
    }, [])

    return {
        cinemaList
    }
}
 **2获取筛选后的数据方法
function useFilter(cinemaList,mytext){
    const getCinemaList = useMemo(() => cinemaList.filter(item=>item.name.toUpperCase().includes(mytext.toUpperCase()) || 
    item.address.toUpperCase().includes(mytext.toUpperCase())
    ), [cinemaList,mytext])

    return {
        getCinemaList
    }
}

export default function Cinema(){
    const [mytext, setmytext] = useState("")
    
    const {cinemaList}  = useCinemaList()

    const {getCinemaList} = useFilter(cinemaList,mytext)

    return <div>
            {/* {this.state.mytext} */}
                <input value={mytext} onChange={(evt)=>{
                    setmytext(evt.target.value)
                }}/>
                {
                    getCinemaList.map(item=>
                        <dl key={item.cinemaId}>
                            <dt>{item.name}</dt>
                            <dd>{item.address}</dd>
                        </dl>    
                    )
                }
        </div>
}
```







### 小结解疑：

Q:  [react中useRef与createRef的区别](https://www.cnblogs.com/-roc/p/16943895.html)

A:   useRef()                   React.createRef()

useRef （是hooks一种，一般在**函数组件使用**）

1.1.获取当前dom数据（不推荐，推荐使用受控组件-即使用useState绑定表单元素）

1.2、作为存储使用

createRef（一般用于class组件，获取子组件dom）

1、createRef创建的ref对象，组件每更新一次，ref对象就会被重新创建。

区别

1.    useRef只会在组件首次渲染时创建

2.  createRef会在组件每次渲染的时候重新创建

   

   

## 十 React路由

### **1.**  什么是路由？

路由是根据不同的 url 地址展示不同的内容或页面。

一个针对React而设计的路由解决方案、可以友好的帮你解决React components 到URl之间的同步映射关系

### 2.路由安装

https://reacttraining.com/react-router/web/guides/quick-start

```
npm install react-router-dom@5

"react-router-dom": "^5.3.4",
```

### 3. 路由使用

####  (1)路由方法导入

```
import React from "react"; import {
 BrowserRouter as Router, Switch,
 Route, Link
  } from "react-router-dom";
```

#### (2)定义路由以及重定向 案例hash模式

  路由基本使用

```react
<HashRouter>
  <Route path="/films" component={Films}/>
    <Route path="/cinemas" component={Cinemas}/>
</HashRouter>
当浏览器http://localhost:3000/#/films时，展示对应组件。插件的基本功能就是匹配功能。
```

加功能1：

当用户输入的路径，没有对应页面时，跳到home页去。

```react
<HashRouter>
  <Switch>
         <Route path="/films" component={Films}/>
         <Route path="/cinemas" component={Cinemas}/>
      
       <Redirect from="/" to="/home" />   //from="/"  模糊匹配
   </Switch>
</HashRouter>
Switch嵌套路由，配合重定位标签。实现： 浏览器输入地址后，自上而下匹配，只要匹配到就跳出。没有匹配到，就重定位到home去。

```

加功能2：

当进入/ 根路由，就进入home去， 如果是 /abc  等乱输入的路径，就跳入到NotFound 未找到页面。

```react
<HashRouter>
    <Switch>
        <Route path="/films" component={Films}/>
        <Route path="/cinemas" component={Cinemas}/>
        <Route path="/center" component={Center}/>
        
        <Redirect from="/" to="/home" exact/>    
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
Redirect重定向标签，加exact精准属性，只有/，才进入home,其他情况，万能匹配，进入NotFound页面。
```



解析：

exact 精确匹配 (Redirect 即使使用了exact, 外面还要嵌套Switch 来用)；

Warning: Hash history cannot
PUSH the same path; a new entry will not be added to the history
stack,这个警告只有在hash 模式会出现。

#### (3)嵌套路由

页面效果：

父页面中显示轮播图和两个按钮  分别显示不同的子页面。

代码配置：

router.js  根路由

```
<HashRouter>
    <Switch>
        <Route path="/films" component={Films}/>   //不要加 exact 否则子页面不显示
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

films组件

```
import React, { Component } from 'react'
import Nowplaying from './films/Nowplaying'
import Comingsoon from './films/Comingsoon'
import {Redirect, Route, Switch} from 'react-router-dom'
export default class Films extends Component {
    render() {
        return (
            <div>
                <div style={{height:"200px",background:"yellow"}}>大轮播</div>

                <div>导航栏  按钮1  按钮2</div>

                {/* 路由配置 嵌套路由 */}
                <Switch>
                    <Route path="/films/nowplaying" component={Nowplaying}/>
                    <Route path="/films/comingsoon" component={Comingsoon}/>
                    <Redirect from="/films" to="/films/nowplaying"/> 
                </Switch>

            </div>
        )
    }
}

```

#### (4)路由跳转方式

按照是否以标签例如<a href='#/films'/>,还是js跳转页面，分类如下：

##### a.   声明式导航

activeClassName 当前显示页面，自动加class。配合css 可以高亮显示tab。

```
<NavLink to="/films" activeClassName="active">films</NavLink>   //react 浏览器中会编译成a标签
<NavLink to="/cinemas" activeClassName="active">cinemas</NavLink>
<NavLink to="/center" activeClassName="active">center</NavLink>
```

##### b   编程式导航

案例

###### router.js  根路由

```
<HashRouter>
    <Switch>
        <Route path="/films" component={Films}/>   
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

###### films组件

```
import React, { Component } from 'react'
import Nowplaying from './films/Nowplaying'
import Comingsoon from './films/Comingsoon'
import {Redirect, Route, Switch} from 'react-router-dom'
export default class Films extends Component {
    render() {
        return (
            <div>
                <div style={{height:"200px",background:"yellow"}}>大轮播</div>

                <div>导航栏</div>

                {/* 路由配置 嵌套路由 */}
            {/* <Nowplaying/> */}
                <Switch>
                    <Route path="/films/nowplaying" component={Nowplaying}/>
                    <Route path="/films/comingsoon" component={Comingsoon}/>
                    <Redirect from="/films" to="/films/nowplaying"/> 
                </Switch>

            </div>
        )
    }
}
```



###### Nowplaying组件

当项目引入路由管理，组件都传入router，这时候组件都成为router的孩子，不管是一级路由，还是页面中嵌入的二级路由，组件都可以接受到一个props参数，这个参数就是路由对象。

```javascript
对象中包含了和路由相关的属性和方法。
{
  history,(有路由相关方法： push go goBack goForward replace location等)
  location  
  match  
}
```

props参数  根据来源分为两种：

第一种：形参传入  有以上三个对象

第二种：使用router对象

```
import { useHistory } from 'react-router-dom'
 const history  = useHistory()
 conosole.log(history)
 这个里面只有 history一个； 范围小一些。
```

Nowplaying组件

```
import React,{useState} from 'react'
import { useHistory } from 'react-router-dom'

export default function Nowplaying( props ) {
    const [list, setlist] = useState(["aa","bb","cc"])
    
      const history  = useHistory()
        
    const handleChangePage = (id)=>{
        // console.log("click")
        //  1.原生js跳转
        // window.location.href="#/detail/"+id

        2.使用入参的props
        // props.history.push(`/detail/${id}`)   //函数式写法（）
        // this.props.history.push(`/detail/${id}`) // 类组件式写法
        
  第二种方式：使用 useHistory 方法来自 router插件提供
        //1 -动态路由传参
        // history.push(`/detail/${id}`)
    
        // 2- query传参
        // history.push({ pathname : '/detail' ,query : { myid: id} })

        // 3- state传参
        // history.push({pathname:"/detail",state:{myid:id}})
    }

    return (
        <div>
            {
                list.map(item=> <li onClick={()=>handleChangePage(item)}>{item}</li>)
            }
        </div>
    )
}
```

#### (5) 路由传参

##### 声明式传参

特征和优缺点：

 参数保存位置， url路径中。    当页面刷新，参数不会丢失。

router.js  根路由

```
<HashRouter>
    <Switch>
        {/* /detail/1111  动态路由 */}
         <Route path="/detail/:myid" component={Detail} /> 
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

###### Nowplaying组件   

列表组件  入参

```
如上代码快
...
 2.使用入参的props
 // props.history.push(`/detail/${id}`)   //函数式写法（）
...
```

detail 详情组件 接参

当前路径   http://localhost:3000/#/detail/bb

```
import React from 'react'

export default function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")  //bb为参数值  myid为形参
    return (
        <div>
            deteail
        </div>
    )
}
```

##### 编程式传参    

特征和优缺点：

 参数保存位置， 缓存中。    当页面刷新，参数会丢失。

router.js  

根路由path="/detail" 这种传参就不要加形参  ：myid了。

```
<HashRouter>
    <Switch>
         <Route path="/detail" component={Detail} /> 
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

###### 

```
(1)
   入参
this.props.history.push({ pathname : '/user' ,query : { day: 'Friday'} }) 
   接受参数
this.props.location.query.day
(2)
    入参
this.props.history.push({ pathname:'/user',state:{day : 'Friday' } }) 
  接受参数
this.props.location.state.day
代码参考（4）路由跳转方式小结。
  测试发现this.props.history.push传入的对象， pathname是必须按照格式，后面query state或是其他属性，都可以，只要在接受参数处，一一对应即可。
```

### 4. 路由拦截（路由守卫）

react 并没有像vue router.beforeEach路由前，路由后等api; 所以这里只是用原生函数方法。

router.js

```
鉴权代码 
function isAuth(){
    return localStorage.getItem("token")
}



<Router>
      <Switch>
          <Route path="/films" component={Films}  />
      <Route path="/center" render={(props)=>{
        return isAuth()?<Center myname="tom"/>:<Redirect to="/login"/>
      }/>                 
```

### 5 路由模式

##### hash模式

像这种带#号的，叫锚点，这里称hash模式。不发起请求。

如果不想看到这样，可以使用令一种模式。

```
http://localhost:3000/#/login

import React, { Component } from 'react'
import { HashRouter as Router,Redirect,Route,Switch} from 'react-router-dom'

export default class IndexRouter extends Component {
    render() {
        return (
            <Router>   模式标签
                <Switch>
                    <Route path="/films" component={Films}  />
```

##### history模式

http://localhost:3000/login     像一个真正的路径。

BrowserRouter 没有#的路径，好看 ，真正朝后端发请求要页面，后端没有对应的路径处理路径， 就会404， 不好看。所以后台要做处理，因为项目是单页面，后台并没有对应资源，只需要返回index.html，前台重新渲染。

```
import React, { Component } from 'react'
import { BrowserRouter as Router,Redirect,Route,Switch} from 'react-router-dom'
...
 <Router>   模式标签
 或者
 import { BrowserRouter,Redirect,Route,Switch} from 'react-router-dom'
...
 <BrowserRouter>  </BrowserRouter>  模式标签

```

BrowserRouter as Router 意为： BrowserRouter 解构出来，起了一个别名叫Router。 这样后面代码就不用改了。更加便捷。

### 6 组件丢爹history和干爹支援（高阶组件withRouter）

#### 第一种情况：router 传递页面组件 

##### 

首先确定，父组件传参，子组件props接受参数。

router.js

```
 <BrowserRouter>
                <Switch>
                    <Route path="/films" component={Films}  />
                    
                     <Route path="/center" render={()=>{
                        return isAuth()?<Center myname="tom"/>:<Redirect to="/login"/>
                    }}/>          
```

前面路由守卫时，center组件做了处理，当我们在center组件中，使用history方法时，页面提示未找到方法。

center组件 

```
export default function Center(props) {
    return (
        <div>
            center

            <div onClick={()=>{
                props.history.push(`/filmsorder`)

                // console.log(props)
            }}>电影订单</div>
        </div>
    )
}
```

前面我们提到，使用路由时，被路由标签   <Router>   </Router> 包裹的页面组件，都是子组件，自然可以接受props参数，包含history等。

查看route核心方法

```
// class Route extends Component{
//     ...

//     render(){
//         var MyComponent = this.props.component
//     return <div>
//             <MyComponent history={} match={}.../>
//         </div>
//     }
// }
```

route以变量形式，接受组件，传入参数，再render出去。而center这条路由，直接使用render，并没有传参，测试传递一个自定义参数myname, center组件中，打印props，果然看到参数tom,证实确实是route给出的东西，没有传递下去，导致子组件history方法缺失。

```
<Route path="/center" render={()=>{
                        return isAuth()?<Center myname="tom"/>:<Redirect to="/login"/>
                    }}/> 
```

改进, 解构，传参下去

```
    <Route path="/center" render={(props)=>{
                        console.log(props,'执行了')
                        return isAuth()?<Center myname="kerwin" {...props}/>:<Redirect to="/login"/>
                    }}/>
```

#### 第二种情况 组件传递组件

代码中，FilmItem小组件， props.history.push提示未找到，情况和第一种相似，都是参数在传递过程中，中断。

```
import React,{useState} from 'react'
export default function Nowplaying(props) {       <----------1这个props参数
    const [list, setlist] = useState([1,2,3,4])

    return (
        <div>
            {
                list.map(item=>
                 <FilmItem key={item.filmId} {...item} 	/>     <----------2这里 {...props}
                )
            }
        </div>
    )
}

function FilmItem(props){
    // console.log(props)  // 打印没有 props.history
    let {name,filmId} = props
    return <li onClick={()=>{
        props.history.push(`/detail/${filmId}`)
    }}>
        {name}
    </li>    
}
```

#### 干爹支援

父组件  ---> 子组件 ---> 孙组件， 有点麻烦，是否有其他便捷api？

router提供一个高阶组件，作用是为没有路由属性和方法的普通组件，增益方法。

```
import {withRouter} from 'react-router-dom'
```

使用方法：

```
import React,{useState} from 'react'
import {useHistory,withRouter} from 'react-router-dom'

export default function Nowplaying(props) {
    const [list, setlist] = useState([1,2,3,4])

    return (
        <div>
            {
                list.map(item=>
                 <WithFilmItem key={item.filmId} {...item} />
                )
            }
        </div>
    )
}

             这是一个普通孙组件           
function FilmItem(props){
    // console.log(props)
    let {name,filmId} = props
    return <li onClick={()=>{
        props.history.push(`/detail/${filmId}`)
    }}>
        {name}
    </li>    
}


const WithFilmItem = withRouter(FilmItem)  <----- withRouter方法，包裹普通组件，吐出来增益组件。这样，FilmItem中的onClick里面，就可以使用 props.history.push了。
```

#### withRouter   的应用与原理

You can get access to the history object's properties and the closest <Route>'smatch via the withRouter higher-order component.wi thRouter will pass updatedmatch, location, and history props to the wrapped component whenever itrenders.

```
只要被withRouter加工后，就可以获取到history相关。
 import { withRouter } from "react-router"; 
 withRouter(MyComponent); 
 withRouter(connect(...)(MyComponent))

```





## 十一  Flux与Redux

### Flux介绍

是一种架构思想，专门解决软件的结构问题。它跟MVC架构是同一类东西，但是更加简单和清晰。Flux存在多种实现(至少15种

[https://github.com/voronianski/ﬂux-comparison](https://github.com/voronianski/flux-comparison)

Facebook Flux是用来构建客户端Web应用的应用架构。它利用**单向数据流**的方式来组合React中的视图组件。它更像一个模式而不是一个正式的框架，开发者不需要太多的新代码就可以快速的上手Flux.

![图](.\img\redux.jpg)

### Redux介绍

Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（state对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers），这样就可以进行数据追踪，实现时光旅行。

#### 1  redux介绍及设计和使用的三大原则

原因：[Redux](https://so.csdn.net/so/search?q=Redux&spm=1001.2101.3001.7020)应用需要遵循三大原则，否则程序很容易出现难以察觉的问题。

1  state 以单一对象存储在 store 对象中
2  state 只读(每次都返回一个新的对象)

3  使用纯函数 reducer 执行 state 更新

细化解释：

①唯一数据源

　　Redux只维护一个全局的状态对象，存储在Redux的store中。唯一数据源是一种集中式管理应用状态的方   

​       式，便于监控任意时刻应用的状态和调试应用，减少出错的可能性。

②保持应用状态只读

　　在任何时候都不能直接修改应用状态。当需要修改应用状态时，必须发送一个action，由这个action描述如何   

​       修改应用状态。

③应用状态的改变通过纯函数完成

　　action表明修改应用状态的意图，真正对应用状态做修改的是reducer。reducer必须是纯函数，所以reducer 

​       在接收到action时，不能直接修改原来的状态对象，而是要创建一个新的状态对象返回。

纯函数指的是：

​    对于同样的参数值，函数的返回结果总是相同的。函数的执行不会产生副作用，例如修改外部对象或输出到I/O

 设备。

主要组成action
　　action是Redux中信息的载体，是store唯一的信息来源。把action发送给store必须通过store的dispatch方法。action是普通的JavaScript对象，但每一个action必须有一个type属性描述action的类型，type一般为字符串常量。除了type属性外，action的结构完全由自己决定。一般通过action creator创建action，action creator是返回action的函数

相关文档参看：https://blog.csdn.net/sxww_zyt/article/details/129253498



#### 2. redux 工作流

摘自官网

![示例](https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)



![img](.\img\redux2.jpg)



#### 3. react绑定后使用redux实现案例

##### npm 引入

 官网 https://cn.redux.js.org/introduction/getting-started/

```
# NPM
npm install redux
```

##### 案例演示

：列表页中显示地图tabbar，进入详情页时隐藏。

npm初始化后，在项目根目录中新建redux文件夹子，进入文件夹，新建store.js文件。

###### store.js

```
 //1. 引入redux, 
 //2. createStore( reducer )
 import {createStore} from 'redux'

 const reducer = (prevState={ show:true,},action)=>{
    console.log(prevState,action)
    let newState = {...prevState}
    switch(action.type){
       case "0":
         newState.show = false
         return newState     （return 的state，就变成最新的state，app页面可以获取最新的值）
       case "1":
         newState.show = true
         return newState
       default:
          return prevState
    }
 }
 const store = createStore(reducer);

 export default store
```



###### App.js组件   

项目运行，即执行 store.subscribe 订阅。

只要那个页面调用 dispatch，store.subscribe就会被触发， 拿到已经修改后的数据，做自己的逻辑。

本页面情况是：   

初始加载A页面（订阅者），跳转B页面（触发者），再回A页面。  -----》需要store.subscribe订阅。

  但有一种情况，

就是A页面，跳转B页面（触发者），然后跳往C页面，不需要订阅，直接拿值即可。store.getState()

```
import React, { Component } from 'react'
import MRouter from './router/IndexRouter'
import Tabbar from './components/Tabbar'
import './views/css/App.css'
               import store from './redux/store'
export default class App extends Component {
    state = {
        isShow:store.getState()
    }

    componentDidMount() {
        store.subscribe(()=>{// store.subsribe 订阅
            console.log("app 中订阅",store.getState())

            this.setState({
                isShow:store.getState().show
            })
        })
    }
    
    render() {
        return (
           <div>
                {/* 其他的内容 */}
                <MRouter>
                    {this.state.isShow && <Tabbar></Tabbar>}
                </MRouter>
           </div>
        )
    }
}

```

###### detail.js组件 

详情组件

```
import React,{useEffect} from 'react'
import store from '../redux/store'

export default function Detail(props) {
    console.log(props.match.params,"利用id去后端拿数据。")
    // console.log(props.location.query.myid,"利用id去后端拿数据。")
    // console.log(props.location.state.myid,"利用id去后端拿数据。")

    useEffect(() => {
        // console.log("create") 渲染完成调用
        
        //store.dispatch  通知
        store.dispatch( {type:"0" } )
        return () => {
            // console.log("destroy") 页面销毁时调用
            
            store.dispatch( {type:"1" } )
        }
    }, [])

    return (
        <div>
            deteail
        </div>
    )
}

```

##### 案例演示逻辑解析

上面案例实现，核心方法

```
/*
store.subscrbe   app页面进入监听

store.dispatch   其他页面调用

store.getState  app页面被触发后，使用该方法获取最新state值

*/
```

diy三个方法

改写store.js

```
 //1. 引入redux, 
 //2. createStore( reducer )
 import {createStore} from 'redux'

 const reducer = (prevState={ show:true},action )=>{
    console.log(action)
    let newState = {...prevState}
    switch(action.type){
       case "kerwinhide-tabbar":
         newState.show = false
         return newState
       case "kerwinshow-tabbar":
         newState.show = true
         return newState
       default:
          return prevState
    }
 }
 const store = createKerwinStore(reducer);// 初始化createStore,更换为下面自定义方法。

 export default store


/*
store.subscrbe   app页面进入监听

store.dispatch   其他页面调用

store.getState  app页面被触发后，使用该方法获取最新state值

*/
  function createKerwinStore(reducer){
     var list = []
     var state = reducer(undefined,{})
     
     function subscribe(callback){
        list.push(callback)
     }
  
     function dispatch(action){
        state = reducer(state,action)
        for(var i in  list){
           list[i] && list[i]()
        }
     }
  
     function getState(){
        return state
     }
     return {
        subscribe,
        dispatch,
        getState
     }
   }

```

其他页面不动，测试发现功能正常。

##### 引申  什么时纯函数

```
 /*
   var obj = {
     myname:"kerwin"
   }
   
   function test(obj){
     var newobj = {...obj}
     newobj.myname="xiaoming"
   
     return newobj
    }
    
    test(obj)  //myname:"xiaoming"
        obj //  myname: "kerwin" obj没有改变（注意：解构是浅复制）

    纯函数： 
      1. 对外界没有副作用 --- 指的是不会修改影响函数外边的变量。这里指不能修改obj对象。
      2. 同样的输入得到同样的输出
 */
```

 根据这个规则，reducers 也可以归类于纯函数类。 它不修改state，每次都是解构后return , 同样的入参，输出同样的出参。 

#### 4 reducer扩展 多命名空间管理

当项目较大，多人开发时，一个retucers肯定不行的，接下来引出新方法 - 

```
 combineReducers  from 'redux'
```

示例如下：

store.js

```
 //1. 引入redux, 
 //2. createStore( reducer )
 import {combineReducers, createStore} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 
 const reducer  = combineReducers({CityReducer,TabbarReducer })
 const store = createStore(reducer);
 export default store
```

子 -- 01

```
const CityReducer = (prevState={
    cityName:"北京"
   //  ...
 },action)=>{

    let newState = {...prevState}
    switch(action.type){
      
       case "change-city":
         newState.cityName = action.payload
         return newState

       default:
          return prevState
    }
 }

 export default  CityReducer
```

子 -- 01

```
const TabbarReducer = (prevState={
    show:true
 },action)=>{
    let newState = {...prevState}
    switch(action.type){
       case "kerwinhide-tabbar":
         newState.show = false
         return newState
       case "kerwinshow-tabbar":
         newState.show = true
         return newState
       default:
          return prevState
    }
 }
 export default TabbarReducer
```

使用state值的时候，也要做相应调整。

```
打印store.getState()就变成
{
 CityReducer: {cityName: '北京'}
 TabbarReducer: {show: true}
}
```



```
    componentDidMount() {
        store.subscribe(()=>{  // store.subsribe 订阅
            console.log("app 中订阅",store.getState())   打印看上边

            this.setState({
                isShow:store.getState().TabbarReducer.show  // 需要再递进一层
            })
        })
    }
```

总结：

如果如果不同的action所处理的属性之间没有联系，我们可以把Reducer 函数拆分。不同的函数负责处理不同属性，最终把它们合并成一个大的Reducer 即可

```
import {combineReducers} from "redux"; 

const reducer = combineReducers({
a: functionA, 
b: functionB, 
c: functionC
})

访问：
(state)=>{ return {
        kerwinstate:state.a (不同的命名空间)
    }
}
```



#### 5. redux 中间件 

##### 第一种  redux-thunk

###### 1. 中间件的作用

在redux里，action仅仅是携带了数据的普通js对象。action creator返回的值是这个action类型的对象。然后通过store.dispatch()进行分发。同步的情况下一切都很完美，但是reducer无法处理异步的情况。

那么我们就需要在action和reducer中间架起一座桥梁来处理异步。这就是middleware。

```
 
 store.dispatch(getCinemaListAction())
 
  dispatch的返回函数中，不能是一个异步，就如下面test函数，立即执行后，必须返回东西。
```



```
function test(){
    setTimeout(()=>{
        return 1000 
    },2000)

}

test() //undefined
```

解决这个报错，就需要使用中间件了





###### 2. 中间件 redux-thunk的使用

```
npm i redux-thunk
```

改造store.js文件

原来

```
 import {combineReducers, createStore} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 
 const reducer  = combineReducers({CityReducer,TabbarReducer })
 const store = createStore(reducer);
 export default store
```

现在

使用了 

applyMiddleware  from 'redux'     （redux中，已经给出了插件接口）

import reduxThunk from 'redux-thunk'

createStore时，传入第二个参数 applyMiddleware(reduxThunk)

```
 import {applyMiddleware, combineReducers, createStore} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 import CinemaListReducer from './reducers/CinemaListReducer'
 import reduxThunk from 'redux-thunk'
 
 const reducer  = combineReducers({
  CityReducer,
  TabbarReducer,
  CinemaListReducer
 })
 const store = createStore(reducer,applyMiddleware(reduxThunk));
 export default store
```

使用页面

```
 dispatch中可以包含axios（url:"xxx"）等异步的操作了
 store.dispatch(getCinemaListAction())
```

项目案例1：

进入列表页，检查store中是否已经有数据，没有就后台请求。

store.js配置好中间件

```
 import {applyMiddleware,combineReducers, createStore} from 'redux' <----- 关键点
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 import CinemaListReducer from './reducers/CinemaListReducer'
 import reduxThunk from 'redux-thunk'  <----- 关键点

 const reducer  = combineReducers({CityReducer,TabbarReducer ,CinemaListReducer})
 const store = createStore(reducer,applyMiddleware(reduxThunk));<----- 关键点
 export default store
```



列表页

```
import React,{useState,useEffect} from 'react'
import getCinemaListAction from '../redux/actionCreator/getCinemaListAction'
import store from '../redux/store'
export default function Cinemas(props) {

    const [cityName] = useState(store.getState().CityReducer.cityName)

    const [cinemaList,setCinemaList] = useState(store.getState().CinemaListReducer.list)


    useEffect(() => {
        // if(store.getState)
        // console.log()
        if(store.getState().CinemaListReducer.list.length===0){
            //去后台取数据
            // actionCreator 里写异步
            store.dispatch(getCinemaListAction())
        }else{
            console.log("store 缓存")
        }
        //订阅
        store.subscribe(()=>{
            console.log("cinema 中订阅",store.getState().CinemaListReducer.list)
            setCinemaList(store.getState().CinemaListReducer.list)
        })

        // windw
    }, [])

    return (
        <div>
            <div onClick={()=>{
                props.history.push(`/city`)
            }}>{cityName}</div>
            {
                  cinemaList.map(item=>
                    <dl key={item.cinemaId} style={{padding:"10px"}}>
                        <dt>{item.name}</dt>
                        <dd style={{fontSize:"12px",color:"gray"}}>{item.address}</dd>
                    </dl>    
                )
            }
        </div>
    )
}

```

数据请求js

```
import axios from 'axios'
function getCinemaListAction(){

    return (dispatch)=>{
        axios({
            url:"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159",
            method:"get",
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.0.4","e":"16395416565231270166529","bc":"110100"}',
                
                'X-Host': 'mall.film-ticket.cinema.list'
    
            }
        }).then(res=>{
            // console.log(res.data.data.cinemas)
            dispatch({
                type:"change-list",
                payload:res.data.data.cinemas
            })
        })   
    }    
}

export default getCinemaListAction

```

##### 第二种 Promise方式

使用方式：

```
作为一款插件引入
npm i redux-promise
```

store.js中使用

```
 import {applyMiddleware,combineReducers, createStore} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 import CinemaListReducer from './reducers/CinemaListReducer'
 import reduxThunk from 'redux-thunk'

 import reduxPromise from 'redux-promise'//中间件promise <--------重点
 

 const reducer  = combineReducers(
 {CityReducer,
 TabbarReducer ,
 CinemaListReducer
 })
 
 const store = createStore(
 reducer,
 applyMiddleware(reduxThunk,reduxPromise)); <--------重点 传入第二款中间件
 
 export default store
```

触发页面

```
 useEffect(() => {
        // if(store.getState)
        // console.log()
        if(store.getState().CinemaListReducer.list.length===0){
            //去后台取数据
            // actionCreator 里写异步
            store.dispatch(  getCinemaListAction()  )  <--------重点 dispatch方法
        }else{
            console.log("store 缓存")
        }
        //订阅
        var unsubscribe = store.subscribe(()=>{
            console.log("cinema 中订阅",store.getState().CinemaListReducer.list)
            setCinemaList(store.getState().CinemaListReducer.list)
        })
        return ()=>{
            //取消订阅？
            unsubscribe() 
        }
    }, [])
```

getCinemaListAction() 封装页面

与redux-thunk的区别：

redux-thunk 

```
test(){
return ( dispatch )=>{   <--------重点 return 的是一个函数
    axios({}).then(res =>{
        dispatch({        <--------重点 使用入参方法dispatch返回数据
                type:"change-list",
                payload:res.data.data.cinemas
            })
    }) 
}

}
export default test
```

promise版本

```
test(){
 return   axios({}).then(res =>{ <--------重点 return 的是一个promise( axios就是promise类的 )
    
       return  { type:"change-list",  <--------重点 return 出去参数
                payload:res.data.data.cinemas
              }
    }) 


}
export default test
```

原理就是：

store.dispatch( xx ）接受到的东西，它会判断一个function  ，就（）执行；还是Promise  就then出去。





```
import axios from 'axios'
function getCinemaListAction(){

    // return (dispatch)=>{
        return axios({
            url:"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159",
            method:"get",
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.0.4","e":"16395416565231270166529","bc":"110100"}',
                
                'X-Host': 'mall.film-ticket.cinema.list'
    
            }
        }).then(res=>{
            // console.log(res.data.data.cinemas)
            // dispatch({
            //     type:"change-list",
            //     payload:res.data.data.cinemas
            // })
           return {
                type:"change-list",
                payload:res.data.data.cinemas
            }
        })   
    // }    
}

export default getCinemaListAction
```









#### 6. 关于反复订阅的问题

页面列表中，使用了 store.subscribe订阅， 但是发现一个问题，就是只要返回数据， 所有订阅者都会触发，不管你需不需要，并且单个页面还会重复订阅。原因是，redux是一个运行在缓存中的逻辑，每次订阅都会往事件数组列中push新的回调执行，然后当数据返回时，又把列表里的订阅事件，执行了一遍。

```
import React,{useState,useEffect} from 'react'
import getCinemaListAction from '../redux/actionCreator/getCinemaListAction'
import store from '../redux/store'
export default function Cinemas(props) {

    const [cityName] = useState(store.getState().CityReducer.cityName)

    const [cinemaList,setCinemaList] = useState(store.getState().CinemaListReducer.list)


    useEffect(() => {

        if(store.getState().CinemaListReducer.list.length===0){
            //去后台取数据
            // actionCreator 里写异步
            store.dispatch(getCinemaListAction())
        }else{
            console.log("store 缓存")
        }
        //订阅
        store.subscribe(()=>{
            console.log("cinema 中订阅",store.getState().CinemaListReducer.list)
            setCinemaList(store.getState().CinemaListReducer.list)
        })

    }, [])

    return (
        <div>
            <div onClick={()=>{
                props.history.push(`/city`)
            }}>{cityName}</div>
            {
                  cinemaList.map(item=>
                    <dl key={item.cinemaId} style={{padding:"10px"}}>
                        <dt>{item.name}</dt>
                        <dd style={{fontSize:"12px",color:"gray"}}>{item.address}</dd>
                    </dl>    
                )
            }
        </div>
    )
}
```

解决方法：

store.subscribe在订阅的时候，返回了一个取消订阅的函数，只要在适当时机执行，就可以取消订阅。

```

    useEffect(() => {

        if(store.getState().CinemaListReducer.list.length===0){
            //去后台取数据
            // actionCreator 里写异步
            store.dispatch(getCinemaListAction())
        }else{
            console.log("store 缓存")
        }
        //订阅
       var unsubscribe =  store.subscribe(()=>{ <----- 重点
            console.log("cinema 中订阅",store.getState().CinemaListReducer.list)
            setCinemaList(store.getState().CinemaListReducer.list)
        })
       return ()=>{
        //页面销毁时执行
        // 取消订阅
        unsubscribe()  <----- 重点
       }
    }, [])
```





#### 7. 插件（可视化redux数据）

Redux DevToolsExtension ；   类似与vue  的  vuejsdevtools；作用都是开发辅助，方便查看数据变化。

redux插件下载地址（ 可以下载chrome浏览器） 下载扩展zip包，下载后，拖到chrome扩展程序处，即自动安装。

https://github.com/zalmoxisus/redux-devtools-extension

然后，项目中配置

store.js参数配置

https://github.com/zalmoxisus/redux-devtools-extension#usage

```
import { 
createStore, 
compose    <----- 重点  解构出这个参数
} from 'redux' import reducer from './reducer'

const composeEnhancers = window.  REDUX_DEVTOOLS_EXTENSION_COMPOSE	 || compose; const store = createStore(reducer, 
composeEnhancers( 原来的中间件 )      <----- 重点  包裹原来的中间件
)

```

示例：

```
 import {applyMiddleware,combineReducers, createStore, compose} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 import CinemaListReducer from './reducers/CinemaListReducer'
 import reduxThunk from 'redux-thunk'

 import reduxPromise from 'redux-promise'

 const composeEnhancers = window.  REDUX_DEVTOOLS_EXTENSION_COMPOSE	 || compose;

 const reducer  = combineReducers({CityReducer,TabbarReducer ,CinemaListReducer})
 const store = createStore(reducer, composeEnhancers(applyMiddleware(reduxThunk,reduxPromise)));
 export default store

```

刷新页面

![](.\img\微信截图_20231112165343.png)



## 十二 react-redux 

![img](.\img\clip_image002.jpg)

#### 1 .口述功能

使用本库的前提，要使用redux. 

依赖与redux,增加了一点react特性。

react-redux就是一个高阶组件，把属性和方法注入到了props.  

用它来发布，订阅，取消订阅等繁琐的事情，更加注重业务。 

​               效果：            低阶组件--->   处理包装 ------> 高阶组件  增加了属性和方法

**实现方式：**

是增加了connect函数生成一个父组件，父传子方式，传递参数。

connect（供应商组件） 包裹<app/>标签，然后每个页面组件使用，就把那个组件改造一下。

#### 2.使用

```
npm i react-redux 
```

#### 3. 案例演示

index.js页面

```
import React from 'react'
import ReactDOM from 'react-dom'
import App from './05-redux/App'

import {Provider} from 'react-redux'    <---- 重点
import {store} from './06-react-redux/redux/store' <---- 重点

ReactDOM.render(

    <Provider store={store}>  <---- 重点  在顶级标签，供应商组件包裹，注入store仓库
         <App/>
    </Provider>
    
  ,document.getElementById("root"))
```

##### 示例01 

app组件改造示例01 

```
import React, { Component } from 'react'
import MRouter from './router/IndexRouter'
import Tabbar from './components/Tabbar'
import './views/css/App.css'

import { connect } from 'react-redux' <---- 重点  引入connect方法

 class App extends Component {

    componentDidMount() {
        console.log(this.props)
    }

    render() {
        return (
           <div>
         
                <MRouter>
                  {this.props.isShow && <Tabbar></Tabbar>} <---- 重点 isShow的拿参形式
               </MRouter>
              
           </div>
        )
    }
}

const mapStateToProps = (state)=>{
    // console.log(state)
    return {
        a:1,
        b:2,
        isShow:state.TabbarReducer.show
    }
}
const  callback = {
    a:()=>{

    },
    b:()=>{

    }
}
    
export default connect( mapStateToProps,callback )(App) <---- 重点 解释如下
```

connect（a,b）返回一个函数，再把App入参。这样是为了便于我们自定义传参。 

--形参a      将来给孩子传的属性

是一个函数 return 一个对象，这里面可以拿到顶级传入的store参数，选取本页面会使用道到的 isshow .

--形参b  将来给孩子传的回调函数

传入回调方法，这里面可以是请求的数据，等自定义的东西。

传入之后，项目中所有的组件都视为Provider的子组件，通过props拿到自己传入的参数。

##### 示例02

detail详情组件示例2

列表页执行代码

```
 props.history.push(`/detail/${filmId}`)
```

详情页：

```
import React,{useEffect} from 'react'
import { show,hide } from '../redux/actionCreator/TabbarActionCreator'

import {connect} from 'react-redux' <---- 重点

 function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")

    let  {show,hide,match} = props; // 把参数解构出来 否则依赖过多 浏览器warm提示

    useEffect(() => {
        // console.log("create")
        // store.dispatch(hide())
                  hide()  <---- 重点 原来dispatch的方法替换为更为更为简洁的hide()
        return () => {
            console.log("destroy")
            // store.dispatch(show() )
                    show()  <---- 重点
        }
    }, [match.params.myid, show,hide]) 依赖参数

    return (
        <div>
            deteail
        </div>
    )
}
const mapDispatchToProps  = {
    show,
    hide
}
export default connect(null,mapDispatchToProps)(Detail) <---- 重点 组件提升
```

TabbarActionCreator 方法

```
 function hide(){
     return {
        type:"kerwinhide-tabbar"
    }
 }

 function show(){
    return {
        type:"kerwinshow-tabbar"
    }
 }

 export {show,hide}
```

##### 示例03 

city.js组件改造

```
import React,{useState} from 'react'
import {connect} from 'react-redux'  <---- 重点

 function City(props) {
    const [list] = useState(["北京","上海","深圳","广州"])
    return (
        <div>
            city

            <ul>
                {
                    list.map(item=>
                    <li key={item} onClick={()=>{
                        // store.dispatch({
                        //     type:"change-city",
                        //     payload:item
                        // })
                        props.change(item)  <---- 重点 传入行参数item

                        props.history.goBack()
                    }}>{item}</li>    
                    )
                }
            </ul>
        </div>
    )
}
const mapDispatchToProp =  {
    change(item){     接受参数  item 
        return {
            type:"change-city",       //这里是通过type挨个区匹配reducer
            payload:item
        }
    }
}

export default connect(null,mapDispatchToProp)(City) <---- 重点
```

CityReducer.js

```
const CityReducer = (prevState={
    cityName:"北京"
   //  ...
 },action)=>{

    let newState = {...prevState}
    switch(action.type){
      
       case "change-city":
         newState.cityName = action.payload
         return newState

       default:
          return prevState
    }
 }

 export default  CityReducer
```

##### 示例04

Cinemas.js电影列表页面  改造

```
import React,{ useEffect } from 'react'
import getCinemaListAction from '../redux/actionCreator/getCinemaListAction'
import { connect } from 'react-redux' <---- 重点

 function Cinemas(props) {

    let {list, getCinemaListAction, cityName} = props

    useEffect(() => {

        if(list.length===0){
            //去后台取数据
            // actionCreator 里写异步
            // store.dispatch(getCinemaListAction())
            getCinemaListAction()  <---- 重点
        }
    }, [list,getCinemaListAction]) <---- 重点
    return (
        <div>
            <div style={{overflow:"hidden"}}>
                <div onClick={()=>{
                    props.history.push(`/city`)
                }} style={{float:"left"}}>{ cityName }</div>
                <div style={{float:"right"}} onClick={()=>{
                    props.history.push(`/cinemas/search`)
                }}>搜索</div>
            </div>
            {
                  list.map(item=> <---- 重点 这里直接使用解构出来的 list
                    <dl key={item.cinemaId} style={{padding:"10px"}}>
                        <dt>{item.name}</dt>
                        <dd style={{fontSize:"12px",color:"gray"}}>{item.address}</dd>
                    </dl>    
                )
            }
        </div>
    )
}
const mapStateToProps = (state)=>{ <---- 重点  顶级组件给的参数  数据仓库
    return {
        list:state.CinemaListReducer.list,
        cityName:state.CityReducer.cityName
    }
}

const mapDispatchToProps = {
    getCinemaListAction
}
export default connect(mapStateToProps,mapDispatchToProps)(Cinemas)<---- 重点
```

#### 4.总结

react-redux插件的引入，把数据从页面抽离，使每个页面都变成了Ui组件。

###### 扩展 ：UI组件和容器组件

###### 1）UI组件

• 只负责 UI 的呈现，不带有任何业务逻辑

• 没有状态（即不使用this.state这个变量）

• 所有数据都由参数（this.props）提供

• 不使用任何 Redux 的 API

###### (2) 容器组件

• 负责管理数据和业务逻辑，不负责 UI 的呈现

• 带有内部状态
•用 Redux 的 API

###### 细化解释：

展示组件负责应用的UI展示，也就是组件如何渲染，具有很强的内聚性。展示组建不关心渲染时使用的数据是如何获取到的，它只要知道有了这些数据后，组件应该如何渲染就足够了。

容器组件负责应用逻辑的处理，如发送网络请求、处理返回数据，将处理过的数据传递给展示组件使用等。容器组件还提供修改源数据的方法，通过展示组件的props传递给展示组件，当展示组件的状态变更引起源数据变化时，展示组件通过调用容器组件提供的方法同步这些变化。

展示组件和容器组件可以自由嵌套。

注意！展示组件和容器组件是根据组件意图划分的，无状态组件和有状态组件是根据组件内部是否使用state划分组件。通常情况下，展示组件是通过无状态组件实现的，容器组件是通过有状态组件实现的，但是展示组件也可以是有状态组件。，容器组件也可以是无状态组件。


##### **1.**  Provider  与  connect

(1)React-Redux  提供Provider组件，可以让容器组件拿到state

```
import React from 'react'
import ReactDOM from 'react-dom'


import { Provider } from 'react-redux' import store from './store'

import App from './App'


const rootElement = document.getElementById('root') ReactDOM.render(
<Provider store={store}>
<App />
</Provider>, rootElement
)

```

##### 2. React-Redux 提供connect方法

，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来

```
import { connect } from 'react-redux'
import { increment, decrement, reset } from './actionCreators'


// const Counter = ...
const mapStateToProps = (state /*, ownProps*/) => { return {
counter: state.counter
}
}
const mapDispatchToProps = { increment, decrement, reset } export default connect(
mapStateToProps, mapDispatchToProps
)(Counter)

```

#####  3  HOC与context通信在react-redux底层中的应用

(1)     connect 是HOC， 高阶组件

(2)  Provider组件，可以让容器组件拿到state ， 使用了context( 跨级通信 )

##### 4 高阶组件构建与应用

HOC不仅仅是一个方法，确切说应该是一个组件工厂，获取低阶组件，生成高阶组件。

 (1)代码复用，代码模块化

(2) 增删改props

(3)   渲染劫持

**示例**

```javascript
// Child.js

//高阶函数  入参为低阶组件
function Control(wrappedComponent) {
  return class MyControl extends React.Component {
    render() {
      if (!this.props.data) {
        return <div>loading...</div>
      }
      return <wrappedComponent {...props} />
    }
  }
}


class MyComponent extends React.Component {
  render() {
    return <div>{this.props.data}</div>
  }
}
export default Control(MyComponent); //输出高阶组件



//Parent.js
import MyControlComponent from "./Child"
<MyControlComponent data={this.state.value}/>

//在父级传入data是null的时候，这一块儿就只会显示loading...,
//不会显示组件的具体内容，如果data不为null,  就显示真实组件信息。

```

#### 5.原理探究

```
...
export default connect(mapStateToProps,mapDispatchToProps)(Cinemas)<---- 重点

这里组件使用connect方法处理后，为低阶组件，增加了属性和方法，对这一核心方法解析。
```

   根据输入和输出效果，自定义connect方法 

   如下

```
import React,{useEffect} from 'react'
//低阶组件
function NotFound(props) {
    useEffect(() => {
        console.log(props)
    }, [props])
    return (
        <div>
            404 not found
        </div>
    )
}
自定义connenct方法
function kerwinconnenct(cb,obj){
    var value = cb()
    return (MyComponent)=>{
        return (props)=>{
            // console.log()
            return <div style={{color:"red"}}>
                <MyComponent {...value} {...props} {...obj}/>
            </div>
        }
    }
}
输出高阶组件
export default kerwinconnenct(()=>{
    return {
        a:1,
        b:2
    }
},{
    aa(){},
    bb(){}
})(NotFound)

```



#### redux持久化改造

使用插件 redux-persist 

前提：最好使用了react-redux之后，再使用这个。

https://github.com/rt2zz/redux-persist

使用

```
npm i redux-persist

```

 需要改造两处

store.js文件

```
 import {applyMiddleware,combineReducers, createStore, compose} from 'redux'
 import CityReducer from './reducers/CityReducer'
 import TabbarReducer from './reducers/TabbarReducer'
 import CinemaListReducer from './reducers/CinemaListReducer'
 import reduxThunk from 'redux-thunk'
 import reduxPromise from 'redux-promise'

 import { persistStore, persistReducer } from 'redux-persist'
 import storage from 'redux-persist/lib/storage' // defaults to localStorage for web
 
 const persistConfig = {
    key: 'kerwin',
    storage,
    whitelist: ['CityReducer']
  }
  
  const reducer  = combineReducers({
    CityReducer,
    TabbarReducer,
    CinemaListReducer
   })
  const persistedReducer = persistReducer(persistConfig, reducer)
  
  
  
   const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;
  
   const store = createStore(persistedReducer,composeEnhancers(applyMiddleware(reduxThunk,reduxPromise)));
   let persistor = persistStore(store)
  
   export {store,persistor}
```

index.js

```
import React from 'react'
import ReactDOM from 'react-dom'
import App from './05-redux/App'

import {Provider} from 'react-redux'
import {store,persistor} from './05-redux/redux/store'

console.log(store)
ReactDOM.render(

    <Provider store={store}>
          <PersistGate loading={null} persistor={persistor}>
             <App/>
          </PersistGate>
        
    </Provider>

  ,document.getElementById("root"))
```

应该可以了





## 十三 UI组件库

## 十四 Immutable

 词义：adj.永恒的，不可改变的

https://github.com/immutable-js/immutable-js

作为一款插件，解决一个痛点。该插件的作用就是高性能的深复制数据，功能只是数据的处理，不关乎框架，

引入react的原因，是react的特性，单向数据流，在修改data的时候，不能改变原数据，使用场景多一点而已。

### 1. 痛点引入

#### 第一步：

   ```
// 引用复制 (浅复制)
var obj = {
    name:"zhangsan"
}

var obj2 = obj
obj2.name = "xiaomoing"
console.log(obj,obj2)//  {name: 'xiaomoing'} {name: 'xiaomoing'}
结论：变量直接等于，指针变化而已，数据源同一个，一旦修改，原数据也跟着改变。
   ```

#### 第二步：

```javascript
// 比浅复制多复制了一层
var myobj = {
    name:"zhangsan",
    arr:[1,2,3]
}
var myobj2 = {  // 使用解构复制
    ...myobj   
}
myobj2.name = "xiaoming"
myobj2.arr.splice(1,1)

console.log(myobj,myobj2) 
//{arr: [1, 3], name: "zhangsan" }  {arr: [1, 3], name: "xiaoming" } 
 结论：表层数据没有影响，深层解构还是修改了
```

#### 第三步:

```javascript
// json-parse json-stringify -深复制- 不能有undefined

var jsonobj ={
    name:"zhangsan",
    arr:[1,2,3],
    address:undefined
}

var jsonobj2 = JSON.parse(JSON.stringify(jsonobj))
jsonobj2.name = "xiaoming"
jsonobj2.arr.splice(1,1)

console.log(jsonobj,jsonobj2)
//{arr: [1,2, 3], name: "zhangsan" }  {arr: [1, 3], name: "xiaoming" } 
结论：成功复制，切没有改变原数据。 但是复制的数据中不能有undefined，会丢失掉。
// deepcopy
// 递归深复制-一层层复制， 性能不好，占用内存，因为这个方法，它是完整的复制了一份数据。
```

### 2.Immutable介绍

#### Immutable功能：

每次修改一个  Immutable  对象时都会创建一个新的不可变的对象，在新对象上操作并不会影响到原对象的数据。

#### Immutable优化性能的方式：

Immutable 实现的原理是
Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免
deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了
Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享

![](https://upload-images.jianshu.io/upload_images/2165169-cebb05bca02f1772)



## 3.插件使用

 ```
# using npm
  1. npm i immutabel
  2. import {Map} from 'immutable'
 ```

### 对象的使用和修改 Map方法

```
import React, { Component } from 'react'
import {Map} from 'immutable'

var obj = {
    name:"zhangsan",
    age:100
}

var oldImmuObj = Map(obj)     //Map把对象转化成immutable对象
var newImmuObj = oldImmuObj.set("name","xiaoming") //.set(key , value) 形式修改对象值
// console.log(oldImmuObj,newImmuObj) // 没有修改原数据

//1 get获取immutalble 

console.log(oldImmuObj.get("name"),newImmuObj.get("name"))// 获取immutable对象的值

//2 immutable===>普通对象

console.log(oldImmuObj.toJS(),newImmuObj.toJS()) //.toJS()方法，还原成普通的js对象
```

### 案例01:Map方法set方法toJS方法

使用Map方法，修改name,age，并更新视图。此案例：immutable仅参与数据处理，不参与视图显示

```
import React, { Component } from 'react'
import {Map} from 'immutable'

export default class App extends Component {

    state = {
        info:{
            name:"zs",
            age:100
        }
    }
    render() {
        return (
            <div>
                
                <button onClick={()=>{
                
  var old = Map(this.state.info) //1.数据类型转化
 var newImmu = old.set("name","xiaoming").set("age",18) //2.数据处理
                    this.setState({
                        info:newImmu.toJS()  //3.数据还原
                    })
                    
                }}>click</button>
                {this.state.info.name}--
                {this.state.info.age}
            </div>
        )
    }
}
```

### 案例2

immutable应用于深层数据结构使用方法，和基于不修改保持不变的特性的利用

下面案例展示：

01.深层级数据filter，也要加上Map，否则会影响原数据

02.利用不修改不变换原理，可以减少子组件的重复渲染



```
import React, { Component } from 'react'
import {Map} from 'immutable'
export default class App extends Component {

    state = {
        info:Map({
            name:"kerwin",
            select:"aa",
            filter:Map({
                text:"",
                up:true,
                down:false
            })
        })
    }

    componentDidMount() {
        console.log(this.state.info.get("filter"))
    }
    
    render() {
        return (
            <div>
                <button onClick={()=>{
                    this.setState({
                        info:this.state.info.set("name","xiaoming").set("select","bb")
                    })
                }}>click</button>
                {this.state.info.get("name")}
                <Child filter={this.state.info.get("filter")}/>
            </div>
        )
    }
}


class Child extends Component{
    shouldComponentUpdate(nextProps, nextState) { // 生命周期函数，是否渲染组件，false则不变
        if(this.props.filter === nextProps.filter){
            return false
        }
        return true
    }
    
    render(){
        return <div>
            child
        </div>
    }

    componentDidUpdate(){
        console.log("componentDidUpdate")
    }
}
```

### 案例3 List方法

```javascript
import React, { Component } from 'react'
import {List} from 'immutable'
var arr = List([1,2,3])

var arr2 = arr.push(4) //不会影响老的对象结构
var arr3 = arr2.concat([5,6,7])
console.log(arr.toJS(),arr2.toJS(),arr3.toJS())
打印结果：
 [1, 2, 3]
 [1, 2, 3, 4]
 [1, 2, 3, 4, 5, 6, 7]
 
export default class App extends Component {
    state = {
        favor:List(["aaa","bbb","ccc"])  
 //immutable的数组，push,concat等正常的js方法，在这里都不会修改原数据。（为了减低学习成本，保持一致）
    }
    render() {
        return (
            <div>
                {
                    this.state.favor.map(item=>
                      <li key={item}>{item}</li>    
                    )
                }
            </div>
        )
    }
}
```

### 案例4 List方法的项目使用

演示list的获取，修改，删除

```react
import { List,Map } from 'immutable'
import React, { Component } from 'react'

export default class App extends Component {
    state = {
        info:Map({
            name:"kerwin",
            location:Map({
                province:"辽宁",
                city:"大连"
            }),
            favor:List(["读书","看报","写代码"])
        })
    }
    render() {
        return (
            <div>
                <h1>个人信息修改</h1>
                <button onClick={()=>{
                    this.setState({
                    info: this.state.info.set("name","xiaomng")
                     .set("location",this.state.info.get("location").set("city","沈阳"))
                    })
                }}>修改</button>
                <div>
                    {this.state.info.get("name")}
                    <br/>
                    {
                        this.state.info.get("location").get("province")
                    }
                    -
                    {
                        this.state.info.get("location").get("city")
                    }
                    <br/>
                    {
                        this.state.info.get("favor").map((item,index)=>
                        <li key={item}>{item}
                            <button onClick={()=>{
                                console.log(index)

                                this.setState({
                                    info:this.state.info.set("favor",
                                    this.state.info.get("favor").splice(index,1))
                                })
                            }}>del</button>
                        </li>    
                        )
                    }
                </div>
            </div>
        )
    }
}
```

### 案例5：fromJS setIn  updateIn方法

fromJS ：当不知道返回数据的层级，可以直接使用fromJS 。

.setIn(["层级1","层级2"],"要修改的新值")

.updateIn( [层级]， （）=>{})  // 第二个值是个回调，回调中返回的就是新值

```react
import { fromJS } from 'immutable'
import React, { Component } from 'react'

export default class App extends Component {
    state = {
        info:fromJS({
            name:"kerwin",
            location:{
                province:"辽宁",
                city:"大连"
            },
            favor:["读书","看报","写代码"]
        })
    }

    componentDidMount() {
        console.log(this.state.info)
    }
    

    render() {
        return (
            <div>
                <h1>个人信息修改</h1>
                <button onClick={()=>{
                    this.setState({
                        info: this.state.info.setIn(["name"],"xiaomng")
                        .setIn(["location","city"],"沈阳")
                    })
                }}>修改</button>
                <div>
                    {this.state.info.get("name")}
                    <br/>
                    {
                        this.state.info.get("location").get("province")
                    }
                    -
                    {
                        this.state.info.get("location").get("city")
                    }
                    <br/>
                    {
                        this.state.info.get("favor").map((item,index)=>
                        <li key={item}>{item}
                            <button onClick={()=>{
                                console.log(index)

                                // this.setState({
                                //     info:this.state.info.setIn(["favor",index],"11111") //数组的本质就是对象
                                // })

                                this.setState({
                                    info:this.state.info.updateIn(["favor"],(list)=>list.splice(index,1))
                                })
                            }}>del</button>
                        </li>    
                        )
                    }
                </div>
            </div>
        )
    }
}

```

### 案例6：Immutable+Redux的开发方式

  遵循Immutable化的数据，取值和修改的规则。

```react
//reducer.js
const initialState = fromJS({ category:"",
material:""
})
const reducer = (prevstate = initialState,action={})=>{ let {type,payload} = action
switch(type){
case GET_HOME:
var newstate =prevstate.set("category",fromJS(payload.category)) var newstate2 =newstate.set("material",fromJS(payload.material)) return newstate2;
default:
return prevstate
}
}


//home.js
const mapStateToProps = (state)=>{ return {
category:state.homeReducer.getIn(["category"]) || Map({}), material:state.homeReducer.getIn(["material"]) || Map({})
}
}

this.props.category.get("相关属性") this.props.category.toJS() //或者转成普通对象

```

建议： 有需要去使用，不要为了使用而使用。

## 十五 Mobx

https://cn.mobx.js.org/

这是一个媲美redux 和react-redux组合的状态管理工具，使用更方面。既然是对标插件，所以Mobx也有

Mobx和 mobx-**react** 的组合。

### 1.介绍

(1)     Mobx是一个功能强大，上手非常容易的状态管理工具。

(2)     Mobx背后的哲学很简单:  任何源自应用状态的东西都应该自动地获得。

(3)     Mobx利用getter和setter来收集组件的数据依赖关系，从而在数据发生变化的时

​        候精确知道哪些组件需要重绘，在界面的规模变大的时候，往往会有很多细粒度更新

![](https://cn.mobx.js.org/flow.png)

### 2.Mobx*与*redux的区别

1.Mobx写法上更偏向于OOP（面向对象）

2.对一份数据直接进行修改操作，不需要始终返回一个新的数据

3.并非单一store,可以多store。

4.Redux默认以JavaScript原生对象形式存储数据，而Mobx使用可观察对象

### 3.优缺点

##### 优点

a.   学习成本小

b.   面向对象编程, 而且对 TS 友好缺点：

##### 缺点

a.  过于自由：Mobx提供的约定及模版代码很少，代码编写很自由，如果不做一些约定，比较容易导致团队代码风格不统一，

b. 相关的中间件很少，逻辑层业务整合是问题。

### 4.Mobx的使用

项目引入

````
npm i mobx@5    // 普及率较高的版本

import {observable,autorun} from 'mobx'  // <----- 1.引入核心方法   

var observableNumber = observable.box(10)  // <----- 2.创建数据

autorun(()=>{            // <----- 3.创建监听者
    console.log("number改变了",observableNumber.get())
})
````



##### 4.1 简单变量的监听

###### 案例1:

核心方法

observable ：将普通js数据，变成可以监听的状态，返回了一个增益属性和方法的对象。

autorun：自动监听  并且只关注指定的数据对象变化，就触发。

mobx对象的修改和提取值    

```
 mobxObj.get()  提取值
 mobxObj.set(新值)  设置新的值
 
```



  执行效果：页面加载后，会首先执行一次，监听数据创建，进入监听，后续数据状态变化，开始工作。

```
import React, { Component } from 'react'
import {observable,autorun} from 'mobx'  // <----- 1.引入核心方法

//对于普通类型数据的监听
var observableNumber = observable.box(10)  // <----- 2.创建数据
var observableName = observable.box("tom")

第一个自动监听
autorun(()=>{            // <----- 3.创建监听者
    console.log("number改变了",observableNumber.get())
})
第二个自动监听
// 第一次执行， 之后每次改变也会执行
autorun(()=>{
    console.log("name改变了",observableName.get())
})

setTimeout(()=>{
    observableNumber.set(20)
    observableName.set("xiaoming")
},1000)

测试结果： 1s后，两个autorun监听打印
加载页面打印；
number改变了 10
name改变了 tom
   1s后打印
number改变了 20
name改变了 xiaoming
```

###### 案例2: 监听规则

```react
import React, { Component } from 'react'
import {observable,autorun} from 'mobx'

//对于普通类型数据的监听
var observableNumber = observable.box(10)
var observableName = observable.box("kerwin")

autorun(()=>{   //autorun01
    console.log("number改变了",observableNumber.get())
})
// 第一次执行， 之后每次改变也会执行
autorun(()=>{  //autorun02
    console.log("name改变了",observableName.get())
})

setTimeout(()=>{
    observableNumber.set(20)
},1000)

setTimeout(()=>{
    observableName.set("xiaoming")
},2000)

export default class App extends Component {
    render() {
        return (
            <div>
                app
            </div>
        )
    }
}
测试结果：
autorun01 1s后打印
autorun02 2s后打印
```

###### 案例3

```
import React, { Component } from 'react'
import {observable,autorun} from 'mobx'

//对于普通类型数据的监听
var observableNumber = observable.box(10)
var observableName = observable.box("tom")

autorun(()=>{
    console.log("number改变了",observableNumber.get())
    console.log("name改变了",observableName.get())
})

setTimeout(()=>{
    observableNumber.set(20)
},1000)

setTimeout(()=>{
    observableName.set("xiaoming")
},2000)
测试结果：
第一次打印
tom 10
一秒钟后
tom 20
两秒钟后
xiaoming 20 
    说明autorun判断自己内部有数据变化，就会自动把自己内部js执行一遍。所以项目使用时，要注意。
```

#### 4.2 对象的监听方法

第一种：声明和修改方法

```
import React, { Component } from 'react'
import {observable,autorun} from 'mobx'

var myobj = observable.map({  // <----- 重点 声明方法
    name:"tom",
    age:100
})

autorun(()=>{
    console.log("对象的name属性改变了",myobj.get("name")) // <-----3s后打印修改后的值xiaoming
})
setTimeout(()=>{
    myobj.set("name","xiaoming")  // <----- 重点  修改方法
},3000)
```

第二种：声明和修改方法

```
import React, { Component } from 'react'
import {observable,autorun} from 'mobx'

var myobj = observable({  // <----- 重点 声明方法
    name:"kerwin",
    age:100
})

autorun(()=>{
    console.log("对象的name属性改变了",myobj.name)
})
setTimeout(()=>{
    myobj.name= "xiaoming"   // <----- 重点  修改方法
},1000)
```

### 5.项目中使用页面配置（无ES7语法）

##### 第一种数据修改无监管情况下  

（各个页面都可以修改，过于随意，出现bug，不好查找。）

store.js 数据仓库

```
import {observable, } from 'mobx'


const store = observable( {
    isTabbarShow:true,
    list:[],
    cityName:"北京",

})

export default store
```

App.js

使用仓库数据   

```react
import React, { Component } from 'react'

import {autorun } from 'mobx'
import store from './mobx/store'  <--- 重点   引入仓库

class App extends Component { 
    state = {
        isShow:false
    }
    
    componentDidMount() {
        autorun(()=>{
            this.setState({
                isShow:store.isTabbarShow   <--- 重点   使用数据并保存到组件state
            })
        })
    }
    
    render() {
        return (
           <div>
                <MRouter>
                    {this.state.isShow && <Tabbar></Tabbar>} <--- 重点 
                </MRouter>
           </div>
        )
    }
}

export default App

```

detail.js 详情页面

引入同一个数据仓库 store,直接修改store数据

```
import React,{useEffect} from 'react'
import store from '../mobx/store'

export default function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")

    useEffect(() => {
    
        store.isTabbarShow = false  <--- 重点 
        return () => {
            console.log("destroy")
            store.isTabbarShow = true  <--- 重点 
        }
    }, [])

    return (
        <div>
            deteail
        </div>
    )
}
```

##### 第二种数据修改- 严格模式

开启严格模式下  数据修改只能在store中注册事件，否则报错。

开启方式

```react
关键代码：
import {observable,configure } from 'mobx'

const store = observable( {
    isTabbarShow:true,
    list:[],
    cityName:"北京",

})

configure({
    // enforceActions:'always'  开启严格模式
    enforceActions:'never'  不开启
})
```

页面使用的参数配置   **configure**  **action** 严格模式配置

store.js配置

```react
import {observable,configure ,action } from 'mobx'

const store = observable( {
    isTabbarShow:true,
    list:[],
    cityName:"北京",
    changeShow(){
        this.isTabbarShow = true
    },
    changeHide(){
        this.isTabbarShow = false
    }
},{
    changeHide:action,
    changeShow:action //标记两个方法是action，专门修改可观测的value
})

configure({
    enforceActions:'always'
})

export default store
```

detail.js详情页面

```react
import React,{useEffect} from 'react'
import store from '../mobx/store'

export default function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")

    useEffect(() => {
        // console.log("create")
       // store.isTabbarShow = false   
        store.changeHide()    <--- 重点  调用方法  不能直接修改了
        return () => {
            console.log("destroy")

            //store.isTabbarShow = true
             store.changeShow()   <--- 重点  调用方法  不能直接修改了
        }
    }, [])

    return (
        <div>
            deteail
        </div>
    )
}

```

### 6.引入Es7 装饰器写法（严格模式下）

#### 装饰器：

```java
装饰器(Decorator)是ES7的一个语法，是一种与类相关的语法，用来注释或修改类和类的方法。

装饰器是一种函数，写成 @ + 函数名。它可以放在类和类方法的定义前面
class Store {
    @observable  isTabbarShow = true
    @observable  list = []

    @action changeShow(){   // @action相当于一个函数，把changeShow方法入参，吐出来一个增强函数
        this.isTabbarShow = true
    }

    @action changeHide(){
        this.isTabbarShow = false
    }


装饰器(Decorator) 也并不是一个新的概念，其他语言比如 Java，Python等已经很早就有了，ES7中的装饰器(Decorator)借鉴了其他语言的写法，不过依赖于ES5的Object.defineProperty 方法 。
```

使用ES7装饰器语法，需要配置代码编辑器vscode ,  项目webpack 语法loader,编译成浏览器能解析的js。

##### 第一步： 调整vscode 

  让它不再认为ES7装饰器是个语法错误

​      点击 左上角 文件 --》  首选项 --》 输入experimentalDecorators   选中后，退出。

##### 第二步： webpack配置

1.

```
npm i @babel/core @babel/plugin-proposal-decorators @babel/preset-env
```

2.

**根目录下创建** **.babelrc**  配置如下

```
{
    "presets": [
        "@babel/preset-env"
    ],
    "plugins": [
        [
            "@babel/plugin-proposal-decorators",
            {
                "legacy": true
            }
        ]
    ]
}
```

3.

**根目录下创建** **conﬁg-overrides.js ** 配置如下

```
const path = require('path')
const { override, addDecoratorsLegacy } = require('customize-cra')

function resolve(dir) {
    return path.join(__dirname, dir)
}

const customize = () => (config, env) => {
    config.resolve.alias['@'] = resolve('src')
    if (env === 'production') {
        config.externals = {
            'react': 'React',
            'react-dom': 'ReactDOM'
        }
    }

    return config
};


module.exports = override(addDecoratorsLegacy(), customize())
```

4.

自定义覆盖webpack配置

```
npm i customize-cra react-app-rewired
```

作用：使用自己配置的启动方式

5.

修改package.json

```json
原来    启动命令是脚手架的快捷启动
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
 改为下面
  "scripts": {
    "start": "react-app-rewired start",
    "build": "react-app-rewired build", 
    "test": "react-app-rewired test", 
    "eject": "react-app-rewired eject" // 这个命令是吧配置暴露出来 操作不可逆 慎用
 },
...
 修改的目的： 启动时覆盖原来的启动方式，让项目读取.babelrc 和config-overrides重写配置； 然后再开启服务
  
  
```

##### 配置后项目写法

老写法

```
import {observable,configure ,action } from 'mobx'

const store = observable( {
    isTabbarShow:true,
    list:[],
    cityName:"北京",
    changeShow(){
        this.isTabbarShow = true
    },
    changeHide(){
        this.isTabbarShow = false
    }
},{
    changeHide:action,
    changeShow:action //标记两个方法是action，专门修改可观测的value
})

configure({
    enforceActions:'always'
})

export default store
```

新写法（这种更简洁）

```react
import {observable,configure ,action } from 'mobx'
    configure({
        enforceActions:'always'
    })

 class Store {
    @observable  isTabbarShow = true    
    @observable  list = []

    @action changeShow(){
        this.isTabbarShow = true
    }

    @action changeHide(){
        this.isTabbarShow = false
    }
    
const store = new Store()
export default store    
```

##### Mobx对异步的处理

store.js

runInAction 核心方法

```react
import {observable,configure ,action ,runInAction} from 'mobx'
import axios from 'axios'

configure({
    enforceActions:'always'  严格模式
})


class Store {
    @observable  isTabbarShow = true
    @observable  list = []

    @action changeShow(){
        this.isTabbarShow = true
    }

    @action changeHide(){
        this.isTabbarShow = false
    }

    @action async getList(){
        var list = await axios({
            url:"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159",
            method:"get",
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.0.4","e":"16395416565231270166529","bc":"110100"}',
                'X-Host': 'mall.film-ticket.cinema.list'
            }
        }).then(res=>{
            // console.log(res.data.data.cinemas)
           return res.data.data.cinemas
        })

        runInAction(()=>{   <--- 重点  处理异步
            this.list = list
        })
    }
}

const store = new Store()
export default store
```

detail.js详情 使用页面

```react
import React,{useEffect ,useState} from 'react'

import store from '../mobx/store'
import {autorun} from 'mobx'

export default function Cinemas(props) {

const [cinemaList,setCinemaList] = useState([])

    useEffect(() => {
        if(store.list.length===0){
            store.getList()
        }
        
        var unsubscribe  = autorun(()=>{
            console.log(store.list,store.isTabbarShow)

            setCinemaList(store.list)
        })

        return ()=>{
            //取消订阅？
            unsubscribe()  <--- 重点  处理多次注册监听
        }

    }, [])

    return (
        <div>
            {
    cinemaList.map(item=>
              <dl key={item.cinemaId} style={{padding:"10px"}}>
                  <dt>{item.name}</dt>
                   <dd style={{fontSize:"12px",color:"gray"}}>{item.address}</dd>
                  </dl>    
                    )
            }
        </div>
    )
}
```

#### 7.mobx-react 的使用

功能：简化mobx, 达到不用autorun监听，和取消监听的操作   即可获取数据。

```
npm i mobx-react@5   // 稳定版本
```

  项目改造如下

###### index.js（函数式组件和Class组件中 这个都是一样的配置）

```
import React from 'react'
import ReactDOM from 'react-dom'

import App from './10-mobx/04-router/App'

import {Provider}  from 'mobx-react'
import store from './10-mobx/04-router/mobx/store'

构建一个 父组件 -高阶组件mobx-react
ReactDOM.render(
    // <React.StrictMode>
    <Provider store={store}>    <--- 重点 加父组件 注入store数据
        <App/>
    </Provider>
    
    // </React.StrictMode>
    ,document.getElementById("root"))
```

###### app函数式组件

app.js 组件，直接变成无状态组件

```react
import React, { Component } from 'react'
import MRouter from './router/IndexRouter'
import Tabbar from './components/Tabbar'
import './views/css/App.css'

import { inject, observer } from 'mobx-react'

//构建一个 父组件 -高阶组件mobx-react
@inject("store")  // 注入数据
@observer  //构建父组件  高阶组件 包装app组件
class App extends Component {

    componentDidMount() {
        console.log(this.props.store.isTabbarShow)
    }
    render() {
        return (
           <div>
                {/* 其他的内容 */}
                <MRouter>
                    {this.props.store.isTabbarShow && <Tabbar></Tabbar>}
                </MRouter>
           </div>
        )
    }
}

export default App
```

###### 类组件中使用

调整点： 引入Observer组件， 组件内的jsx以箭头函数，返回。

```react
import React, { useEffect, useState } from 'react'

import { Observer } from 'mobx-react'
import store from '../mobx/store'
export default function Cinemas(props) {

    useEffect(() => {
        if (store.list.length === 0) {
            store.getList()
        }
        return () => {
            //取消订阅？
        }
    }, [])

    return (
        <div>
                  {/* // 函数式组件中 Observer执行监听和取消监听的方法 */}
            <Observer>  
            {() => {
                    return store.list.map(item =>
                        <dl key={item.cinemaId} style={{ padding: "10px" }}>
                            <dt>{item.name}</dt>
                            <dd>{item.address}</dd>
                        </dl>
                    )
                }
                }
            </Observer>

        </div>
    )
}
```

## 十六 TS

### 1.简介

TS对项目的帮助

举例：

```
项目中js写
let str = "tom";
   str.map(...) 
像这样的语法错误，webpack编译器是发现不了的， 它正常编译，然后打开浏览器，才会报错。这种语法发现时机明显延后，为了在代码编写过程中， 提前发现语法错误。 可以使用TS。 typeScript
```

官网

https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/

总结：

\1.    TypeScript  的定位是静态类型语言，在写代码阶段就能检查错误，而非运行阶段

\2.    类型系统是最好的文档，增加了代码的可读性和可维护性。

\3.    有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）等

\4.    ts最后被编译成js



创建TS版react项目

```
create-react-app my-app --template typescript

项目创建之初就要确定选型，TS和js还是不一样的。
```

项目创建可能会碰到的问题：

vscode 对TS有波浪线提示错误， 不能解析。

方法：1.更新vscode版本  2.react中有TS依赖包，contro+shift+p 选择使用工作区版本TS库。

### 2.变量声明

##### 字符串， 数字， 布尔

```
// 字符串， 数字， 布尔，

 var myname:string = "kerwin" //推荐写法 声明一个字符串   
 myname.substring(0,1)  // 如果myname上使用数字的方法，将报错。

var type = "123"   //初次声明的变量类型将默认为基准 后续再修改类型   会提示报错
type = 40  //报错


 var myage:number = 100  //推荐写法 声明一个数字
 myage.toFixed(1)

 var myshow:boolean = true  //推荐写法 声明一个布尔
 myshow = false 

 var my:string | number  ="kerwin"  //变量可以是数字或字符串
 my = 100

 var myany:any = 100  //变量可以是任意值

 export default {}
```

##### 数组

```
var list1:string[] = ["1","2","3",4]  //声明一个字符串型的数组 4是个数字  提示报错
list1.push("daa") //添加一个项  字符串可以
// list.push(4)  //添加一个项  数字类型不可以

var list2:number[] = [1,2,3]   //声明一个数字型的数组
list2.push(5) // 可以

var list3:(number | string)[] = [1,2,"aa","bbb"]//声明一个 包含数字或字符串类型的数组
list3.push("aaaa")  //字符串  可以

-----------------------------范型-----另一种写法---------------------------------
var mylist1:Array<string> = ["aa","bb","cc"]   //声明字符串数组
mylist1.push("dw")

var mylist2:Array<string|number> = [1,2,"aaa"]  //声明字符串或数字两种类型的数组
mylist2.push(3)  可以
mylist2.push(‘44’) 可以
```

##### 对象

接口概念:    接口描述一个形状，一个规范。 关键字 **interface**（n.（人机）界面  v.（通过界面或接口）连接）

```
// 对象  接口
 interface IObj {
     name:string,
     age:number,
     location?:string,   //  可选属性
     [propName:string]:any //propName 其余属性省略 值 任意 
 }


 var obj1:IObj = {  //接口使用
     name:"kerwin",  //字符串
     age:100,  //数字
     
     location:"大连", //可写可不写
     
     grade: "7.7",      //不限制是否存在  key value 任意
    isPresale: true, //不限制是否存在  key value 任意
    isSale: false,//不限制是否存在  key value 任意
    item: {name: "4D", type: 13},//不限制是否存在  key value 任意
 }
 
console.log(obj1.location) //使用没有的key。会提示
```

##### 函数

```
// 案例1 声明一个test1方法  入参a 字符串 b 字符串 c 可选 数字  返回值：字符串
 function test1(a:string,b:string,c?:number):string{
    console.log(a.substring(0,1)+b.substring(0,1))

    return a.substring(0,1)+b.substring(0,1)
 }

 var myname:string = test1("aaa","bbb",100) // 调用
 console.log(myname)

 //---------------------------------

// 案例2  为方法 创建接口 入参a 字符串 b 字符串 c 可选 数字  返回值：字符串
 interface IFunc{(a:string,b:string,c?:number):string}

//    声明一个myfunc2使用IFunc接口限制
 var myfunc2:IFunc = function test1(a:string,b:string,c?:number):string{
    console.log(a.substring(0,1)+b.substring(0,1))

    return a.substring(0,1)+b.substring(0,1)
 }


// 案例3 创建一个接口  包含属性和方法
 interface Iobj {
     name:string,
     age:number,
     getName:(name:string)=>string
 }
// 案例3 声明一个对象 使用接口Iobj
 var obj:Iobj = {
     name:"kerwin",
     age:100,
     getName:(name:string)=>{
         return name
     }
 }

 var name:string =  obj.getName("aaaa")//入参不是字符串的话提示错误
console.log(name)
export default {}
```

##### 类

```
class Bus {
    public name = "kerwin" //共有属性
    private _list: any = [] //私有变量   _下划线  君子协定 默认为私有变量

    protected age = 100   //孩子可以使用
    public subscribe(cb: any) { // 设置为共有方法
        this._list.push(cb)
    }

    public dispatch() {  // 设置为共有方法
        this._list.forEach((cb: any) => {
            cb && cb()
        })
    }
}


class Child extends Bus {

    aaa() {
        console.log(this.name, this.age) //除了Bus的私有 其他可以使用
    }
}

var obj = new Bus()  //除了Bus的私有 其他可以使用
obj.subscribe(() => {

})

console.log(obj.name)
//  obj._list = [] // 下划线也可以使用  除非加了属性private限制
//  console.log(obj._list)


export default {}
```

##### 类+接口

```react
// 1. 创建一个接口  要求使用本接口的对象 必须要有以下两个方法
 interface Ifunc {
    getName:()=>string,  //并且 返回值 为字符串
    getAge:()=>number //并且 返回值 为数字
}

class A implements Ifunc{ // 声明一个类 实现（implements）接口Ifunc
    getAge(){
        return 100
    }
    a1(){

    }

    a2(){

    }

    getName(){
        return "AAA"
    }
}

class B implements Ifunc{ // 声明一个类 实现（implements）接口Ifunc
    getAge(){
        return 100
    }
    b1(){

    }

    b2(){

    }

    getName(){
        return "CCC"
    }
}

class C implements Ifunc{ // 声明一个类 实现（implements）接口Ifunc
    getAge(){
        return 100
    }
    getName(){
        return "CCC"
    }
}

function init(obj:Ifunc){ //创建一个函数  入参obj需要符合接口Ifunc的形状
    obj.getName()
    obj.getAge()
}
var objA = new A()
var objB = new B()
var objC = new C()

init(objA)
init(objB)
init(objC)
```

#### 3.TS-类组件











## 十七 styled-components

## 十八 单元测试

## 十九 redux-saga

## 二十 React补充

## 二十一 React扩展

## 二十二 前端代理（反向代理）

官网：

 https://facebook.github.io/create-react-app/docs/proxying-api-requests-in-development

 引入插件

```
npm install http-proxy-middleware --save
```

src下创建 src/setupProxy.js文件，参数如下

```

const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) { app.use(
  '/api', createProxyMiddleware({
    target: 'http://localhost:5000', 
    changeOrigin: true,
   })
   );
};
表示：代理拦截/api开头的请求，并在其url前面加上http://localhost:5000域名。
```



案例：某眼电影接口

```
https://i.maoyan.com/#movie/.f-hot
```

请求待映列表数据，直接使用提示跨域。

```
https://i.maoyan.com/ajax/mostExpected?limit=10&offset=0&token=&optimus_uuid=B13246E07BC511EE8C86B72966AD43929DD65EA435C340D6A572D95977F59FCA&optimus_risk_level=71&optimus_code=10
```

项目配置如下：

setupProxy.js文件

```
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) {
  app.use(
    '/ajax',
    createProxyMiddleware({
      target: 'https://i.maoyan.com',
      changeOrigin: true,
    })
  );
};
```

组件如下:   

```
import React, {  Component } from 'react'
import axios from 'axios'
export default class Comingsoon extends Component {

  componentWillMount(){
    axios({
        url:"/ajax/mostExpected?limit=10&offset=0&token=&optimus_uuid=B13246E07BC511EE8C86B72966AD43929DD65EA435C340D6A572D95977F59FCA&optimus_risk_level=71&optimus_code=10", 
    }).then(res=>{
        // console.log(res.data.data.films) 成功返回数据
    
    })
  }
    render() {
        return (
            <div>
                Comingsoon
            </div>
        )
    }
}

```

## 二十三  css module

官网

https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet

引入背景：

react是单页面， 每个组件引入的css样式，编译时，会自动插入到index.html页面中，造成样式污染。

film.css

```
.father{
  border: 1px solid red;
}
```

film组件

```
import '../css/film.css' //导入 css模块，  webpack的支持。

        return (
                <div className='father'>导航栏</div>
```

子组件

```
  render() {
        return (
            <div className='father'>
                Comingsoon
            </div>
```

父组件引入的样式， 污染到了子组件。

解决方式：

file.css 文件名字，改造为film.module.css   规定写法

```
.father{
  border: 1px solid red;
  .child{
    color: yellow;
  }
}
#id{
  color: red;
}


私有样式文件中  写全局css   ；建议如果是项目全局css, 单独新建一个 common.css 比较好。
:global(.active){

}

```

film.js组件

```
import style from  '../css/film.module.css' //导入 css模块，  webpack的支持。

    render() {
        return (
            <div>
                <div className={style.father +" othercss"}>导航栏</div>  
                //变量写法 因为类名加后缀动态化 私有化


css 打印出来变量名字 和js相似
console.log(style)
{
father: 'film_father__HgGKs', 
child: 'film_child__2Bvwp', 
id: 'film_id__2TOI9'
}

```











## 其他

### 1.函数式组件的注意点 

如果页面有axios请求，放到useEffect中，在页面实际情况中，函数式组件可能会执行多次，以确保数据都更新过来了。为避免接口多次请求，务必遵守。

```
import React,{useEffect} from 'react'
import { show,hide } from '../redux/actionCreator/TabbarActionCreator'
import store from '../redux/store'

export default function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")

    useEffect(() => {
        // console.log("create")

        //store.dispatch  通知
        store.dispatch(hide())
        return () => {
            console.log("destroy")
            store.dispatch(show() )
        }
    }, [])

    return (
        <div>
            deteail
        </div>
    )
}
```

### 2.自定义DOM属性

[React](https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020) 16 之前会忽略不是把的HTML和SVG属性，现在React会把不识别的属性传递给DOM

React16之前：

```
 <div cust-attr="someting"></div>
```

  会被渲染成

```
<div></div>　
```

React 16渲染出来的节点：

```
<div cust-attr="someting"></div>　　
```

### 3. Portals

https://blog.csdn.net/sxww_zyt/article/details/129253485

### 4.错误处理

https://blog.csdn.net/sxww_zyt/article/details/129253482

### 5.render新的返回类型

React16之前，rende[r方](https://so.csdn.net/so/search?q=r方&spm=1001.2101.3001.7020)法必须返回单个元素。现在，render支持两种新的返回类型：数组(有React元素组成)和字符串。

```
render() {
 return [
    <li key="a">a</li>,
    <li key="b">b</li>,
    <li key="c">c</li>
 ]
}
```



```
render() {
 return  "just a string";
}
```

### 6.列表和Keys

渲染列表数据是非常常见的场景，例如做一个展示用户的列表，需要根据获取的用户数据进行渲染列表。

运行后控制台报错：应该为列表每一项添加key(一般使用列表数据的id作为key)，[React](https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020)用Key标记每个元素，当数据变化时，React可以通过key知道哪些元素发生变化，从而只渲染发生变化的元素，提高渲染效率。

```
<User info={item.info} handleClick={this.handleClick} key={item.id}/>

```

**不推荐使用索引作为key**，因为一旦列表中的数据发生重排，数据的索引也会改变，不利于react渲染。**列表元素的key不能重复，但只限于当前列表，不是全局唯一**。

### 7.事件处理

https://blog.csdn.net/sxww_zyt/article/details/129253483

### 8.实现自定义createElement和render

https://blog.csdn.net/sxww_zyt/article/details/132900693







### hooks中记住状态的方式

useRef

### 关于生命周期

*1.类组件 Class Component* 有生命周期概念。

2.函数组件*Function Component* 不存在生命周期，

默认不能使用生命周期 如果要使用 那么就要使用HOOK来完成。

react16.8版本之后新增的一个概念

HOOK---useEffect

**useEffect就可以让函数组件使用生命周期---他会在 挂载完毕 修改完毕 准备销毁 这三个阶段都触发**

语法：

```javascript
useEffect(第一个参数是一个函数,第二个参数是一个数组)
```