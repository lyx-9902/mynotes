# react全家桶

## 一 React 介绍

## 二 create-react-app

## 三 编写一个react应用程序

## 四 JSX语法与组件

## 五 组件的数据挂载方式

**状态(state)**

状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态的目的就是为了在不同的状态下使组件的显示不同(自己管理）

### **(1)**  **定义**  **state**

第一种方式

```
import React, { Component } from 'react' import ReactDOM from 'react-dom'

class App extends Component { 
    state = {
      name: 'React', isLiked: false
    }
    render () { 
        return (
        <div>
            <h1>欢迎来到{this.state.name}的世界</h1>
                <button>
                {
                this.state.isLiked ? '❤取消' : '🖤收藏'
                }
                </button>
        </div>
        )
       }
    }
ReactDOM.render(
<App/>, document.getElementById('root')
)

```

另一种方式

```
import React, { Component } from 'react' import ReactDOM from 'react-dom'

class App extends Component { 
    constructor() {
        super() 
        this.state = {
        name: 'React', isLiked: false
        }
    }
    
        render () { 
        return (
            <div>
               <h1>欢迎来到{this.state.name}的世界</h1>
                <button>
                {this.state.isLiked ? '❤取消' : '🖤收藏'}
                </button>
            </div>
        )
        }
    }
ReactDOM.render(
<App/>, document.getElementById('root')
)

```

this.state 是纯js对象,在vue中，data属性是利用Object.defineProperty 处理过的，更改data的数据的时候会触发数据的getter 和setter ，但是React中没有做这样的处理，如果直接更改的话， react是无法得知的，所以，需要使用特殊的更改状态的方法 setState 。

### **(2)**  **setState**

isLiked 存放在实例的 states对象当中，组件的render 函数内，会根据组件的states的中的isLiked 不同显示“取消"或“收藏"内容。下面给button加上了点击的事件监听。

```
import React, { Component } from 'react' import ReactDOM from 'react-dom'

class App extends Component { 
    constructor() {
        super() 
        this.state = {
        name: 'React', isLiked: false
        }
    }

    handleBtnClick = () => { this.setState({
    isLiked: !this.state.isLiked
    })
  }
  
render () { 
    return (
    <div>
         <h1>欢迎来到{this.state.name}的世界</h1>
        <button onClick={this.handleBtnClick}>
            {
            this.state.isLiked ? '❤取消' : '🖤收藏'
            }
        </button>
    </div>
    )
    }
}
ReactDOM.render(
<App/>, document.getElementById('root')
setState 有两个参数
```

第一个参数可以是对象，也可以是方法return一个对象，我们把这个参数叫做 updater

参数是对象

```
this.setState({
isLiked: !this.state.isLiked
})
```

参数是方法

```
this.setState((prevState, props) => { return {
        isLiked: !prevState.isLiked
        }
})

```

注意的是这个方法接收两个参数，第一个是上一次的state,  第二个是props .

setState 是异步的，所以想要获取到最新的state，没有办法获取，就有了第二个参数，这是一个可选的回调函数

```
this.setState(
(prevState, props) => { 
return {
    isLiked: !prevState.isLiked
}, 
    () => {
    console.log('回调里的',this.state.isLiked)
    }
)
console.log('setState外部的',this.state.isLiked)

```

### (3)属性(props)

props 是正常是外部传入的，组件内部也可以通过一些方式来初始化的设置，属性不能被组件自己更改，但是你可以通过父组件主动重新渲染的方式来传入新的属性是描述性质、特点的，组件自己不能随意更改。

之前的组件代码里面有props 的简单使用，总的来说，在使用一个组件的时候，可以把参数放在标签的属性当中，所有的属性都会作为组件参数来接收props :

```
(1) 在组件上通过key=value 写属性,通过this.props获取属性,这样组件的可复用性提高了.
(2) 注意在传参数时候，如果写成isShow="true" 那么这是一个字符串,如果写成isShow={true} 这个是布尔值。
(3) {...对象} 展开赋值
(4) 默认属性值

*.defaultProps = {
     默认都是空，或者写入
   }
  static defaultProps = { 
  myname:"默认的myname", myshow:true
}

(5) prop-types 属性验证
import propTypes from "prop-types";

*.propTypes={
     name:propTypes.string, age:propTypes.number
}

static propTypes={ 
        myname:propTypes.string,
        myshow:propTypes.bool
    }

```

### （4）属性  vs  状态

相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）

不同点：

\1.    属性能从父组件获取，状态不能

\2.    属性可以由父组件修改，状态不能

\3.    属性能在内部设置默认值，状态也可以，设置方式不一样

\4.    属性不在组件内部修改，状态要在组件内部修改

\5.    属性能设置子组件初始值，状态不可以

\6.    属性可以修改子组件的值，状态不可以



state的主要作用是用于组件保存、控制、修改自己的可变状态。 state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state  是一个局部的、只能被组件自身控制的数据源。

state中状态可以通过 this.setState 方法进行更新， setState 会导致组件的重新渲染。

props的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 ，否则组件的不变。

没有state-的组件叫无状态组件(stateless component)，设置了 state的叫做有状态组件(stateful component)。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。

### (5)渲染数据

条件渲染

```
{
condition ? '渲染列表的代码' : '空空如也'
}
```

列表渲染

```
// 数据
const people = [
{ id: 1,name: 'Leo', age: 35}, 
{id: 2,name: 'XiaoMing', age: 16
}]
// 渲染列表
{
    people.map(person => { return (
        <dl key={person.id}>
        <dt>{person.name}</dt>
        <dd>age: {person.age}</dd>
        </dl>
        )
    })
}

```

React的高效依赖于所谓的Virtual-DOM，尽量不碰DOM。对于列表元素来说会有一个问题:元素可能会在一个列表中改变位置。要实现这个操作，只需要交换一下DOM位置就行了，但是React并不知道其实我们只是改变了元素的位置，所以它会重新渲染后面两个元素(再执行Vitual-DOM )，这样会大大增加DOM操作。但如果给每个元素加上唯一的标识，React就可以知道这两个元素只是交换了位置，这个标识就是key，这个key必须是每个元素唯一的标识

dangerouslySetInnerHTML

对于富文本创建的内容，后台拿到的数据是这样的

```
content = "<p>React.js是一个构建UI的库</p>"
```

处于安全的原因，React当中所有表达式的内容会被转义，如果直接输入，标签会被当成文本。这时候就需要使用dangerouslyS.etHTML属性，它允许我们动态设置innecHTML

```
import React, { Component } from 'react' import ReactDOM from 'react-dom'

class App extends Component { 
       constructor() {
        super() this.state = {
            content : "<p>React.js是一个构建UI的库</p>"
        }
    }
render () { 
   return (
        <div
        // 注意这里是两个下下划线  __html 
        dangerouslySetInnerHTML={{ __html: this.state.content}}
        />
        )
     }
}

ReactDOM.render(
<App/>, document.getElementById('root')
)

```







## 六表单中的受控租金按和非受控组件

## 七 组件通信的方式

### **1.**   父子组件通信方式

(1)    父传子  看props小节

父组件中，在引用的子组件上，k：v方式传递，

子组件使用props接收。

(2)     传递数据(父传子)与传递方法(子传父)

```
传递方法(子传父) 
父组件把修改自己数据的方法，通过变量，使用子组件传递过去。子组件使用this.props接受
import React, { Component } from 'react'

子组件
class Navbar extends Component{
    render(){
        return <div style={{background:"red"}}>
            <button onClick={()=>{
                   console.log("子通知父， 让父的isSHow 取反。",this.props.event) 

                   this.props.event() //调用父组件传来啊的回调函数
            }}>click</button>
            <span>navbar</span>
        </div>
    }
}
父组件
export default class App extends Component {
    state = {
        isShow:false
    }

    handleEvent = ()=>{
        this.setState({
            isShow:!this.state.isShow
        })
        // console.log("父组件定义的event事件")
    }
    render() {
        return (
            <div>
                <Navbar event={this.handleEvent}/>
                {/* <button onClick={()=>{
                    this.setState({
                        isShow:!this.state.isShow
                    })
                }}>click</button> */}
                {this.state.isShow && <Sidebar/>}
            </div>
        )
    }
}
```

(2)     ref标记 (父组件拿到子组件的引用，从而调用子组件的方法)

在父组件中清除子组件的input输入框的value值。**this.refs.form.reset()**



### **2.**   非父子组件通信方式

#### **(1)**   **状态提升**  **(**中间人模式**)**

React中的状态提升概括来说,就是将多个组件需要共享的状态提升到它们最近的父组件上.在父组件上改变这个状态然后通过props分发给子组件. （实质还是父子通信方式）

```
import React, { Component } from 'react'
import axios from 'axios'
import './css/03-communination.css'
export default class App extends Component {

    constructor(){
        super()
        this.state = {
            filmList:[],
            info:""
        }
    }
    数据来自互联网
    https://m.maizuo.com/v5/#/films/nowPlaying
    componentDidMount(){
        axios.get(`/test.json`).then(res=>{
            console.log(res.data.data.films)
            this.setState({
                filmList:res.data.data.films
            })
        })
    }

    render() {
        return (
            <div>
                {/* {this.state.info} */}
                {
                    this.state.filmList.map(item=>
                        <FilmItem key={item.filmId} {...item} onEvent={(value)=>{
                            // console.log("父组件接受",value)

                            this.setState({
                                info:value
                            })
                        }}></FilmItem>    
                    )
                }


                <FilmDetail info={this.state.info}></FilmDetail>
            </div>
        )
    }
}

/*受控组件*/
class FilmItem extends Component{
    render(){
        // console.log(this.props)
        let {name, poster,grade,synopsis}  = this.props
        return <div className="filmitem" onClick={()=>{
            // console.log(synopsis)
            this.props.onEvent(synopsis)
        }}>
            <img src={poster} alt={name}/>
            <h4>{name}</h4>
            <div>观众评分：{grade}</div>
        </div>
    }
}

class FilmDetail extends Component{
   
    render(){
        console.log(this.props)
        return <div className="filmdetail">
            {this.props.info}
        </div>
    }
}
```



#### **(2)**   发布订阅模式实现

纯js实现 ，谁订阅，谁接受，抛弃了父子孙关系。

```
/*
 * @作者: kerwin
 * @公众号: 大前端私房菜
 */
import React, { Component } from 'react'

export default class App extends Component {
    render() {
        return (
            <div>
                app
            </div>
        )
    }
}

//调度中心
var bus = {

    list:[],
    //订阅
    subscribe(callback){
        // console.log(callback)

        this.list.push(callback)
    },

    //发布
    publish(text){
        //遍历所有的list， 将回调函数执行
        // console.log(this.list)

        this.list.forEach(callback=>{
            callback && callback(text)
        })
    }
}


// 订阅者
bus.subscribe((value)=>{
    console.log("11111",value)
})

bus.subscribe((value)=>{
    console.log("2222",value)
})



//发布者

setTimeout(()=>{
    bus.publish("男人看了沉默111")
},0)


// Redux 基于订阅发布 

```



#### **(3)**   **context** 状态树传参

```
import React, { Component } from 'react'
import axios from 'axios'
import './css/03-communination.css'

const GlobalContext  = React.createContext() //创建context对象

export default class App extends Component {

    constructor(){
        super()
        this.state = {
            filmList:[],
            info:""
        }
        axios.get(`/test.json`).then(res=>{
            console.log(res.data.data.films)
            this.setState({
                filmList:res.data.data.films
            })
        })
    }

    render() {
        return (
            <GlobalContext.Provider value={{
                call:"打电话",
                sms:"短信",
                info:this.state.info,
                changeInfo:(value)=>{
                    this.setState( {
                        info:value
                    })
                }
            }}>
                <div>
                    {/* {this.state.info} */}
                    {
                        this.state.filmList.map(item=>
                            <FilmItem key={item.filmId} {...item} ></FilmItem>    
                        )
                    }


                    <FilmDetail ></FilmDetail>
                </div>
            </GlobalContext.Provider>
        )
    }
}

/*受控组件*/
class FilmItem extends Component{
    render(){
        // console.log(this.props)
        let {name, poster,grade,synopsis}  = this.props
        return (
        <GlobalContext.Consumer>
           {
                (value)=>{
                    console.log(value)
                    
                    return <div className="filmitem" onClick={()=>{
                        console.log(synopsis)
                        // this.props.onEvent(synopsis)

                        // value.info = "2222222"

                        // console.log(value)

                        value.changeInfo(synopsis)
                    }}>
                        <img src={poster} alt={name}/>
                        <h4>{name}</h4>
                        <div>观众评分：{grade}</div>
                    </div>
                }
           }
        </GlobalContext.Consumer>
        )    
    }
}

class FilmDetail extends Component{
    render(){
        return (
            <GlobalContext.Consumer>
                {
                    (value)=><div className="filmdetail">
                        detail-{value.info}
                    </div>
                }
            </GlobalContext.Consumer>
        )
    }
}
```







## 八 React生命周期





## 九 React Hooks

### 1 用hooks理由

1. 高阶组件为了复用，导致代码层级复杂

2. 生命周期的复杂
3. 写成functional组件,无状态组件 ，因为需要状态，又改成了class,成本高

### 2. useState(保存组件状态)

```
const [list,setList] = useState(["aa","bb","cc"])
结构出list变量， 和修改list的唯一指定方法setList

案例: 点击按钮num+1; 在实际页面效果中，由于每次刷新，num都会回到初始值，无法达到目的。
import React,{useState,useRef} from 'react'
export default function App() {
    var num = 20;
    const [list,setList] = useState(["aa","bb","cc"])
    
```

### 3. useEffect(处理副作用)和useLayoutEffect (同步执行副作用)

Function Component 不存在生命周期，所以不要把 Class Component 的生命周期概念搬过来试图对号入座。

```
useEffect(() => {
//effect
return () => {
//cleanup
};
}, [依赖的状态;空数组,表示不依赖])
```

不要对 Dependencies 撒谎, 如果你明明使用了某个变量，却没有申明在依赖中，你等于向 React 撒了谎，后果
就是，当依赖的变量改变时，useEffect 也不会再次执行, eslint会报警告

```
let id = props.match.params.myid useEffect(()=>{
axios.get(`/articles/${id}`).then(res => { settitle(res.data.title) setcontent(res.data.content) setcategory(res.data.category)
})
},[id])
```

**useEﬀect**和 **useLayoutEﬀect**  有什么区别？

**简单来说就是调用时机不同，**
useLayoutEffect **和原来** componentDidMount **&** componentDidUpdate **一致，在 react完成DOM更新后马上**同步**调用的代码，会阻塞页面渲染。而**
useEffect **是会在整个页面渲染完才会调用的代码**



### 4. useRef（是hooks一种，一般在**函数组件使用**）

作用是：记住状态

```
export default function App() {
    const mytext = useRef() // React.createRef()
    
    const handleAdd = ()=>{
        console.log(mytext.current.value) // 获取值
    }
 
  return (<div>
            <input ref={mytext}/> 
               <button onClick={handleAdd}>add</button>
```

官方建议优先使用useEffect

在实际使用时如果想避免**页面抖动**（在useEffect 里修改DOM很有可能出现）的话，可以把需要操作DOM的代码放在useLayoutEffect 里。在这里做点dom操作，这些dom修改会和
react 做出的更改一起被一次性渲染到屏幕上，只有一次回流、重绘的代价

### **5. useCallback(**记忆函数**)**

防止因为组件重新渲染，导致方法被重新创建 ，起到缓存作用*;* 只有第二个参数 变化了，才重新声明一次。

```react
var handleClick = useCallback(()=>{ console.log(name)
},[name])
<button onClick={()=>handleClick()}>hello</button>

//只有name改变后，  这个函数才会重新声明一次，
//如果传入空数组，  那么就是第一次创建后就被缓存，  如果name后期改变了,拿到的还是老的name。
//如果不传第二个参数，每次都会重新声明一次，拿到的就是最新的name.

```

**useMemo** **记忆组件**

useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的

```react
useCallback(fn, inputs) is equivalent to useMemo(() => fn, inputs).
```

唯一的区别是：**useCallback** **不会执行第一个参数函数，而是将它返回给你，而** **useMemo** **会执行第一个函数并****且将函数执行结果返回给你。**所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。

所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。(类似与vue的计算属性)

### **6. useRef(**保存引用值**)**

```react
const myswiper = useRef(null);
<Swiper ref={myswiper}/>
```

ref 写在dom上是value值，写在组件上，是组件对象。



### 7. useContext（减少组件层级）

对class类组件中使用context方法，

在函数式组件中的简化写法。 提供端没有简化，接受端较大简化。

```react
import React, { useState,useEffect,useContext } from 'react'
import axios from 'axios'
import './css/index.css'

const GlobalContext  = React.createContext() //创建context对象

export default function App (){
    const [filmList, setfilmList] = useState([])
    const [info, setinfo] = useState("")

    useEffect(() => {
        axios.get(`/test.json`).then(res=>{
            // console.log(res.data.data.films)
            setfilmList(res.data.data.films)
        })
    }, []);

    return (
        <GlobalContext.Provider value={{
            call:"打电话",
            sms:"短信",
            info:info,
            changeInfo:(value)=>{
                setinfo(value)
            }
        }}>
            <div>
                {/* {this.state.info} */}
                {
                    filmList.map(item=>
                        <FilmItem key={item.filmId} {...item} ></FilmItem>    
                    )
                }


                <FilmDetail ></FilmDetail>
            </div>
        </GlobalContext.Provider>
    )
}

/*受控组件*/

function FilmItem(props){
    let {name, poster,grade,synopsis}  = props
    const value = useContext(GlobalContext)

    console.log(value)// 父组件GlobalContext.Provider 提供的值：call:"打电话",
    return <div className="filmitem" onClick={()=>{
                console.log(synopsis)

                value.changeInfo(synopsis)
            }}>
                <img src={poster} alt={name}/>
                <h4>{name}</h4>
                <div>观众评分：{grade}</div>
            </div> 
}



function FilmDetail(){
    const value = useContext(GlobalContext)
    return <div className="filmdetail">
        detail-{value.info}
    </div>
}
```

### 8.useReducer 的使用

功能：Hooks提供的一种，将组件状态提到外面的方法。

案例： 对count数字， +  -- 操作。

```react
import React,{useReducer} from 'react'
 //处理函数
 const reducer = (prevState,action)=>{
    //  console.log("reduercer",prevState,action)
     let newstate = {...prevState}
     switch(action.type){
         case "kerwin-minus":
            newstate.count--
            return newstate

         case "kerwin-add":
            newstate.count++
            return newstate
        
         default:
            return prevState
     }
 }
 // 外部的对象
 const intialState = {
     count:0,
    //  list:[]
 } 

 export default function App() {
     const [state, dispatch] = useReducer(reducer,intialState)
        console.log(state, dispatch)
     return (
         <div>
             <button onClick={()=>{
                 dispatch({
                     type:"kerwin-minus"
                 })
             }}>-</button>
             {state.count}
             <button onClick={()=>{
                 dispatch({
                    type:"kerwin-add"
                })
             }}>+</button>
         </div>
     )
 }
```

### 9.useReducer + useContext配合使用（减少组件层级）

  Hooks提供类似redux数据仓库理念的工具方法。

案例：app父组件， 传值给三个子组件，共享数据和方法。child1组件，点击，child2 child3视图变化。

```react
import React,{useReducer,useContext} from 'react'

const initailState = {
    a:"11111",
    b:"11111"
}

const reducer = (prevState,action)=>{
    let newstate = {...prevState}
    switch(action.type){
        case "change-a":
            newstate.a = action.value
            return newstate
        case "change-b":
            newstate.b = action.value
            return newstate
        default:
            return prevState
    }
    // return prevState
}

const GlobalContext = React.createContext()
export default function App() {
    const [state, dispatch] = useReducer(reducer, initailState)
    
    return (
        <GlobalContext.Provider value={
            {
                state,
                dispatch
            }
        }>
            <div>
                <Child1/>
                <Child2/>
                <Child3/>
            </div>
        </GlobalContext.Provider>
    )
}

function Child1(){
    const {dispatch} = useContext(GlobalContext)
    return <div style={{background:"red"}}>
        <button onClick={()=>{
            dispatch({
                type:"change-a",
                value:"2222222"
            })
        }}>改变a</button>
        <button onClick={()=>{
            dispatch({
                type:"change-b",
                value:"333333"
            })
        }}>改变b</button>
    </div>
}

function Child2(){
    const {state} = useContext(GlobalContext)
    return <div style={{background:"yellow"}}>
        child2-{state.a}
    </div>
}

function Child3(){
    const {state} = useContext(GlobalContext)
    return <div style={{background:"gray"}}>
        child3-{state.b}
    </div>
}
```



### 10 自定义hooks

功能： 页面逻辑更清晰，更好阅读，体现函数式变成思想。

实现： Hooks提供一种方法。 允许你将一个大方法，按一定逻辑，抽离出来写成一个use-开头的小方法，不用担心异步问题。每次修改，代码都会重新给出新值。

案例如下；

```
import React, { useState,useEffect,useMemo } from 'react'
import axios from 'axios'

**1 获取list数据方法
function useCinemaList(){
    const [cinemaList, setcinemaList] = useState([])


    useEffect(() => {
        axios({
            url:"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159",
            method:"get",
            headers:{
                'X-Client-Info': '{"a":"3000","ch":"1002","v":"5.0.4","e":"16395416565231270166529","bc":"110100"}',
                
                'X-Host': 'mall.film-ticket.cinema.list'

            }
        }).then(res=>{
            setcinemaList(res.data.data.cinemas)
        })
    }, [])

    return {
        cinemaList
    }
}
 **2获取筛选后的数据方法
function useFilter(cinemaList,mytext){
    const getCinemaList = useMemo(() => cinemaList.filter(item=>item.name.toUpperCase().includes(mytext.toUpperCase()) || 
    item.address.toUpperCase().includes(mytext.toUpperCase())
    ), [cinemaList,mytext])

    return {
        getCinemaList
    }
}

export default function Cinema(){
    const [mytext, setmytext] = useState("")
    
    const {cinemaList}  = useCinemaList()

    const {getCinemaList} = useFilter(cinemaList,mytext)

    return <div>
            {/* {this.state.mytext} */}
                <input value={mytext} onChange={(evt)=>{
                    setmytext(evt.target.value)
                }}/>
                {
                    getCinemaList.map(item=>
                        <dl key={item.cinemaId}>
                            <dt>{item.name}</dt>
                            <dd>{item.address}</dd>
                        </dl>    
                    )
                }
        </div>
}
```







### 小结解疑：

Q:  [react中useRef与createRef的区别](https://www.cnblogs.com/-roc/p/16943895.html)

A:   useRef()                   React.createRef()

useRef （是hooks一种，一般在**函数组件使用**）

1.1.获取当前dom数据（不推荐，推荐使用受控组件-即使用useState绑定表单元素）

1.2、作为存储使用

createRef（一般用于class组件，获取子组件dom）

1、createRef创建的ref对象，组件每更新一次，ref对象就会被重新创建。

区别

1.    useRef只会在组件首次渲染时创建

2.  createRef会在组件每次渲染的时候重新创建

   

   

## 十 React路由

### **1.**  什么是路由？

路由是根据不同的 url 地址展示不同的内容或页面。

一个针对React而设计的路由解决方案、可以友好的帮你解决React components 到URl之间的同步映射关系

### 2.路由安装

https://reacttraining.com/react-router/web/guides/quick-start

```
npm install react-router-dom@5

"react-router-dom": "^5.3.4",
```

### 3. 路由使用

####  (1)路由方法导入

```
import React from "react"; import {
 BrowserRouter as Router, Switch,
 Route, Link
  } from "react-router-dom";
```

#### (2)定义路由以及重定向 案例hash模式

  路由基本使用

```react
<HashRouter>
  <Route path="/films" component={Films}/>
    <Route path="/cinemas" component={Cinemas}/>
</HashRouter>
当浏览器http://localhost:3000/#/films时，展示对应组件。插件的基本功能就是匹配功能。
```

加功能1：

当用户输入的路径，没有对应页面时，跳到home页去。

```react
<HashRouter>
  <Switch>
         <Route path="/films" component={Films}/>
         <Route path="/cinemas" component={Cinemas}/>
      
       <Redirect from="/" to="/home" />   //from="/"  模糊匹配
   </Switch>
</HashRouter>
Switch嵌套路由，配合重定位标签。实现： 浏览器输入地址后，自上而下匹配，只要匹配到就跳出。没有匹配到，就重定位到home去。

```

加功能2：

当进入/ 根路由，就进入home去， 如果是 /abc  等乱输入的路径，就跳入到NotFound 未找到页面。

```react
<HashRouter>
    <Switch>
        <Route path="/films" component={Films}/>
        <Route path="/cinemas" component={Cinemas}/>
        <Route path="/center" component={Center}/>
        
        <Redirect from="/" to="/home" exact/>    
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
Redirect重定向标签，加exact精准属性，只有/，才进入home,其他情况，万能匹配，进入NotFound页面。
```



解析：

exact 精确匹配 (Redirect 即使使用了exact, 外面还要嵌套Switch 来用)；

Warning: Hash history cannot
PUSH the same path; a new entry will not be added to the history
stack,这个警告只有在hash 模式会出现。

#### (3)嵌套路由

页面效果：

父页面中显示轮播图和两个按钮  分别显示不同的子页面。

代码配置：

router.js  根路由

```
<HashRouter>
    <Switch>
        <Route path="/films" component={Films}/>   //不要加 exact 否则子页面不显示
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

films组件

```
import React, { Component } from 'react'
import Nowplaying from './films/Nowplaying'
import Comingsoon from './films/Comingsoon'
import {Redirect, Route, Switch} from 'react-router-dom'
export default class Films extends Component {
    render() {
        return (
            <div>
                <div style={{height:"200px",background:"yellow"}}>大轮播</div>

                <div>导航栏  按钮1  按钮2</div>

                {/* 路由配置 嵌套路由 */}
                <Switch>
                    <Route path="/films/nowplaying" component={Nowplaying}/>
                    <Route path="/films/comingsoon" component={Comingsoon}/>
                    <Redirect from="/films" to="/films/nowplaying"/> 
                </Switch>

            </div>
        )
    }
}

```

#### (4)路由跳转方式

按照是否以标签例如<a href='#/films'/>,还是js跳转页面，分类如下：

##### a.   声明式导航

activeClassName 当前显示页面，自动加class。配合css 可以高亮显示tab。

```
<NavLink to="/films" activeClassName="active">films</NavLink>   //react 浏览器中会编译成a标签
<NavLink to="/cinemas" activeClassName="active">cinemas</NavLink>
<NavLink to="/center" activeClassName="active">center</NavLink>
```

##### b   编程式导航

案例

###### router.js  根路由

```
<HashRouter>
    <Switch>
        <Route path="/films" component={Films}/>   
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

###### films组件

```
import React, { Component } from 'react'
import Nowplaying from './films/Nowplaying'
import Comingsoon from './films/Comingsoon'
import {Redirect, Route, Switch} from 'react-router-dom'
export default class Films extends Component {
    render() {
        return (
            <div>
                <div style={{height:"200px",background:"yellow"}}>大轮播</div>

                <div>导航栏</div>

                {/* 路由配置 嵌套路由 */}
            {/* <Nowplaying/> */}
                <Switch>
                    <Route path="/films/nowplaying" component={Nowplaying}/>
                    <Route path="/films/comingsoon" component={Comingsoon}/>
                    <Redirect from="/films" to="/films/nowplaying"/> 
                </Switch>

            </div>
        )
    }
}
```



###### Nowplaying组件

当项目引入路由管理，组件都传入router，这时候组件都成为router的孩子，不管是一级路由，还是页面中嵌入的二级路由，组件都可以接受到一个props参数，这个参数就是路由对象。

```javascript
对象中包含了和路由相关的属性和方法。
{
  history,(有路由相关方法： push go goBack goForward replace location等)
  location  
  match  
}
```

props参数  根据来源分为两种：

第一种：形参传入  有以上三个对象

第二种：使用router对象

```
import { useHistory } from 'react-router-dom'
 const history  = useHistory()
 conosole.log(history)
 这个里面只有 history一个； 范围小一些。
```

Nowplaying组件

```
import React,{useState} from 'react'
import { useHistory } from 'react-router-dom'

export default function Nowplaying( props ) {
    const [list, setlist] = useState(["aa","bb","cc"])
    
      const history  = useHistory()
        
    const handleChangePage = (id)=>{
        // console.log("click")
        //  1.原生js跳转
        // window.location.href="#/detail/"+id

        2.使用入参的props
        // props.history.push(`/detail/${id}`)   //函数式写法（）
        // this.props.history.push(`/detail/${id}`) // 类组件式写法
        
  第二种方式：使用 useHistory 方法来自 router插件提供
        //1 -动态路由传参
        // history.push(`/detail/${id}`)
    
        // 2- query传参
        // history.push({ pathname : '/detail' ,query : { myid: id} })

        // 3- state传参
        // history.push({pathname:"/detail",state:{myid:id}})
    }

    return (
        <div>
            {
                list.map(item=> <li onClick={()=>handleChangePage(item)}>{item}</li>)
            }
        </div>
    )
}
```

#### (5) 路由传参

##### 声明式传参

特征和优缺点：

 参数保存位置， url路径中。    当页面刷新，参数不会丢失。

router.js  根路由

```
<HashRouter>
    <Switch>
        {/* /detail/1111  动态路由 */}
         <Route path="/detail/:myid" component={Detail} /> 
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

###### Nowplaying组件   

列表组件  入参

```
如上代码快
...
 2.使用入参的props
 // props.history.push(`/detail/${id}`)   //函数式写法（）
...
```

detail 详情组件 接参

当前路径   http://localhost:3000/#/detail/bb

```
import React from 'react'

export default function Detail(props) {
    console.log(props.match.params.myid,"利用id去后端拿数据。")  //bb为参数值  myid为形参
    return (
        <div>
            deteail
        </div>
    )
}
```

##### 编程式传参    

特征和优缺点：

 参数保存位置， 缓存中。    当页面刷新，参数会丢失。

router.js  

根路由path="/detail" 这种传参就不要加形参  ：myid了。

```
<HashRouter>
    <Switch>
         <Route path="/detail" component={Detail} /> 
        <Route path="*" component={NotFound}/>
    </Switch>
</HashRouter>
```

###### 

```
(1)
   入参
this.props.history.push({ pathname : '/user' ,query : { day: 'Friday'} }) 
   接受参数
this.props.location.query.day
(2)
    入参
this.props.history.push({ pathname:'/user',state:{day : 'Friday' } }) 
  接受参数
this.props.location.state.day
代码参考（4）路由跳转方式小结。
  测试发现this.props.history.push传入的对象， pathname是必须按照格式，后面query state或是其他属性，都可以，只要在接受参数处，一一对应即可。
```

### 4. 路由拦截（路由守卫）

react 并没有像vue router.beforeEach路由前，路由后等api; 所以这里只是用原生函数方法。

router.js

```
鉴权代码 
function isAuth(){
    return localStorage.getItem("token")
}



<Router>
      <Switch>
          <Route path="/films" component={Films}  />
      <Route path="/center" render={(props)=>{
        return isAuth()?<Center myname="tom"/>:<Redirect to="/login"/>
      }/>                 
```

### 5 路由模式

##### hash模式

像这种带#号的，叫锚点，这里称hash模式。不发起请求。

如果不想看到这样，可以使用令一种模式。

```
http://localhost:3000/#/login

import React, { Component } from 'react'
import { HashRouter as Router,Redirect,Route,Switch} from 'react-router-dom'

export default class IndexRouter extends Component {
    render() {
        return (
            <Router>   模式标签
                <Switch>
                    <Route path="/films" component={Films}  />
```

##### history模式

http://localhost:3000/login     像一个真正的路径。

BrowserRouter 没有#的路径，好看 ，真正朝后端发请求要页面，后端没有对应的路径处理路径， 就会404， 不好看。所以后台要做处理，因为项目是单页面，后台并没有对应资源，只需要返回index.html，前台重新渲染。

```
import React, { Component } from 'react'
import { BrowserRouter as Router,Redirect,Route,Switch} from 'react-router-dom'
...
 <Router>   模式标签
 或者
 import { BrowserRouter,Redirect,Route,Switch} from 'react-router-dom'
...
 <BrowserRouter>  </BrowserRouter>  模式标签

```

BrowserRouter as Router 意为： BrowserRouter 解构出来，起了一个别名叫Router。 这样后面代码就不用改了。更加便捷。

### 6 组件丢爹history和干爹支援（高阶组件withRouter）

#### 第一种情况：router 传递页面组件 

##### 

首先确定，父组件传参，子组件props接受参数。

router.js

```
 <BrowserRouter>
                <Switch>
                    <Route path="/films" component={Films}  />
                    
                     <Route path="/center" render={()=>{
                        return isAuth()?<Center myname="tom"/>:<Redirect to="/login"/>
                    }}/>          
```

前面路由守卫时，center组件做了处理，当我们在center组件中，使用history方法时，页面提示未找到方法。

center组件 

```
export default function Center(props) {
    return (
        <div>
            center

            <div onClick={()=>{
                props.history.push(`/filmsorder`)

                // console.log(props)
            }}>电影订单</div>
        </div>
    )
}
```

前面我们提到，使用路由时，被路由标签   <Router>   </Router> 包裹的页面组件，都是子组件，自然可以接受props参数，包含history等。

查看route核心方法

```
// class Route extends Component{
//     ...

//     render(){
//         var MyComponent = this.props.component
//     return <div>
//             <MyComponent history={} match={}.../>
//         </div>
//     }
// }
```

route以变量形式，接受组件，传入参数，再render出去。而center这条路由，直接使用render，并没有传参，测试传递一个自定义参数myname, center组件中，打印props，果然看到参数tom,证实确实是route给出的东西，没有传递下去，导致子组件history方法缺失。

```
<Route path="/center" render={()=>{
                        return isAuth()?<Center myname="tom"/>:<Redirect to="/login"/>
                    }}/> 
```

改进, 解构，传参下去

```
    <Route path="/center" render={(props)=>{
                        console.log(props,'执行了')
                        return isAuth()?<Center myname="kerwin" {...props}/>:<Redirect to="/login"/>
                    }}/>
```

#### 第二种情况 组件传递组件

代码中，FilmItem小组件， props.history.push提示未找到，情况和第一种相似，都是参数在传递过程中，中断。

```
import React,{useState} from 'react'
export default function Nowplaying(props) {       <----------1这个props参数
    const [list, setlist] = useState([1,2,3,4])

    return (
        <div>
            {
                list.map(item=>
                 <FilmItem key={item.filmId} {...item} 	/>     <----------2这里 {...props}
                )
            }
        </div>
    )
}

function FilmItem(props){
    // console.log(props)  // 打印没有 props.history
    let {name,filmId} = props
    return <li onClick={()=>{
        props.history.push(`/detail/${filmId}`)
    }}>
        {name}
    </li>    
}
```

#### 干爹支援

父组件  ---> 子组件 ---> 孙组件， 有点麻烦，是否有其他便捷api？

router提供一个高阶组件，作用是为没有路由属性和方法的普通组件，增益方法。

```
import {withRouter} from 'react-router-dom'
```

使用方法：

```
import React,{useState} from 'react'
import {useHistory,withRouter} from 'react-router-dom'

export default function Nowplaying(props) {
    const [list, setlist] = useState([1,2,3,4])

    return (
        <div>
            {
                list.map(item=>
                 <WithFilmItem key={item.filmId} {...item} />
                )
            }
        </div>
    )
}

             这是一个普通孙组件           
function FilmItem(props){
    // console.log(props)
    let {name,filmId} = props
    return <li onClick={()=>{
        props.history.push(`/detail/${filmId}`)
    }}>
        {name}
    </li>    
}


const WithFilmItem = withRouter(FilmItem)  <----- withRouter方法，包裹普通组件，吐出来增益组件。这样，FilmItem中的onClick里面，就可以使用 props.history.push了。
```

#### withRouter   的应用与原理

You can get access to the history object's properties and the closest <Route>'smatch via the withRouter higher-order component.wi thRouter will pass updatedmatch, location, and history props to the wrapped component whenever itrenders.

```
只要被withRouter加工后，就可以获取到history相关。
 import { withRouter } from "react-router"; 
 withRouter(MyComponent); 
 withRouter(connect(...)(MyComponent))

```





## 十一  Flux与Redux

## 十二 react-redux

## 十三 UI组件库

## 十四 Immutable

## 十五 Mobx

## 十六 TS

## 十七 styled-components

## 十八 单元测试

## 十九 redux-saga

## 二十 React补充

## 二十一 React扩展

## 二十二 前端代理（反向代理）

官网：

 https://facebook.github.io/create-react-app/docs/proxying-api-requests-in-development

 引入插件

```
npm install http-proxy-middleware --save
```

src下创建 src/setupProxy.js文件，参数如下

```

const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) { app.use(
  '/api', createProxyMiddleware({
    target: 'http://localhost:5000', 
    changeOrigin: true,
   })
   );
};
表示：代理拦截/api开头的请求，并在其url前面加上http://localhost:5000域名。
```



案例：某眼电影接口

```
https://i.maoyan.com/#movie/.f-hot
```

请求待映列表数据，直接使用提示跨域。

```
https://i.maoyan.com/ajax/mostExpected?limit=10&offset=0&token=&optimus_uuid=B13246E07BC511EE8C86B72966AD43929DD65EA435C340D6A572D95977F59FCA&optimus_risk_level=71&optimus_code=10
```

项目配置如下：

setupProxy.js文件

```
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) {
  app.use(
    '/ajax',
    createProxyMiddleware({
      target: 'https://i.maoyan.com',
      changeOrigin: true,
    })
  );
};
```

组件如下:   

```
import React, {  Component } from 'react'
import axios from 'axios'
export default class Comingsoon extends Component {

  componentWillMount(){
    axios({
        url:"/ajax/mostExpected?limit=10&offset=0&token=&optimus_uuid=B13246E07BC511EE8C86B72966AD43929DD65EA435C340D6A572D95977F59FCA&optimus_risk_level=71&optimus_code=10", 
    }).then(res=>{
        // console.log(res.data.data.films) 成功返回数据
    
    })
  }
    render() {
        return (
            <div>
                Comingsoon
            </div>
        )
    }
}

```

## 二十三  css module

官网

https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet

引入背景：

react是单页面， 每个组件引入的css样式，编译时，会自动插入到index.html页面中，造成样式污染。

film.css

```
.father{
  border: 1px solid red;
}
```

film组件

```
import '../css/film.css' //导入 css模块，  webpack的支持。

        return (
                <div className='father'>导航栏</div>
```

子组件

```
  render() {
        return (
            <div className='father'>
                Comingsoon
            </div>
```

父组件引入的样式， 污染到了子组件。

解决方式：

file.css 文件名字，改造为film.module.css   规定写法

```
.father{
  border: 1px solid red;
  .child{
    color: yellow;
  }
}
#id{
  color: red;
}


私有样式文件中  写全局css   ；建议如果是项目全局css, 单独新建一个 common.css 比较好。
:global(.active){

}

```

film.js组件

```
import style from  '../css/film.module.css' //导入 css模块，  webpack的支持。

    render() {
        return (
            <div>
                <div className={style.father +" othercss"}>导航栏</div>  
                //变量写法 因为类名加后缀动态化 私有化


css 打印出来变量名字 和js相似
console.log(style)
{
father: 'film_father__HgGKs', 
child: 'film_child__2Bvwp', 
id: 'film_id__2TOI9'
}

```











## 其他



### hooks中记住状态的方式

useRef

### 关于生命周期

*1.类组件 Class Component* 有生命周期概念。

2.函数组件*Function Component* 不存在生命周期，

默认不能使用生命周期 如果要使用 那么就要使用HOOK来完成。

react16.8版本之后新增的一个概念

HOOK---useEffect

**useEffect就可以让函数组件使用生命周期---他会在 挂载完毕 修改完毕 准备销毁 这三个阶段都触发**

语法：

```
useEffect(第一个参数是一个函数,第二个参数是一个数组)
```